<html lang="en">
    <head>
        <meta charset="UTF-8"/>
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"/>
        <base href="./">
        <link rel="icon" type="image/png" href="./favicon.png"/>
        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link href="https://fonts.googleapis.com/css2?family=Architects+Daughter&family=DM+Sans:ital,opsz,wght@0,9..40,100..1000;1,9..40,100..1000&family=Fira+Code:wght@300..700&family=Geist+Mono:wght@100..900&family=Geist:wght@100..900&family=IBM+Plex+Mono:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;1,100;1,200;1,300;1,400;1,500;1,600;1,700&family=IBM+Plex+Sans:ital,wght@0,100..700;1,100..700&family=Inter:ital,opsz,wght@0,14..32,100..900;1,14..32,100..900&family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&family=Libre+Baskerville:ital,wght@0,400;0,700;1,400&family=Lora:ital,wght@0,400..700;1,400..700&family=Merriweather:ital,opsz,wght@0,18..144,300..900;1,18..144,300..900&family=Montserrat:ital,wght@0,100..900;1,100..900&family=Open+Sans:ital,wght@0,300..800;1,300..800&family=Outfit:wght@100..900&family=Oxanium:wght@200..800&family=Playfair+Display:ital,wght@0,400..900;1,400..900&family=Plus+Jakarta+Sans:ital,wght@0,200..800;1,200..800&family=Poppins:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&family=Roboto+Mono:ital,wght@0,100..700;1,100..700&family=Roboto:ital,wght@0,100..900;1,100..900&family=Source+Code+Pro:ital,wght@0,200..900;1,200..900&family=Source+Serif+4:ital,opsz,wght@0,8..60,200..900;1,8..60,200..900&family=Space+Grotesk:wght@300..700&family=Space+Mono:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel="stylesheet">
                <script>
                    (function(){
                        // Redirect deep links (including /index.html) to hash-based URLs so
                        // the SPA can load without server rewrites.
                        var pathname = location.pathname || '/';
                        if (!location.hash && pathname !== '/') {
                            var effectivePath = pathname === '/index.html' ? '/' : pathname;
                            var path = effectivePath + (location.search || '');
                            var newUrl = location.origin + '/#' + path.replace(/^\//, '');
                            location.replace(newUrl);
                        }
                        document.addEventListener('DOMContentLoaded', function(){
                            // Convert absolute internal links (/about) into hash links (#/about)
                            document.querySelectorAll('a[href^="/"]').forEach(function(a){
                                var href = a.getAttribute('href');
                                if (href && !href.startsWith('http') && !href.startsWith('#')) a.setAttribute('href', '#' + href);
                            });
                        });
                    })();
                </script>
                <script type="module" crossorigin src="./assets/index-BXIdmK2c.js"></script>
        <link rel="stylesheet" crossorigin href="./assets/index-Bx-BUfgU.css">
    </head>
    <style>
      @import"https://fonts.googleapis.com/css2?family=Lilita+One&family=Outfit:wght@400;500;600;700;800&display=swap";*,:before,:after {
    --tw-border-spacing-x: 0;
    --tw-border-spacing-y: 0;
    --tw-translate-x: 0;
    --tw-translate-y: 0;
    --tw-rotate: 0;
    --tw-skew-x: 0;
    --tw-skew-y: 0;
    --tw-scale-x: 1;
    --tw-scale-y: 1;
    --tw-pan-x: ;
    --tw-pan-y: ;
    --tw-pinch-zoom: ;
    --tw-scroll-snap-strictness: proximity;
    --tw-gradient-from-position: ;
    --tw-gradient-via-position: ;
    --tw-gradient-to-position: ;
    --tw-ordinal: ;
    --tw-slashed-zero: ;
    --tw-numeric-figure: ;
    --tw-numeric-spacing: ;
    --tw-numeric-fraction: ;
    --tw-ring-inset: ;
    --tw-ring-offset-width: 0px;
    --tw-ring-offset-color: #fff;
    --tw-ring-color: rgb(59 130 246 / .5);
    --tw-ring-offset-shadow: 0 0 #0000;
    --tw-ring-shadow: 0 0 #0000;
    --tw-shadow: 0 0 #0000;
    --tw-shadow-colored: 0 0 #0000;
    --tw-blur: ;
    --tw-brightness: ;
    --tw-contrast: ;
    --tw-grayscale: ;
    --tw-hue-rotate: ;
    --tw-invert: ;
    --tw-saturate: ;
    --tw-sepia: ;
    --tw-drop-shadow: ;
    --tw-backdrop-blur: ;
    --tw-backdrop-brightness: ;
    --tw-backdrop-contrast: ;
    --tw-backdrop-grayscale: ;
    --tw-backdrop-hue-rotate: ;
    --tw-backdrop-invert: ;
    --tw-backdrop-opacity: ;
    --tw-backdrop-saturate: ;
    --tw-backdrop-sepia: ;
    --tw-contain-size: ;
    --tw-contain-layout: ;
    --tw-contain-paint: ;
    --tw-contain-style:
}

::backdrop {
    --tw-border-spacing-x: 0;
    --tw-border-spacing-y: 0;
    --tw-translate-x: 0;
    --tw-translate-y: 0;
    --tw-rotate: 0;
    --tw-skew-x: 0;
    --tw-skew-y: 0;
    --tw-scale-x: 1;
    --tw-scale-y: 1;
    --tw-pan-x: ;
    --tw-pan-y: ;
    --tw-pinch-zoom: ;
    --tw-scroll-snap-strictness: proximity;
    --tw-gradient-from-position: ;
    --tw-gradient-via-position: ;
    --tw-gradient-to-position: ;
    --tw-ordinal: ;
    --tw-slashed-zero: ;
    --tw-numeric-figure: ;
    --tw-numeric-spacing: ;
    --tw-numeric-fraction: ;
    --tw-ring-inset: ;
    --tw-ring-offset-width: 0px;
    --tw-ring-offset-color: #fff;
    --tw-ring-color: rgb(59 130 246 / .5);
    --tw-ring-offset-shadow: 0 0 #0000;
    --tw-ring-shadow: 0 0 #0000;
    --tw-shadow: 0 0 #0000;
    --tw-shadow-colored: 0 0 #0000;
    --tw-blur: ;
    --tw-brightness: ;
    --tw-contrast: ;
    --tw-grayscale: ;
    --tw-hue-rotate: ;
    --tw-invert: ;
    --tw-saturate: ;
    --tw-sepia: ;
    --tw-drop-shadow: ;
    --tw-backdrop-blur: ;
    --tw-backdrop-brightness: ;
    --tw-backdrop-contrast: ;
    --tw-backdrop-grayscale: ;
    --tw-backdrop-hue-rotate: ;
    --tw-backdrop-invert: ;
    --tw-backdrop-opacity: ;
    --tw-backdrop-saturate: ;
    --tw-backdrop-sepia: ;
    --tw-contain-size: ;
    --tw-contain-layout: ;
    --tw-contain-paint: ;
    --tw-contain-style:
}

*,:before,:after {
    box-sizing: border-box;
    border-width: 0;
    border-style: solid;
    border-color: #e5e7eb
}

:before,:after {
    --tw-content: ""
}

html,:host {
    line-height: 1.5;
    -webkit-text-size-adjust: 100%;
    -moz-tab-size: 4;
    -o-tab-size: 4;
    tab-size: 4;
    font-family: var(--font-sans);
    font-feature-settings: normal;
    font-variation-settings: normal;
    -webkit-tap-highlight-color: transparent
}

body {
    margin: 0;
    line-height: inherit
}

hr {
    height: 0;
    color: inherit;
    border-top-width: 1px
}

abbr:where([title]) {
    -webkit-text-decoration: underline dotted;
    text-decoration: underline dotted
}

h1,h2,h3,h4,h5,h6 {
    font-size: inherit;
    font-weight: inherit
}

a {
    color: inherit;
    text-decoration: inherit
}

b,strong {
    font-weight: bolder
}

code,kbd,samp,pre {
    font-family: var(--font-mono);
    font-feature-settings: normal;
    font-variation-settings: normal;
    font-size: 1em
}

small {
    font-size: 80%
}

sub,sup {
    font-size: 75%;
    line-height: 0;
    position: relative;
    vertical-align: baseline
}

sub {
    bottom: -.25em
}

sup {
    top: -.5em
}

table {
    text-indent: 0;
    border-color: inherit;
    border-collapse: collapse
}

button,input,optgroup,select,textarea {
    font-family: inherit;
    font-feature-settings: inherit;
    font-variation-settings: inherit;
    font-size: 100%;
    font-weight: inherit;
    line-height: inherit;
    letter-spacing: inherit;
    color: inherit;
    margin: 0;
    padding: 0
}

button,select {
    text-transform: none
}

button,input:where([type=button]),input:where([type=reset]),input:where([type=submit]) {
    -webkit-appearance: button;
    background-color: transparent;
    background-image: none
}

:-moz-focusring {
    outline: auto
}

:-moz-ui-invalid {
    box-shadow: none
}

progress {
    vertical-align: baseline
}

::-webkit-inner-spin-button,::-webkit-outer-spin-button {
    height: auto
}

[type=search] {
    -webkit-appearance: textfield;
    outline-offset: -2px
}

::-webkit-search-decoration {
    -webkit-appearance: none
}

::-webkit-file-upload-button {
    -webkit-appearance: button;
    font: inherit
}

summary {
    display: list-item
}

blockquote,dl,dd,h1,h2,h3,h4,h5,h6,hr,figure,p,pre {
    margin: 0
}

fieldset {
    margin: 0;
    padding: 0
}

legend {
    padding: 0
}

ol,ul,menu {
    list-style: none;
    margin: 0;
    padding: 0
}

dialog {
    padding: 0
}

textarea {
    resize: vertical
}

input::-moz-placeholder,textarea::-moz-placeholder {
    opacity: 1;
    color: #9ca3af
}

input::placeholder,textarea::placeholder {
    opacity: 1;
    color: #9ca3af
}

button,[role=button] {
    cursor: pointer
}

:disabled {
    cursor: default
}

img,svg,video,canvas,audio,iframe,embed,object {
    display: block;
    vertical-align: middle
}

img,video {
    max-width: 100%;
    height: auto
}

[hidden]:where(:not([hidden=until-found])) {
    display: none
}

body {
    --tw-bg-opacity: 1;
    background-color: hsl(var(--background) / var(--tw-bg-opacity, 1));
    --tw-text-opacity: 1;
    color: hsl(var(--foreground) / var(--tw-text-opacity, 1));
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale
}

body *::-moz-selection {
    --tw-bg-opacity: 1;
    background-color: hsl(var(--primary) / var(--tw-bg-opacity, 1));
    --tw-text-opacity: 1;
    color: hsl(var(--primary-foreground) / var(--tw-text-opacity, 1))
}

body *::selection {
    --tw-bg-opacity: 1;
    background-color: hsl(var(--primary) / var(--tw-bg-opacity, 1));
    --tw-text-opacity: 1;
    color: hsl(var(--primary-foreground) / var(--tw-text-opacity, 1))
}

body::-moz-selection {
    --tw-bg-opacity: 1;
    background-color: hsl(var(--primary) / var(--tw-bg-opacity, 1));
    --tw-text-opacity: 1;
    color: hsl(var(--primary-foreground) / var(--tw-text-opacity, 1))
}

body::selection {
    --tw-bg-opacity: 1;
    background-color: hsl(var(--primary) / var(--tw-bg-opacity, 1));
    --tw-text-opacity: 1;
    color: hsl(var(--primary-foreground) / var(--tw-text-opacity, 1))
}

body {
    font-family: var(--font-body);
    background-image: radial-gradient(circle at 15% 50%,rgba(255,209,0,.05) 0%,transparent 25%),radial-gradient(circle at 85% 30%,rgba(255,209,0,.05) 0%,transparent 25%);
    background-attachment: fixed
}

h1,h2,h3,h4,h5,h6 {
    font-family: var(--font-display);
    text-transform: uppercase;
    letter-spacing: .025em;
    text-shadow: 2px 2px 0px rgba(0,0,0,.5)
}

.container {
    width: 100%
}

@media(min-width: 640px) {
    .container {
        max-width:640px
    }
}

@media(min-width: 768px) {
    .container {
        max-width:768px
    }
}

@media(min-width: 1024px) {
    .container {
        max-width:1024px
    }
}

@media(min-width: 1280px) {
    .container {
        max-width:1280px
    }
}

@media(min-width: 1536px) {
    .container {
        max-width:1536px
    }
}

.prose {
    color: var(--tw-prose-body);
    max-width: 65ch
}

.prose :where(p):not(:where([class~=not-prose],[class~=not-prose] *)) {
    margin-top: 1.25em;
    margin-bottom: 1.25em
}

.prose :where([class~=lead]):not(:where([class~=not-prose],[class~=not-prose] *)) {
    color: var(--tw-prose-lead);
    font-size: 1.25em;
    line-height: 1.6;
    margin-top: 1.2em;
    margin-bottom: 1.2em
}

.prose :where(a):not(:where([class~=not-prose],[class~=not-prose] *)) {
    color: var(--tw-prose-links);
    text-decoration: underline;
    font-weight: 500
}

.prose :where(strong):not(:where([class~=not-prose],[class~=not-prose] *)) {
    color: var(--tw-prose-bold);
    font-weight: 600
}

.prose :where(a strong):not(:where([class~=not-prose],[class~=not-prose] *)) {
    color: inherit
}

.prose :where(blockquote strong):not(:where([class~=not-prose],[class~=not-prose] *)) {
    color: inherit
}

.prose :where(thead th strong):not(:where([class~=not-prose],[class~=not-prose] *)) {
    color: inherit
}

.prose :where(ol):not(:where([class~=not-prose],[class~=not-prose] *)) {
    list-style-type: decimal;
    margin-top: 1.25em;
    margin-bottom: 1.25em;
    padding-inline-start:1.625em}

.prose :where(ol[type=A]):not(:where([class~=not-prose],[class~=not-prose] *)) {
    list-style-type: upper-alpha
}

.prose :where(ol[type=a]):not(:where([class~=not-prose],[class~=not-prose] *)) {
    list-style-type: lower-alpha
}

.prose :where(ol[type=A s]):not(:where([class~=not-prose],[class~=not-prose] *)) {
    list-style-type: upper-alpha
}

.prose :where(ol[type=a s]):not(:where([class~=not-prose],[class~=not-prose] *)) {
    list-style-type: lower-alpha
}

.prose :where(ol[type=I]):not(:where([class~=not-prose],[class~=not-prose] *)) {
    list-style-type: upper-roman
}

.prose :where(ol[type=i]):not(:where([class~=not-prose],[class~=not-prose] *)) {
    list-style-type: lower-roman
}

.prose :where(ol[type=I s]):not(:where([class~=not-prose],[class~=not-prose] *)) {
    list-style-type: upper-roman
}

.prose :where(ol[type=i s]):not(:where([class~=not-prose],[class~=not-prose] *)) {
    list-style-type: lower-roman
}

.prose :where(ol[type="1"]):not(:where([class~=not-prose],[class~=not-prose] *)) {
    list-style-type: decimal
}

.prose :where(ul):not(:where([class~=not-prose],[class~=not-prose] *)) {
    list-style-type: disc;
    margin-top: 1.25em;
    margin-bottom: 1.25em;
    padding-inline-start:1.625em}

.prose :where(ol>li):not(:where([class~=not-prose],[class~=not-prose] *))::marker {
    font-weight: 400;
    color: var(--tw-prose-counters)
}

.prose :where(ul>li):not(:where([class~=not-prose],[class~=not-prose] *))::marker {
    color: var(--tw-prose-bullets)
}

.prose :where(dt):not(:where([class~=not-prose],[class~=not-prose] *)) {
    color: var(--tw-prose-headings);
    font-weight: 600;
    margin-top: 1.25em
}

.prose :where(hr):not(:where([class~=not-prose],[class~=not-prose] *)) {
    border-color: var(--tw-prose-hr);
    border-top-width: 1px;
    margin-top: 3em;
    margin-bottom: 3em
}

.prose :where(blockquote):not(:where([class~=not-prose],[class~=not-prose] *)) {
    font-weight: 500;
    font-style: italic;
    color: var(--tw-prose-quotes);
    border-inline-start-width:.25rem;border-inline-start-color:var(--tw-prose-quote-borders);quotes: "“""”""‘""’";
    margin-top: 1.6em;
    margin-bottom: 1.6em;
    padding-inline-start:1em}

.prose :where(blockquote p:first-of-type):not(:where([class~=not-prose],[class~=not-prose] *)):before {
    content: open-quote
}

.prose :where(blockquote p:last-of-type):not(:where([class~=not-prose],[class~=not-prose] *)):after {
    content: close-quote
}

.prose :where(h1):not(:where([class~=not-prose],[class~=not-prose] *)) {
    color: var(--tw-prose-headings);
    font-weight: 800;
    font-size: 2.25em;
    margin-top: 0;
    margin-bottom: .8888889em;
    line-height: 1.1111111
}

.prose :where(h1 strong):not(:where([class~=not-prose],[class~=not-prose] *)) {
    font-weight: 900;
    color: inherit
}

.prose :where(h2):not(:where([class~=not-prose],[class~=not-prose] *)) {
    color: var(--tw-prose-headings);
    font-weight: 700;
    font-size: 1.5em;
    margin-top: 2em;
    margin-bottom: 1em;
    line-height: 1.3333333
}

.prose :where(h2 strong):not(:where([class~=not-prose],[class~=not-prose] *)) {
    font-weight: 800;
    color: inherit
}

.prose :where(h3):not(:where([class~=not-prose],[class~=not-prose] *)) {
    color: var(--tw-prose-headings);
    font-weight: 600;
    font-size: 1.25em;
    margin-top: 1.6em;
    margin-bottom: .6em;
    line-height: 1.6
}

.prose :where(h3 strong):not(:where([class~=not-prose],[class~=not-prose] *)) {
    font-weight: 700;
    color: inherit
}

.prose :where(h4):not(:where([class~=not-prose],[class~=not-prose] *)) {
    color: var(--tw-prose-headings);
    font-weight: 600;
    margin-top: 1.5em;
    margin-bottom: .5em;
    line-height: 1.5
}

.prose :where(h4 strong):not(:where([class~=not-prose],[class~=not-prose] *)) {
    font-weight: 700;
    color: inherit
}

.prose :where(img):not(:where([class~=not-prose],[class~=not-prose] *)) {
    margin-top: 2em;
    margin-bottom: 2em
}

.prose :where(picture):not(:where([class~=not-prose],[class~=not-prose] *)) {
    display: block;
    margin-top: 2em;
    margin-bottom: 2em
}

.prose :where(video):not(:where([class~=not-prose],[class~=not-prose] *)) {
    margin-top: 2em;
    margin-bottom: 2em
}

.prose :where(kbd):not(:where([class~=not-prose],[class~=not-prose] *)) {
    font-weight: 500;
    font-family: inherit;
    color: var(--tw-prose-kbd);
    box-shadow: 0 0 0 1px rgb(var(--tw-prose-kbd-shadows) / 10%),0 3px rgb(var(--tw-prose-kbd-shadows) / 10%);
    font-size: .875em;
    border-radius: .3125rem;
    padding-top: .1875em;
    padding-inline-end:.375em;padding-bottom: .1875em;
    padding-inline-start:.375em}

.prose :where(code):not(:where([class~=not-prose],[class~=not-prose] *)) {
    color: var(--tw-prose-code);
    font-weight: 600;
    font-size: .875em
}

.prose :where(code):not(:where([class~=not-prose],[class~=not-prose] *)):before {
    content: "`"
}

.prose :where(code):not(:where([class~=not-prose],[class~=not-prose] *)):after {
    content: "`"
}

.prose :where(a code):not(:where([class~=not-prose],[class~=not-prose] *)) {
    color: inherit
}

.prose :where(h1 code):not(:where([class~=not-prose],[class~=not-prose] *)) {
    color: inherit
}

.prose :where(h2 code):not(:where([class~=not-prose],[class~=not-prose] *)) {
    color: inherit;
    font-size: .875em
}

.prose :where(h3 code):not(:where([class~=not-prose],[class~=not-prose] *)) {
    color: inherit;
    font-size: .9em
}

.prose :where(h4 code):not(:where([class~=not-prose],[class~=not-prose] *)) {
    color: inherit
}

.prose :where(blockquote code):not(:where([class~=not-prose],[class~=not-prose] *)) {
    color: inherit
}

.prose :where(thead th code):not(:where([class~=not-prose],[class~=not-prose] *)) {
    color: inherit
}

.prose :where(pre):not(:where([class~=not-prose],[class~=not-prose] *)) {
    color: var(--tw-prose-pre-code);
    background-color: var(--tw-prose-pre-bg);
    overflow-x: auto;
    font-weight: 400;
    font-size: .875em;
    line-height: 1.7142857;
    margin-top: 1.7142857em;
    margin-bottom: 1.7142857em;
    border-radius: .375rem;
    padding-top: .8571429em;
    padding-inline-end:1.1428571em;padding-bottom: .8571429em;
    padding-inline-start:1.1428571em}

.prose :where(pre code):not(:where([class~=not-prose],[class~=not-prose] *)) {
    background-color: transparent;
    border-width: 0;
    border-radius: 0;
    padding: 0;
    font-weight: inherit;
    color: inherit;
    font-size: inherit;
    font-family: inherit;
    line-height: inherit
}

.prose :where(pre code):not(:where([class~=not-prose],[class~=not-prose] *)):before {
    content: none
}

.prose :where(pre code):not(:where([class~=not-prose],[class~=not-prose] *)):after {
    content: none
}

.prose :where(table):not(:where([class~=not-prose],[class~=not-prose] *)) {
    width: 100%;
    table-layout: auto;
    margin-top: 2em;
    margin-bottom: 2em;
    font-size: .875em;
    line-height: 1.7142857
}

.prose :where(thead):not(:where([class~=not-prose],[class~=not-prose] *)) {
    border-bottom-width: 1px;
    border-bottom-color: var(--tw-prose-th-borders)
}

.prose :where(thead th):not(:where([class~=not-prose],[class~=not-prose] *)) {
    color: var(--tw-prose-headings);
    font-weight: 600;
    vertical-align: bottom;
    padding-inline-end:.5714286em;padding-bottom: .5714286em;
    padding-inline-start:.5714286em}

.prose :where(tbody tr):not(:where([class~=not-prose],[class~=not-prose] *)) {
    border-bottom-width: 1px;
    border-bottom-color: var(--tw-prose-td-borders)
}

.prose :where(tbody tr:last-child):not(:where([class~=not-prose],[class~=not-prose] *)) {
    border-bottom-width: 0
}

.prose :where(tbody td):not(:where([class~=not-prose],[class~=not-prose] *)) {
    vertical-align: baseline
}

.prose :where(tfoot):not(:where([class~=not-prose],[class~=not-prose] *)) {
    border-top-width: 1px;
    border-top-color: var(--tw-prose-th-borders)
}

.prose :where(tfoot td):not(:where([class~=not-prose],[class~=not-prose] *)) {
    vertical-align: top
}

.prose :where(th,td):not(:where([class~=not-prose],[class~=not-prose] *)) {
    text-align: start
}

.prose :where(figure>*):not(:where([class~=not-prose],[class~=not-prose] *)) {
    margin-top: 0;
    margin-bottom: 0
}

.prose :where(figcaption):not(:where([class~=not-prose],[class~=not-prose] *)) {
    color: var(--tw-prose-captions);
    font-size: .875em;
    line-height: 1.4285714;
    margin-top: .8571429em
}

.prose {
    --tw-prose-body: #374151;
    --tw-prose-headings: #111827;
    --tw-prose-lead: #4b5563;
    --tw-prose-links: #111827;
    --tw-prose-bold: #111827;
    --tw-prose-counters: #6b7280;
    --tw-prose-bullets: #d1d5db;
    --tw-prose-hr: #e5e7eb;
    --tw-prose-quotes: #111827;
    --tw-prose-quote-borders: #e5e7eb;
    --tw-prose-captions: #6b7280;
    --tw-prose-kbd: #111827;
    --tw-prose-kbd-shadows: 17 24 39;
    --tw-prose-code: #111827;
    --tw-prose-pre-code: #e5e7eb;
    --tw-prose-pre-bg: #1f2937;
    --tw-prose-th-borders: #d1d5db;
    --tw-prose-td-borders: #e5e7eb;
    --tw-prose-invert-body: #d1d5db;
    --tw-prose-invert-headings: #fff;
    --tw-prose-invert-lead: #9ca3af;
    --tw-prose-invert-links: #fff;
    --tw-prose-invert-bold: #fff;
    --tw-prose-invert-counters: #9ca3af;
    --tw-prose-invert-bullets: #4b5563;
    --tw-prose-invert-hr: #374151;
    --tw-prose-invert-quotes: #f3f4f6;
    --tw-prose-invert-quote-borders: #374151;
    --tw-prose-invert-captions: #9ca3af;
    --tw-prose-invert-kbd: #fff;
    --tw-prose-invert-kbd-shadows: 255 255 255;
    --tw-prose-invert-code: #fff;
    --tw-prose-invert-pre-code: #d1d5db;
    --tw-prose-invert-pre-bg: rgb(0 0 0 / 50%);
    --tw-prose-invert-th-borders: #4b5563;
    --tw-prose-invert-td-borders: #374151;
    font-size: 1rem;
    line-height: 1.75
}

.prose :where(picture>img):not(:where([class~=not-prose],[class~=not-prose] *)) {
    margin-top: 0;
    margin-bottom: 0
}

.prose :where(li):not(:where([class~=not-prose],[class~=not-prose] *)) {
    margin-top: .5em;
    margin-bottom: .5em
}

.prose :where(ol>li):not(:where([class~=not-prose],[class~=not-prose] *)) {
    padding-inline-start:.375em}

.prose :where(ul>li):not(:where([class~=not-prose],[class~=not-prose] *)) {
    padding-inline-start:.375em}

.prose :where(.prose>ul>li p):not(:where([class~=not-prose],[class~=not-prose] *)) {
    margin-top: .75em;
    margin-bottom: .75em
}

.prose :where(.prose>ul>li>p:first-child):not(:where([class~=not-prose],[class~=not-prose] *)) {
    margin-top: 1.25em
}

.prose :where(.prose>ul>li>p:last-child):not(:where([class~=not-prose],[class~=not-prose] *)) {
    margin-bottom: 1.25em
}

.prose :where(.prose>ol>li>p:first-child):not(:where([class~=not-prose],[class~=not-prose] *)) {
    margin-top: 1.25em
}

.prose :where(.prose>ol>li>p:last-child):not(:where([class~=not-prose],[class~=not-prose] *)) {
    margin-bottom: 1.25em
}

.prose :where(ul ul,ul ol,ol ul,ol ol):not(:where([class~=not-prose],[class~=not-prose] *)) {
    margin-top: .75em;
    margin-bottom: .75em
}

.prose :where(dl):not(:where([class~=not-prose],[class~=not-prose] *)) {
    margin-top: 1.25em;
    margin-bottom: 1.25em
}

.prose :where(dd):not(:where([class~=not-prose],[class~=not-prose] *)) {
    margin-top: .5em;
    padding-inline-start:1.625em}

.prose :where(hr+*):not(:where([class~=not-prose],[class~=not-prose] *)) {
    margin-top: 0
}

.prose :where(h2+*):not(:where([class~=not-prose],[class~=not-prose] *)) {
    margin-top: 0
}

.prose :where(h3+*):not(:where([class~=not-prose],[class~=not-prose] *)) {
    margin-top: 0
}

.prose :where(h4+*):not(:where([class~=not-prose],[class~=not-prose] *)) {
    margin-top: 0
}

.prose :where(thead th:first-child):not(:where([class~=not-prose],[class~=not-prose] *)) {
    padding-inline-start:0}

.prose :where(thead th:last-child):not(:where([class~=not-prose],[class~=not-prose] *)) {
    padding-inline-end:0}

.prose :where(tbody td,tfoot td):not(:where([class~=not-prose],[class~=not-prose] *)) {
    padding-top: .5714286em;
    padding-inline-end:.5714286em;padding-bottom: .5714286em;
    padding-inline-start:.5714286em}

.prose :where(tbody td:first-child,tfoot td:first-child):not(:where([class~=not-prose],[class~=not-prose] *)) {
    padding-inline-start:0}

.prose :where(tbody td:last-child,tfoot td:last-child):not(:where([class~=not-prose],[class~=not-prose] *)) {
    padding-inline-end:0}

.prose :where(figure):not(:where([class~=not-prose],[class~=not-prose] *)) {
    margin-top: 2em;
    margin-bottom: 2em
}

.prose :where(.prose>:first-child):not(:where([class~=not-prose],[class~=not-prose] *)) {
    margin-top: 0
}

.prose :where(.prose>:last-child):not(:where([class~=not-prose],[class~=not-prose] *)) {
    margin-bottom: 0
}

.prose-invert {
    --tw-prose-body: var(--tw-prose-invert-body);
    --tw-prose-headings: var(--tw-prose-invert-headings);
    --tw-prose-lead: var(--tw-prose-invert-lead);
    --tw-prose-links: var(--tw-prose-invert-links);
    --tw-prose-bold: var(--tw-prose-invert-bold);
    --tw-prose-counters: var(--tw-prose-invert-counters);
    --tw-prose-bullets: var(--tw-prose-invert-bullets);
    --tw-prose-hr: var(--tw-prose-invert-hr);
    --tw-prose-quotes: var(--tw-prose-invert-quotes);
    --tw-prose-quote-borders: var(--tw-prose-invert-quote-borders);
    --tw-prose-captions: var(--tw-prose-invert-captions);
    --tw-prose-kbd: var(--tw-prose-invert-kbd);
    --tw-prose-kbd-shadows: var(--tw-prose-invert-kbd-shadows);
    --tw-prose-code: var(--tw-prose-invert-code);
    --tw-prose-pre-code: var(--tw-prose-invert-pre-code);
    --tw-prose-pre-bg: var(--tw-prose-invert-pre-bg);
    --tw-prose-th-borders: var(--tw-prose-invert-th-borders);
    --tw-prose-td-borders: var(--tw-prose-invert-td-borders)
}

.sr-only {
    position: absolute;
    width: 1px;
    height: 1px;
    padding: 0;
    margin: -1px;
    overflow: hidden;
    clip: rect(0,0,0,0);
    white-space: nowrap;
    border-width: 0
}

.pointer-events-none {
    pointer-events: none
}

.pointer-events-auto {
    pointer-events: auto
}

.visible {
    visibility: visible
}

.invisible {
    visibility: hidden
}

.fixed {
    position: fixed
}

.absolute {
    position: absolute
}

.relative {
    position: relative
}

.sticky {
    position: sticky
}

.inset-0 {
    inset: 0
}

.inset-x-0 {
    left: 0;
    right: 0
}

.inset-y-0 {
    top: 0;
    bottom: 0
}

.-bottom-10 {
    bottom: -2.5rem
}

.-bottom-12 {
    bottom: -3rem
}

.-left-12 {
    left: -3rem
}

.-right-10 {
    right: -2.5rem
}

.-right-12 {
    right: -3rem
}

.-top-12 {
    top: -3rem
}

.bottom-0 {
    bottom: 0
}

.left-0 {
    left: 0
}

.left-1 {
    left: .25rem
}

.left-1\/2 {
    left: 50%
}

.left-2 {
    left: .5rem
}

.left-\[-10\%\] {
    left: -10%
}

.left-\[50\%\] {
    left: 50%
}

.right-0 {
    right: 0
}

.right-1 {
    right: .25rem
}

.right-2 {
    right: .5rem
}

.right-3 {
    right: .75rem
}

.right-4 {
    right: 1rem
}

.right-\[-5\%\] {
    right: -5%
}

.top-0 {
    top: 0
}

.top-1\.5 {
    top: .375rem
}

.top-1\/2 {
    top: 50%
}

.top-2 {
    top: .5rem
}

.top-3\.5 {
    top: .875rem
}

.top-4 {
    top: 1rem
}

.top-\[-10\%\] {
    top: -10%
}

.top-\[1px\] {
    top: 1px
}

.top-\[50\%\] {
    top: 50%
}

.top-\[60\%\] {
    top: 60%
}

.top-full {
    top: 100%
}

.z-0 {
    z-index: 0
}

.z-10 {
    z-index: 10
}

.z-20 {
    z-index: 20
}

.z-30 {
    z-index: 30
}

.z-50 {
    z-index: 50
}

.z-\[100\] {
    z-index: 100
}

.z-\[1\] {
    z-index: 1
}

.col-span-full {
    grid-column: 1 / -1
}

.-mx-1 {
    margin-left: -.25rem;
    margin-right: -.25rem
}

.mx-2 {
    margin-left: .5rem;
    margin-right: .5rem
}

.mx-3\.5 {
    margin-left: .875rem;
    margin-right: .875rem
}

.mx-4 {
    margin-left: 1rem;
    margin-right: 1rem
}

.mx-auto {
    margin-left: auto;
    margin-right: auto
}

.my-0\.5 {
    margin-top: .125rem;
    margin-bottom: .125rem
}

.my-1 {
    margin-top: .25rem;
    margin-bottom: .25rem
}

.-ml-4 {
    margin-left: -1rem
}

.-mt-20 {
    margin-top: -5rem
}

.-mt-4 {
    margin-top: -1rem
}

.-mt-6 {
    margin-top: -1.5rem
}

.-mt-8 {
    margin-top: -2rem
}

.mb-1 {
    margin-bottom: .25rem
}

.mb-10 {
    margin-bottom: 2.5rem
}

.mb-12 {
    margin-bottom: 3rem
}

.mb-16 {
    margin-bottom: 4rem
}

.mb-2 {
    margin-bottom: .5rem
}

.mb-3 {
    margin-bottom: .75rem
}

.mb-32 {
    margin-bottom: 8rem
}

.mb-4 {
    margin-bottom: 1rem
}

.mb-6 {
    margin-bottom: 1.5rem
}

.mb-8 {
    margin-bottom: 2rem
}

.ml-1 {
    margin-left: .25rem
}

.ml-2 {
    margin-left: .5rem
}

.ml-auto {
    margin-left: auto
}

.mr-1 {
    margin-right: .25rem
}

.mr-2 {
    margin-right: .5rem
}

.mt-1\.5 {
    margin-top: .375rem
}

.mt-2 {
    margin-top: .5rem
}

.mt-24 {
    margin-top: 6rem
}

.mt-4 {
    margin-top: 1rem
}

.mt-6 {
    margin-top: 1.5rem
}

.mt-8 {
    margin-top: 2rem
}

.mt-auto {
    margin-top: auto
}

.line-clamp-3 {
    overflow: hidden;
    display: -webkit-box;
    -webkit-box-orient: vertical;
    -webkit-line-clamp: 3
}

.block {
    display: block
}

.flex {
    display: flex
}

.inline-flex {
    display: inline-flex
}

.table {
    display: table
}

.grid {
    display: grid
}

.hidden {
    display: none
}

.aspect-square {
    aspect-ratio: 1 / 1
}

.aspect-video {
    aspect-ratio: 16 / 9
}

.size-4 {
    width: 1rem;
    height: 1rem
}

.h-1\.5 {
    height: .375rem
}

.h-10 {
    height: 2.5rem
}

.h-11 {
    height: 2.75rem
}

.h-12 {
    height: 3rem
}

.h-14 {
    height: 3.5rem
}

.h-16 {
    height: 4rem
}

.h-2 {
    height: .5rem
}

.h-2\.5 {
    height: .625rem
}

.h-20 {
    height: 5rem
}

.h-3 {
    height: .75rem
}

.h-3\.5 {
    height: .875rem
}

.h-4 {
    height: 1rem
}

.h-40 {
    height: 10rem
}

.h-48 {
    height: 12rem
}

.h-5 {
    height: 1.25rem
}

.h-6 {
    height: 1.5rem
}

.h-7 {
    height: 1.75rem
}

.h-8 {
    height: 2rem
}

.h-9 {
    height: 2.25rem
}

.h-\[1px\] {
    height: 1px
}

.h-\[400px\] {
    height: 400px
}

.h-\[500px\] {
    height: 500px
}

.h-\[600px\] {
    height: 600px
}

.h-\[var\(--radix-navigation-menu-viewport-height\)\] {
    height: var(--radix-navigation-menu-viewport-height)
}

.h-\[var\(--radix-select-trigger-height\)\] {
    height: var(--radix-select-trigger-height)
}

.h-auto {
    height: auto
}

.h-full {
    height: 100%
}

.h-px {
    height: 1px
}

.h-svh {
    height: 100svh
}

.max-h-\[--radix-context-menu-content-available-height\] {
    max-height: var(--radix-context-menu-content-available-height)
}

.max-h-\[--radix-select-content-available-height\] {
    max-height: var(--radix-select-content-available-height)
}

.max-h-\[300px\] {
    max-height: 300px
}

.max-h-\[90vh\] {
    max-height: 90vh
}

.max-h-\[var\(--radix-dropdown-menu-content-available-height\)\] {
    max-height: var(--radix-dropdown-menu-content-available-height)
}

.max-h-screen {
    max-height: 100vh
}

.min-h-0 {
    min-height: 0px
}

.min-h-10 {
    min-height: 2.5rem
}

.min-h-8 {
    min-height: 2rem
}

.min-h-9 {
    min-height: 2.25rem
}

.min-h-\[400px\] {
    min-height: 400px
}

.min-h-\[80px\] {
    min-height: 80px
}

.min-h-screen {
    min-height: 100vh
}

.min-h-svh {
    min-height: 100svh
}

.w-0 {
    width: 0px
}

.w-1 {
    width: .25rem
}

.w-10 {
    width: 2.5rem
}

.w-11 {
    width: 2.75rem
}

.w-12 {
    width: 3rem
}

.w-16 {
    width: 4rem
}

.w-2 {
    width: .5rem
}

.w-2\.5 {
    width: .625rem
}

.w-2\/3 {
    width: 66.666667%
}

.w-3 {
    width: .75rem
}

.w-3\.5 {
    width: .875rem
}

.w-3\/4 {
    width: 75%
}

.w-4 {
    width: 1rem
}

.w-40 {
    width: 10rem
}

.w-5 {
    width: 1.25rem
}

.w-6 {
    width: 1.5rem
}

.w-64 {
    width: 16rem
}

.w-7 {
    width: 1.75rem
}

.w-72 {
    width: 18rem
}

.w-8 {
    width: 2rem
}

.w-9 {
    width: 2.25rem
}

.w-\[100px\] {
    width: 100px
}

.w-\[1px\] {
    width: 1px
}

.w-\[500px\] {
    width: 500px
}

.w-\[600px\] {
    width: 600px
}

.w-\[var\(--sidebar-width\)\] {
    width: var(--sidebar-width)
}

.w-auto {
    width: auto
}

.w-full {
    width: 100%
}

.w-max {
    width: -moz-max-content;
    width: max-content
}

.w-px {
    width: 1px
}

.min-w-0 {
    min-width: 0px
}

.min-w-10 {
    min-width: 2.5rem
}

.min-w-11 {
    min-width: 2.75rem
}

.min-w-5 {
    min-width: 1.25rem
}

.min-w-9 {
    min-width: 2.25rem
}

.min-w-\[12rem\] {
    min-width: 12rem
}

.min-w-\[8rem\] {
    min-width: 8rem
}

.min-w-\[var\(--radix-select-trigger-width\)\] {
    min-width: var(--radix-select-trigger-width)
}

.max-w-2xl {
    max-width: 42rem
}

.max-w-3xl {
    max-width: 48rem
}

.max-w-4xl {
    max-width: 56rem
}

.max-w-\[var\(--skeleton-width\)\] {
    max-width: var(--skeleton-width)
}

.max-w-lg {
    max-width: 32rem
}

.max-w-max {
    max-width: -moz-max-content;
    max-width: max-content
}

.max-w-md {
    max-width: 28rem
}

.max-w-none {
    max-width: none
}

.max-w-xl {
    max-width: 36rem
}

.flex-1 {
    flex: 1 1 0%
}

.shrink-0 {
    flex-shrink: 0
}

.grow {
    flex-grow: 1
}

.grow-0 {
    flex-grow: 0
}

.basis-full {
    flex-basis: 100%
}

.caption-bottom {
    caption-side: bottom
}

.border-collapse {
    border-collapse: collapse
}

.origin-\[--radix-context-menu-content-transform-origin\] {
    transform-origin: var(--radix-context-menu-content-transform-origin)
}

.origin-\[--radix-dropdown-menu-content-transform-origin\] {
    transform-origin: var(--radix-dropdown-menu-content-transform-origin)
}

.origin-\[--radix-hover-card-content-transform-origin\] {
    transform-origin: var(--radix-hover-card-content-transform-origin)
}

.origin-\[--radix-menubar-content-transform-origin\] {
    transform-origin: var(--radix-menubar-content-transform-origin)
}

.origin-\[--radix-popover-content-transform-origin\] {
    transform-origin: var(--radix-popover-content-transform-origin)
}

.origin-\[--radix-select-content-transform-origin\] {
    transform-origin: var(--radix-select-content-transform-origin)
}

.origin-\[--radix-tooltip-content-transform-origin\] {
    transform-origin: var(--radix-tooltip-content-transform-origin)
}

.-translate-x-1\/2 {
    --tw-translate-x: -50%;
    transform: translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))
}

.-translate-x-px {
    --tw-translate-x: -1px;
    transform: translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))
}

.-translate-y-1\/2 {
    --tw-translate-y: -50%;
    transform: translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))
}

.translate-x-\[-50\%\] {
    --tw-translate-x: -50%;
    transform: translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))
}

.translate-x-px {
    --tw-translate-x: 1px;
    transform: translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))
}

.translate-y-\[-50\%\] {
    --tw-translate-y: -50%;
    transform: translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))
}

.rotate-45 {
    --tw-rotate: 45deg;
    transform: translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))
}

.rotate-90 {
    --tw-rotate: 90deg;
    transform: translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))
}

.transform {
    transform: translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))
}

@keyframes pulse {
    50% {
        opacity: .5
    }
}

.animate-pulse {
    animation: pulse 2s cubic-bezier(.4,0,.6,1) infinite
}

@keyframes spin {
    to {
        transform: rotate(360deg)
    }
}

.animate-spin {
    animation: spin 1s linear infinite
}

.cursor-default {
    cursor: default
}

.cursor-pointer {
    cursor: pointer
}

.touch-none {
    touch-action: none
}

.select-none {
    -webkit-user-select: none;
    -moz-user-select: none;
    user-select: none
}

.list-disc {
    list-style-type: disc
}

.list-none {
    list-style-type: none
}

.grid-cols-1 {
    grid-template-columns: repeat(1,minmax(0,1fr))
}

.grid-cols-2 {
    grid-template-columns: repeat(2,minmax(0,1fr))
}

.flex-row {
    flex-direction: row
}

.flex-col {
    flex-direction: column
}

.flex-col-reverse {
    flex-direction: column-reverse
}

.flex-wrap {
    flex-wrap: wrap
}

.flex-nowrap {
    flex-wrap: nowrap
}

.items-start {
    align-items: flex-start
}

.items-end {
    align-items: flex-end
}

.items-center {
    align-items: center
}

.items-stretch {
    align-items: stretch
}

.justify-start {
    justify-content: flex-start
}

.justify-center {
    justify-content: center
}

.justify-between {
    justify-content: space-between
}

.gap-1 {
    gap: .25rem
}

.gap-1\.5 {
    gap: .375rem
}

.gap-2 {
    gap: .5rem
}

.gap-3 {
    gap: .75rem
}

.gap-4 {
    gap: 1rem
}

.gap-6 {
    gap: 1.5rem
}

.gap-8 {
    gap: 2rem
}

.space-x-1>:not([hidden])~:not([hidden]) {
    --tw-space-x-reverse: 0;
    margin-right: calc(.25rem * var(--tw-space-x-reverse));
    margin-left: calc(.25rem * calc(1 - var(--tw-space-x-reverse)))
}

.space-x-4>:not([hidden])~:not([hidden]) {
    --tw-space-x-reverse: 0;
    margin-right: calc(1rem * var(--tw-space-x-reverse));
    margin-left: calc(1rem * calc(1 - var(--tw-space-x-reverse)))
}

.space-y-1>:not([hidden])~:not([hidden]) {
    --tw-space-y-reverse: 0;
    margin-top: calc(.25rem * calc(1 - var(--tw-space-y-reverse)));
    margin-bottom: calc(.25rem * var(--tw-space-y-reverse))
}

.space-y-1\.5>:not([hidden])~:not([hidden]) {
    --tw-space-y-reverse: 0;
    margin-top: calc(.375rem * calc(1 - var(--tw-space-y-reverse)));
    margin-bottom: calc(.375rem * var(--tw-space-y-reverse))
}

.space-y-2>:not([hidden])~:not([hidden]) {
    --tw-space-y-reverse: 0;
    margin-top: calc(.5rem * calc(1 - var(--tw-space-y-reverse)));
    margin-bottom: calc(.5rem * var(--tw-space-y-reverse))
}

.space-y-3>:not([hidden])~:not([hidden]) {
    --tw-space-y-reverse: 0;
    margin-top: calc(.75rem * calc(1 - var(--tw-space-y-reverse)));
    margin-bottom: calc(.75rem * var(--tw-space-y-reverse))
}

.space-y-4>:not([hidden])~:not([hidden]) {
    --tw-space-y-reverse: 0;
    margin-top: calc(1rem * calc(1 - var(--tw-space-y-reverse)));
    margin-bottom: calc(1rem * var(--tw-space-y-reverse))
}

.space-y-6>:not([hidden])~:not([hidden]) {
    --tw-space-y-reverse: 0;
    margin-top: calc(1.5rem * calc(1 - var(--tw-space-y-reverse)));
    margin-bottom: calc(1.5rem * var(--tw-space-y-reverse))
}

.divide-y>:not([hidden])~:not([hidden]) {
    --tw-divide-y-reverse: 0;
    border-top-width: calc(1px * calc(1 - var(--tw-divide-y-reverse)));
    border-bottom-width: calc(1px * var(--tw-divide-y-reverse))
}

.divide-white\/5>:not([hidden])~:not([hidden]) {
    border-color: #ffffff0d
}

.overflow-auto {
    overflow: auto
}

.overflow-hidden {
    overflow: hidden
}

.overflow-x-auto {
    overflow-x: auto
}

.overflow-y-auto {
    overflow-y: auto
}

.overflow-x-hidden {
    overflow-x: hidden
}

.whitespace-nowrap {
    white-space: nowrap
}

.whitespace-pre-wrap {
    white-space: pre-wrap
}

.break-words {
    overflow-wrap: break-word
}

.rounded-2xl {
    border-radius: 1rem
}

.rounded-3xl {
    border-radius: 1.5rem
}

.rounded-\[2\.5rem\] {
    border-radius: 2.5rem
}

.rounded-\[2px\] {
    border-radius: 2px
}

.rounded-\[inherit\] {
    border-radius: inherit
}

.rounded-full {
    border-radius: 9999px
}

.rounded-lg {
    border-radius: .5625rem
}

.rounded-md {
    border-radius: .375rem
}

.rounded-sm {
    border-radius: .1875rem
}

.rounded-xl {
    border-radius: .75rem
}

.rounded-t-\[10px\] {
    border-top-left-radius: 10px;
    border-top-right-radius: 10px
}

.rounded-tl-sm {
    border-top-left-radius: .1875rem
}

.border {
    border-width: 1px
}

.border-2 {
    border-width: 2px
}

.border-4 {
    border-width: 4px
}

.border-\[1\.5px\] {
    border-width: 1.5px
}

.border-y {
    border-top-width: 1px;
    border-bottom-width: 1px
}

.border-b {
    border-bottom-width: 1px
}

.border-l {
    border-left-width: 1px
}

.border-r {
    border-right-width: 1px
}

.border-t {
    border-top-width: 1px
}

.border-dashed {
    border-style: dashed
}

.border-\[--color-border\] {
    border-color: var(--color-border)
}

.border-accent {
    --tw-border-opacity: 1;
    border-color: hsl(var(--accent) / var(--tw-border-opacity, 1))
}

.border-border {
    --tw-border-opacity: 1;
    border-color: hsl(var(--border) / var(--tw-border-opacity, 1))
}

.border-border\/50 {
    border-color: hsl(var(--border) / .5)
}

.border-card-border {
    --tw-border-opacity: 1;
    border-color: hsl(var(--card-border) / var(--tw-border-opacity, 1))
}

.border-destructive {
    --tw-border-opacity: 1;
    border-color: hsl(var(--destructive) / var(--tw-border-opacity, 1))
}

.border-destructive-border {
    border-color: var(--destructive-border)
}

.border-destructive\/50 {
    border-color: hsl(var(--destructive) / .5)
}

.border-green-400 {
    --tw-border-opacity: 1;
    border-color: rgb(74 222 128 / var(--tw-border-opacity, 1))
}

.border-input {
    --tw-border-opacity: 1;
    border-color: hsl(var(--input) / var(--tw-border-opacity, 1))
}

.border-primary {
    --tw-border-opacity: 1;
    border-color: hsl(var(--primary) / var(--tw-border-opacity, 1))
}

.border-primary-border {
    border-color: var(--primary-border)
}

.border-red-400 {
    --tw-border-opacity: 1;
    border-color: rgb(248 113 113 / var(--tw-border-opacity, 1))
}

.border-secondary-border {
    border-color: var(--secondary-border)
}

.border-sidebar-border {
    --tw-border-opacity: 1;
    border-color: hsl(var(--sidebar-border) / var(--tw-border-opacity, 1))
}

.border-slate-500 {
    --tw-border-opacity: 1;
    border-color: rgb(100 116 139 / var(--tw-border-opacity, 1))
}

.border-transparent {
    border-color: transparent
}

.border-white\/10 {
    border-color: #ffffff1a
}

.border-white\/20 {
    border-color: #fff3
}

.border-white\/5 {
    border-color: #ffffff0d
}

.border-white\/50 {
    border-color: #ffffff80
}

.border-l-transparent {
    border-left-color: transparent
}

.border-t-transparent {
    border-top-color: transparent
}

.bg-\[\#2a303c\] {
    --tw-bg-opacity: 1;
    background-color: rgb(42 48 60 / var(--tw-bg-opacity, 1))
}

.bg-\[--color-bg\] {
    background-color: var(--color-bg)
}

.bg-accent {
    --tw-bg-opacity: 1;
    background-color: hsl(var(--accent) / var(--tw-bg-opacity, 1))
}

.bg-accent\/20 {
    background-color: hsl(var(--accent) / .2)
}

.bg-background {
    --tw-bg-opacity: 1;
    background-color: hsl(var(--background) / var(--tw-bg-opacity, 1))
}

.bg-background\/50 {
    background-color: hsl(var(--background) / .5)
}

.bg-background\/80 {
    background-color: hsl(var(--background) / .8)
}

.bg-black\/50 {
    background-color: #00000080
}

.bg-black\/80 {
    background-color: #000c
}

.bg-border {
    --tw-bg-opacity: 1;
    background-color: hsl(var(--border) / var(--tw-bg-opacity, 1))
}

.bg-card {
    --tw-bg-opacity: 1;
    background-color: hsl(var(--card) / var(--tw-bg-opacity, 1))
}

.bg-card\/30 {
    background-color: hsl(var(--card) / .3)
}

.bg-card\/50 {
    background-color: hsl(var(--card) / .5)
}

.bg-destructive {
    --tw-bg-opacity: 1;
    background-color: hsl(var(--destructive) / var(--tw-bg-opacity, 1))
}

.bg-foreground {
    --tw-bg-opacity: 1;
    background-color: hsl(var(--foreground) / var(--tw-bg-opacity, 1))
}

.bg-gray-50 {
    --tw-bg-opacity: 1;
    background-color: rgb(249 250 251 / var(--tw-bg-opacity, 1))
}

.bg-green-500 {
    --tw-bg-opacity: 1;
    background-color: rgb(34 197 94 / var(--tw-bg-opacity, 1))
}

.bg-muted {
    --tw-bg-opacity: 1;
    background-color: hsl(var(--muted) / var(--tw-bg-opacity, 1))
}

.bg-muted\/50 {
    background-color: hsl(var(--muted) / .5)
}

.bg-popover {
    --tw-bg-opacity: 1;
    background-color: hsl(var(--popover) / var(--tw-bg-opacity, 1))
}

.bg-primary {
    --tw-bg-opacity: 1;
    background-color: hsl(var(--primary) / var(--tw-bg-opacity, 1))
}

.bg-primary\/10 {
    background-color: hsl(var(--primary) / .1)
}

.bg-primary\/20 {
    background-color: hsl(var(--primary) / .2)
}

.bg-primary\/5 {
    background-color: hsl(var(--primary) / .05)
}

.bg-red-500 {
    --tw-bg-opacity: 1;
    background-color: rgb(239 68 68 / var(--tw-bg-opacity, 1))
}

.bg-red-500\/20 {
    background-color: #ef444433
}

.bg-secondary {
    --tw-bg-opacity: 1;
    background-color: hsl(var(--secondary) / var(--tw-bg-opacity, 1))
}

.bg-secondary\/20 {
    background-color: hsl(var(--secondary) / .2)
}

.bg-sidebar {
    --tw-bg-opacity: 1;
    background-color: hsl(var(--sidebar) / var(--tw-bg-opacity, 1))
}

.bg-sidebar-border {
    --tw-bg-opacity: 1;
    background-color: hsl(var(--sidebar-border) / var(--tw-bg-opacity, 1))
}

.bg-slate-600 {
    --tw-bg-opacity: 1;
    background-color: rgb(71 85 105 / var(--tw-bg-opacity, 1))
}

.bg-transparent {
    background-color: transparent
}

.bg-white {
    --tw-bg-opacity: 1;
    background-color: rgb(255 255 255 / var(--tw-bg-opacity, 1))
}

.bg-white\/10 {
    background-color: #ffffff1a
}

.bg-white\/20 {
    background-color: #fff3
}

.bg-white\/5 {
    background-color: #ffffff0d
}

.bg-gradient-to-br {
    background-image: linear-gradient(to bottom right,var(--tw-gradient-stops))
}

.bg-gradient-to-l {
    background-image: linear-gradient(to left,var(--tw-gradient-stops))
}

.bg-gradient-to-t {
    background-image: linear-gradient(to top,var(--tw-gradient-stops))
}

.from-background {
    --tw-gradient-from: hsl(var(--background) / 1) var(--tw-gradient-from-position);
    --tw-gradient-to: hsl(var(--background) / 0) var(--tw-gradient-to-position);
    --tw-gradient-stops: var(--tw-gradient-from), var(--tw-gradient-to)
}

.from-black\/80 {
    --tw-gradient-from: rgb(0 0 0 / .8) var(--tw-gradient-from-position);
    --tw-gradient-to: rgb(0 0 0 / 0) var(--tw-gradient-to-position);
    --tw-gradient-stops: var(--tw-gradient-from), var(--tw-gradient-to)
}

.from-card {
    --tw-gradient-from: hsl(var(--card) / 1) var(--tw-gradient-from-position);
    --tw-gradient-to: hsl(var(--card) / 0) var(--tw-gradient-to-position);
    --tw-gradient-stops: var(--tw-gradient-from), var(--tw-gradient-to)
}

.from-secondary {
    --tw-gradient-from: hsl(var(--secondary) / 1) var(--tw-gradient-from-position);
    --tw-gradient-to: hsl(var(--secondary) / 0) var(--tw-gradient-to-position);
    --tw-gradient-stops: var(--tw-gradient-from), var(--tw-gradient-to)
}

.via-background\/80 {
    --tw-gradient-to: hsl(var(--background) / 0) var(--tw-gradient-to-position);
    --tw-gradient-stops: var(--tw-gradient-from), hsl(var(--background) / .8) var(--tw-gradient-via-position), var(--tw-gradient-to)
}

.via-card\/20 {
    --tw-gradient-to: hsl(var(--card) / 0) var(--tw-gradient-to-position);
    --tw-gradient-stops: var(--tw-gradient-from), hsl(var(--card) / .2) var(--tw-gradient-via-position), var(--tw-gradient-to)
}

.to-purple-800 {
    --tw-gradient-to: #6b21a8 var(--tw-gradient-to-position)
}

.to-transparent {
    --tw-gradient-to: transparent var(--tw-gradient-to-position)
}

.fill-current {
    fill: currentColor
}

.object-cover {
    -o-object-fit: cover;
    object-fit: cover
}

.p-0 {
    padding: 0
}

.p-1 {
    padding: .25rem
}

.p-12 {
    padding: 3rem
}

.p-2 {
    padding: .5rem
}

.p-3 {
    padding: .75rem
}

.p-4 {
    padding: 1rem
}

.p-6 {
    padding: 1.5rem
}

.p-8 {
    padding: 2rem
}

.p-\[1px\] {
    padding: 1px
}

.px-1 {
    padding-left: .25rem;
    padding-right: .25rem
}

.px-2 {
    padding-left: .5rem;
    padding-right: .5rem
}

.px-2\.5 {
    padding-left: .625rem;
    padding-right: .625rem
}

.px-3 {
    padding-left: .75rem;
    padding-right: .75rem
}

.px-4 {
    padding-left: 1rem;
    padding-right: 1rem
}

.px-5 {
    padding-left: 1.25rem;
    padding-right: 1.25rem
}

.px-6 {
    padding-left: 1.5rem;
    padding-right: 1.5rem
}

.px-8 {
    padding-left: 2rem;
    padding-right: 2rem
}

.py-0\.5 {
    padding-top: .125rem;
    padding-bottom: .125rem
}

.py-1 {
    padding-top: .25rem;
    padding-bottom: .25rem
}

.py-1\.5 {
    padding-top: .375rem;
    padding-bottom: .375rem
}

.py-10 {
    padding-top: 2.5rem;
    padding-bottom: 2.5rem
}

.py-12 {
    padding-top: 3rem;
    padding-bottom: 3rem
}

.py-16 {
    padding-top: 4rem;
    padding-bottom: 4rem
}

.py-2 {
    padding-top: .5rem;
    padding-bottom: .5rem
}

.py-20 {
    padding-top: 5rem;
    padding-bottom: 5rem
}

.py-3 {
    padding-top: .75rem;
    padding-bottom: .75rem
}

.py-32 {
    padding-top: 8rem;
    padding-bottom: 8rem
}

.py-4 {
    padding-top: 1rem;
    padding-bottom: 1rem
}

.py-6 {
    padding-top: 1.5rem;
    padding-bottom: 1.5rem
}

.pb-12 {
    padding-bottom: 3rem
}

.pb-20 {
    padding-bottom: 5rem
}

.pb-3 {
    padding-bottom: .75rem
}

.pb-32 {
    padding-bottom: 8rem
}

.pb-4 {
    padding-bottom: 1rem
}

.pl-2\.5 {
    padding-left: .625rem
}

.pl-4 {
    padding-left: 1rem
}

.pl-5 {
    padding-left: 1.25rem
}

.pl-8 {
    padding-left: 2rem
}

.pr-2 {
    padding-right: .5rem
}

.pr-2\.5 {
    padding-right: .625rem
}

.pr-8 {
    padding-right: 2rem
}

.pt-0 {
    padding-top: 0
}

.pt-1 {
    padding-top: .25rem
}

.pt-20 {
    padding-top: 5rem
}

.pt-3 {
    padding-top: .75rem
}

.pt-4 {
    padding-top: 1rem
}

.pt-6 {
    padding-top: 1.5rem
}

.text-left {
    text-align: left
}

.text-center {
    text-align: center
}

.align-middle {
    vertical-align: middle
}

.font-display {
    font-family: var(--font-display)
}

.font-mono {
    font-family: var(--font-mono)
}

.text-2xl {
    font-size: 1.5rem;
    line-height: 2rem
}

.text-3xl {
    font-size: 1.875rem;
    line-height: 2.25rem
}

.text-4xl {
    font-size: 2.25rem;
    line-height: 2.5rem
}

.text-5xl {
    font-size: 3rem;
    line-height: 1
}

.text-\[0\.8rem\] {
    font-size: .8rem
}

.text-base {
    font-size: 1rem;
    line-height: 1.5rem
}

.text-lg {
    font-size: 1.125rem;
    line-height: 1.75rem
}

.text-sm {
    font-size: .875rem;
    line-height: 1.25rem
}

.text-xl {
    font-size: 1.25rem;
    line-height: 1.75rem
}

.text-xs {
    font-size: .75rem;
    line-height: 1rem
}

.font-bold {
    font-weight: 700
}

.font-medium {
    font-weight: 500
}

.font-normal {
    font-weight: 400
}

.font-semibold {
    font-weight: 600
}

.uppercase {
    text-transform: uppercase
}

.tabular-nums {
    --tw-numeric-spacing: tabular-nums;
    font-variant-numeric: var(--tw-ordinal) var(--tw-slashed-zero) var(--tw-numeric-figure) var(--tw-numeric-spacing) var(--tw-numeric-fraction)
}

.leading-\[0\.9\] {
    line-height: .9
}

.leading-none {
    line-height: 1
}

.leading-relaxed {
    line-height: 1.625
}

.leading-tight {
    line-height: 1.25
}

.tracking-tight {
    letter-spacing: -.025em
}

.tracking-wide {
    letter-spacing: .025em
}

.tracking-wider {
    letter-spacing: .05em
}

.tracking-widest {
    letter-spacing: .1em
}

.text-accent {
    --tw-text-opacity: 1;
    color: hsl(var(--accent) / var(--tw-text-opacity, 1))
}

.text-accent-foreground {
    --tw-text-opacity: 1;
    color: hsl(var(--accent-foreground) / var(--tw-text-opacity, 1))
}

.text-black {
    --tw-text-opacity: 1;
    color: rgb(0 0 0 / var(--tw-text-opacity, 1))
}

.text-card-foreground {
    --tw-text-opacity: 1;
    color: hsl(var(--card-foreground) / var(--tw-text-opacity, 1))
}

.text-current {
    color: currentColor
}

.text-destructive {
    --tw-text-opacity: 1;
    color: hsl(var(--destructive) / var(--tw-text-opacity, 1))
}

.text-destructive-foreground {
    --tw-text-opacity: 1;
    color: hsl(var(--destructive-foreground) / var(--tw-text-opacity, 1))
}

.text-foreground {
    --tw-text-opacity: 1;
    color: hsl(var(--foreground) / var(--tw-text-opacity, 1))
}

.text-foreground\/50 {
    color: hsl(var(--foreground) / .5)
}

.text-gray-200 {
    --tw-text-opacity: 1;
    color: rgb(229 231 235 / var(--tw-text-opacity, 1))
}

.text-gray-600 {
    --tw-text-opacity: 1;
    color: rgb(75 85 99 / var(--tw-text-opacity, 1))
}

.text-gray-900 {
    --tw-text-opacity: 1;
    color: rgb(17 24 39 / var(--tw-text-opacity, 1))
}

.text-muted-foreground {
    --tw-text-opacity: 1;
    color: hsl(var(--muted-foreground) / var(--tw-text-opacity, 1))
}

.text-popover-foreground {
    --tw-text-opacity: 1;
    color: hsl(var(--popover-foreground) / var(--tw-text-opacity, 1))
}

.text-primary {
    --tw-text-opacity: 1;
    color: hsl(var(--primary) / var(--tw-text-opacity, 1))
}

.text-primary-foreground {
    --tw-text-opacity: 1;
    color: hsl(var(--primary-foreground) / var(--tw-text-opacity, 1))
}

.text-red-500 {
    --tw-text-opacity: 1;
    color: rgb(239 68 68 / var(--tw-text-opacity, 1))
}

.text-secondary {
    --tw-text-opacity: 1;
    color: hsl(var(--secondary) / var(--tw-text-opacity, 1))
}

.text-secondary-foreground {
    --tw-text-opacity: 1;
    color: hsl(var(--secondary-foreground) / var(--tw-text-opacity, 1))
}

.text-sidebar-foreground {
    --tw-text-opacity: 1;
    color: hsl(var(--sidebar-foreground) / var(--tw-text-opacity, 1))
}

.text-sidebar-foreground\/70 {
    color: hsl(var(--sidebar-foreground) / .7)
}

.text-slate-200 {
    --tw-text-opacity: 1;
    color: rgb(226 232 240 / var(--tw-text-opacity, 1))
}

.text-white {
    --tw-text-opacity: 1;
    color: rgb(255 255 255 / var(--tw-text-opacity, 1))
}

.text-white\/80 {
    color: #fffc
}

.text-white\/90 {
    color: #ffffffe6
}

.opacity-0 {
    opacity: 0
}

.opacity-20 {
    opacity: .2
}

.opacity-50 {
    opacity: .5
}

.opacity-60 {
    opacity: .6
}

.opacity-70 {
    opacity: .7
}

.opacity-90 {
    opacity: .9
}

.shadow-\[0_0_0_1px_hsl\(var\(--sidebar-border\)\)\] {
    --tw-shadow: 0 0 0 1px hsl(var(--sidebar-border));
    --tw-shadow-colored: 0 0 0 1px var(--tw-shadow-color);
    box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow)
}

.shadow-lg {
    --tw-shadow: 0 10px 15px -3px rgb(0 0 0 / .1), 0 4px 6px -4px rgb(0 0 0 / .1);
    --tw-shadow-colored: 0 10px 15px -3px var(--tw-shadow-color), 0 4px 6px -4px var(--tw-shadow-color);
    box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow)
}

.shadow-md {
    --tw-shadow: 0 4px 6px -1px rgb(0 0 0 / .1), 0 2px 4px -2px rgb(0 0 0 / .1);
    --tw-shadow-colored: 0 4px 6px -1px var(--tw-shadow-color), 0 2px 4px -2px var(--tw-shadow-color);
    box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow)
}

.shadow-none {
    --tw-shadow: 0 0 #0000;
    --tw-shadow-colored: 0 0 #0000;
    box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow)
}

.shadow-sm {
    --tw-shadow: 0 1px 2px 0 rgb(0 0 0 / .05);
    --tw-shadow-colored: 0 1px 2px 0 var(--tw-shadow-color);
    box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow)
}

.shadow-xl {
    --tw-shadow: 0 20px 25px -5px rgb(0 0 0 / .1), 0 8px 10px -6px rgb(0 0 0 / .1);
    --tw-shadow-colored: 0 20px 25px -5px var(--tw-shadow-color), 0 8px 10px -6px var(--tw-shadow-color);
    box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow)
}

.shadow-accent\/20 {
    --tw-shadow-color: hsl(var(--accent) / .2);
    --tw-shadow: var(--tw-shadow-colored)
}

.shadow-black\/20 {
    --tw-shadow-color: rgb(0 0 0 / .2);
    --tw-shadow: var(--tw-shadow-colored)
}

.shadow-primary\/30 {
    --tw-shadow-color: hsl(var(--primary) / .3);
    --tw-shadow: var(--tw-shadow-colored)
}

.outline-none {
    outline: 2px solid transparent;
    outline-offset: 2px
}

.outline {
    outline-style: solid
}

.outline-2 {
    outline-width: 2px
}

.outline-offset-2 {
    outline-offset: 2px
}

.outline-transparent {
    outline-color: transparent
}

.ring-0 {
    --tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);
    --tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(0px + var(--tw-ring-offset-width)) var(--tw-ring-color);
    box-shadow: var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow, 0 0 #0000)
}

.ring-2 {
    --tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);
    --tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color);
    box-shadow: var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow, 0 0 #0000)
}

.ring-ring {
    --tw-ring-opacity: 1;
    --tw-ring-color: hsl(var(--ring) / var(--tw-ring-opacity, 1))
}

.ring-sidebar-ring {
    --tw-ring-opacity: 1;
    --tw-ring-color: hsl(var(--sidebar-ring) / var(--tw-ring-opacity, 1))
}

.ring-offset-background {
    --tw-ring-offset-color: hsl(var(--background) / 1)
}

.blur-3xl {
    --tw-blur: blur(64px);
    filter: var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow)
}

.blur-\[100px\] {
    --tw-blur: blur(100px);
    filter: var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow)
}

.blur-\[120px\] {
    --tw-blur: blur(120px);
    filter: var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow)
}

.drop-shadow-2xl {
    --tw-drop-shadow: drop-shadow(0 25px 25px rgb(0 0 0 / .15));
    filter: var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow)
}

.drop-shadow-\[0_2px_4px_rgba\(0\,0\,0\,0\.5\)\] {
    --tw-drop-shadow: drop-shadow(0 2px 4px rgba(0,0,0,.5));
    filter: var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow)
}

.drop-shadow-lg {
    --tw-drop-shadow: drop-shadow(0 10px 8px rgb(0 0 0 / .04)) drop-shadow(0 4px 3px rgb(0 0 0 / .1));
    filter: var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow)
}

.grayscale {
    --tw-grayscale: grayscale(100%);
    filter: var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow)
}

.filter {
    filter: var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow)
}

.backdrop-blur-md {
    --tw-backdrop-blur: blur(12px);
    -webkit-backdrop-filter: var(--tw-backdrop-blur) var(--tw-backdrop-brightness) var(--tw-backdrop-contrast) var(--tw-backdrop-grayscale) var(--tw-backdrop-hue-rotate) var(--tw-backdrop-invert) var(--tw-backdrop-opacity) var(--tw-backdrop-saturate) var(--tw-backdrop-sepia);
    backdrop-filter: var(--tw-backdrop-blur) var(--tw-backdrop-brightness) var(--tw-backdrop-contrast) var(--tw-backdrop-grayscale) var(--tw-backdrop-hue-rotate) var(--tw-backdrop-invert) var(--tw-backdrop-opacity) var(--tw-backdrop-saturate) var(--tw-backdrop-sepia)
}

.backdrop-blur-sm {
    --tw-backdrop-blur: blur(4px);
    -webkit-backdrop-filter: var(--tw-backdrop-blur) var(--tw-backdrop-brightness) var(--tw-backdrop-contrast) var(--tw-backdrop-grayscale) var(--tw-backdrop-hue-rotate) var(--tw-backdrop-invert) var(--tw-backdrop-opacity) var(--tw-backdrop-saturate) var(--tw-backdrop-sepia);
    backdrop-filter: var(--tw-backdrop-blur) var(--tw-backdrop-brightness) var(--tw-backdrop-contrast) var(--tw-backdrop-grayscale) var(--tw-backdrop-hue-rotate) var(--tw-backdrop-invert) var(--tw-backdrop-opacity) var(--tw-backdrop-saturate) var(--tw-backdrop-sepia)
}

.backdrop-blur-xl {
    --tw-backdrop-blur: blur(24px);
    -webkit-backdrop-filter: var(--tw-backdrop-blur) var(--tw-backdrop-brightness) var(--tw-backdrop-contrast) var(--tw-backdrop-grayscale) var(--tw-backdrop-hue-rotate) var(--tw-backdrop-invert) var(--tw-backdrop-opacity) var(--tw-backdrop-saturate) var(--tw-backdrop-sepia);
    backdrop-filter: var(--tw-backdrop-blur) var(--tw-backdrop-brightness) var(--tw-backdrop-contrast) var(--tw-backdrop-grayscale) var(--tw-backdrop-hue-rotate) var(--tw-backdrop-invert) var(--tw-backdrop-opacity) var(--tw-backdrop-saturate) var(--tw-backdrop-sepia)
}

.transition {
    transition-property: color,background-color,border-color,text-decoration-color,fill,stroke,opacity,box-shadow,transform,filter,backdrop-filter;
    transition-timing-function: cubic-bezier(.4,0,.2,1);
    transition-duration: .15s
}

.transition-\[left\,right\,width\] {
    transition-property: left,right,width;
    transition-timing-function: cubic-bezier(.4,0,.2,1);
    transition-duration: .15s
}

.transition-\[margin\,opacity\] {
    transition-property: margin,opacity;
    transition-timing-function: cubic-bezier(.4,0,.2,1);
    transition-duration: .15s
}

.transition-\[width\,height\,padding\] {
    transition-property: width,height,padding;
    transition-timing-function: cubic-bezier(.4,0,.2,1);
    transition-duration: .15s
}

.transition-\[width\] {
    transition-property: width;
    transition-timing-function: cubic-bezier(.4,0,.2,1);
    transition-duration: .15s
}

.transition-all {
    transition-property: all;
    transition-timing-function: cubic-bezier(.4,0,.2,1);
    transition-duration: .15s
}

.transition-colors {
    transition-property: color,background-color,border-color,text-decoration-color,fill,stroke;
    transition-timing-function: cubic-bezier(.4,0,.2,1);
    transition-duration: .15s
}

.transition-opacity {
    transition-property: opacity;
    transition-timing-function: cubic-bezier(.4,0,.2,1);
    transition-duration: .15s
}

.transition-transform {
    transition-property: transform;
    transition-timing-function: cubic-bezier(.4,0,.2,1);
    transition-duration: .15s
}

.duration-1000 {
    transition-duration: 1s
}

.duration-200 {
    transition-duration: .2s
}

.duration-300 {
    transition-duration: .3s
}

.duration-700 {
    transition-duration: .7s
}

.ease-in-out {
    transition-timing-function: cubic-bezier(.4,0,.2,1)
}

.ease-linear {
    transition-timing-function: linear
}

@keyframes enter {
    0% {
        opacity: var(--tw-enter-opacity, 1);
        transform: translate3d(var(--tw-enter-translate-x, 0),var(--tw-enter-translate-y, 0),0) scale3d(var(--tw-enter-scale, 1),var(--tw-enter-scale, 1),var(--tw-enter-scale, 1)) rotate(var(--tw-enter-rotate, 0))
    }
}

@keyframes exit {
    to {
        opacity: var(--tw-exit-opacity, 1);
        transform: translate3d(var(--tw-exit-translate-x, 0),var(--tw-exit-translate-y, 0),0) scale3d(var(--tw-exit-scale, 1),var(--tw-exit-scale, 1),var(--tw-exit-scale, 1)) rotate(var(--tw-exit-rotate, 0))
    }
}

.animate-in {
    animation-name: enter;
    animation-duration: .15s;
    --tw-enter-opacity: initial;
    --tw-enter-scale: initial;
    --tw-enter-rotate: initial;
    --tw-enter-translate-x: initial;
    --tw-enter-translate-y: initial
}

.fade-in-0 {
    --tw-enter-opacity: 0
}

.fade-in-80 {
    --tw-enter-opacity: .8
}

.zoom-in-95 {
    --tw-enter-scale: .95
}

.duration-1000 {
    animation-duration: 1s
}

.duration-200 {
    animation-duration: .2s
}

.duration-300 {
    animation-duration: .3s
}

.duration-700 {
    animation-duration: .7s
}

.ease-in-out {
    animation-timing-function: cubic-bezier(.4,0,.2,1)
}

.ease-linear {
    animation-timing-function: linear
}

.\[border-color\:var\(--badge-outline\)\] {
    border-color: var(--badge-outline)
}

.\[border-color\:var\(--button-outline\)\] {
    border-color: var(--button-outline)
}

:root {
    --font-display: "Lilita One", cursive;
    --font-body: "Outfit", sans-serif;
    --background: 0 0% 7%;
    --foreground: 0 0% 98%;
    --primary: 49 100% 50%;
    --primary-foreground: 0 0% 7%;
    --secondary: 0 0% 15%;
    --secondary-foreground: 0 0% 98%;
    --accent: 49 100% 60%;
    --accent-foreground: 0 0% 7%;
    --card: 0 0% 12%;
    --card-foreground: 0 0% 98%;
    --popover: 0 0% 12%;
    --popover-foreground: 0 0% 98%;
    --muted: 0 0% 20%;
    --muted-foreground: 0 0% 70%;
    --destructive: 0 84% 60%;
    --destructive-foreground: 0 0% 100%;
    --border: 0 0% 20%;
    --input: 0 0% 15%;
    --ring: 49 100% 50%;
    --radius: .75rem
}

::-webkit-scrollbar {
    width: 10px
}

::-webkit-scrollbar-track {
    --tw-bg-opacity: 1;
    background-color: hsl(var(--background) / var(--tw-bg-opacity, 1))
}

::-webkit-scrollbar-thumb {
    border-radius: 9999px;
    --tw-bg-opacity: 1;
    background-color: hsl(var(--muted) / var(--tw-bg-opacity, 1));
    -webkit-transition-property: color,background-color,border-color,text-decoration-color,fill,stroke;
    transition-property: color,background-color,border-color,text-decoration-color,fill,stroke;
    transition-timing-function: cubic-bezier(.4,0,.2,1);
    transition-duration: .15s
}

::-webkit-scrollbar-thumb:hover {
    background-color: hsl(var(--muted-foreground) / .5)
}

@media(min-width: 1024px) {
    .lg\:prose-xl {
        font-size:1.25rem;
        line-height: 1.8
    }

    .lg\:prose-xl :where(p):not(:where([class~=not-prose],[class~=not-prose] *)) {
        margin-top: 1.2em;
        margin-bottom: 1.2em
    }

    .lg\:prose-xl :where([class~=lead]):not(:where([class~=not-prose],[class~=not-prose] *)) {
        font-size: 1.2em;
        line-height: 1.5;
        margin-top: 1em;
        margin-bottom: 1em
    }

    .lg\:prose-xl :where(blockquote):not(:where([class~=not-prose],[class~=not-prose] *)) {
        margin-top: 1.6em;
        margin-bottom: 1.6em;
        padding-inline-start:1.0666667em}

    .lg\:prose-xl :where(h1):not(:where([class~=not-prose],[class~=not-prose] *)) {
        font-size: 2.8em;
        margin-top: 0;
        margin-bottom: .8571429em;
        line-height: 1
    }

    .lg\:prose-xl :where(h2):not(:where([class~=not-prose],[class~=not-prose] *)) {
        font-size: 1.8em;
        margin-top: 1.5555556em;
        margin-bottom: .8888889em;
        line-height: 1.1111111
    }

    .lg\:prose-xl :where(h3):not(:where([class~=not-prose],[class~=not-prose] *)) {
        font-size: 1.5em;
        margin-top: 1.6em;
        margin-bottom: .6666667em;
        line-height: 1.3333333
    }

    .lg\:prose-xl :where(h4):not(:where([class~=not-prose],[class~=not-prose] *)) {
        margin-top: 1.8em;
        margin-bottom: .6em;
        line-height: 1.6
    }

    .lg\:prose-xl :where(img):not(:where([class~=not-prose],[class~=not-prose] *)) {
        margin-top: 2em;
        margin-bottom: 2em
    }

    .lg\:prose-xl :where(picture):not(:where([class~=not-prose],[class~=not-prose] *)) {
        margin-top: 2em;
        margin-bottom: 2em
    }

    .lg\:prose-xl :where(picture>img):not(:where([class~=not-prose],[class~=not-prose] *)) {
        margin-top: 0;
        margin-bottom: 0
    }

    .lg\:prose-xl :where(video):not(:where([class~=not-prose],[class~=not-prose] *)) {
        margin-top: 2em;
        margin-bottom: 2em
    }

    .lg\:prose-xl :where(kbd):not(:where([class~=not-prose],[class~=not-prose] *)) {
        font-size: .9em;
        border-radius: .3125rem;
        padding-top: .25em;
        padding-inline-end:.4em;padding-bottom: .25em;
        padding-inline-start:.4em}

    .lg\:prose-xl :where(code):not(:where([class~=not-prose],[class~=not-prose] *)) {
        font-size: .9em
    }

    .lg\:prose-xl :where(h2 code):not(:where([class~=not-prose],[class~=not-prose] *)) {
        font-size: .8611111em
    }

    .lg\:prose-xl :where(h3 code):not(:where([class~=not-prose],[class~=not-prose] *)) {
        font-size: .9em
    }

    .lg\:prose-xl :where(pre):not(:where([class~=not-prose],[class~=not-prose] *)) {
        font-size: .9em;
        line-height: 1.7777778;
        margin-top: 2em;
        margin-bottom: 2em;
        border-radius: .5rem;
        padding-top: 1.1111111em;
        padding-inline-end:1.3333333em;padding-bottom: 1.1111111em;
        padding-inline-start:1.3333333em}

    .lg\:prose-xl :where(ol):not(:where([class~=not-prose],[class~=not-prose] *)) {
        margin-top: 1.2em;
        margin-bottom: 1.2em;
        padding-inline-start:1.6em}

    .lg\:prose-xl :where(ul):not(:where([class~=not-prose],[class~=not-prose] *)) {
        margin-top: 1.2em;
        margin-bottom: 1.2em;
        padding-inline-start:1.6em}

    .lg\:prose-xl :where(li):not(:where([class~=not-prose],[class~=not-prose] *)) {
        margin-top: .6em;
        margin-bottom: .6em
    }

    .lg\:prose-xl :where(ol>li):not(:where([class~=not-prose],[class~=not-prose] *)) {
        padding-inline-start:.4em}

    .lg\:prose-xl :where(ul>li):not(:where([class~=not-prose],[class~=not-prose] *)) {
        padding-inline-start:.4em}

    .lg\:prose-xl :where(.lg\:prose-xl>ul>li p):not(:where([class~=not-prose],[class~=not-prose] *)) {
        margin-top: .8em;
        margin-bottom: .8em
    }

    .lg\:prose-xl :where(.lg\:prose-xl>ul>li>p:first-child):not(:where([class~=not-prose],[class~=not-prose] *)) {
        margin-top: 1.2em
    }

    .lg\:prose-xl :where(.lg\:prose-xl>ul>li>p:last-child):not(:where([class~=not-prose],[class~=not-prose] *)) {
        margin-bottom: 1.2em
    }

    .lg\:prose-xl :where(.lg\:prose-xl>ol>li>p:first-child):not(:where([class~=not-prose],[class~=not-prose] *)) {
        margin-top: 1.2em
    }

    .lg\:prose-xl :where(.lg\:prose-xl>ol>li>p:last-child):not(:where([class~=not-prose],[class~=not-prose] *)) {
        margin-bottom: 1.2em
    }

    .lg\:prose-xl :where(ul ul,ul ol,ol ul,ol ol):not(:where([class~=not-prose],[class~=not-prose] *)) {
        margin-top: .8em;
        margin-bottom: .8em
    }

    .lg\:prose-xl :where(dl):not(:where([class~=not-prose],[class~=not-prose] *)) {
        margin-top: 1.2em;
        margin-bottom: 1.2em
    }

    .lg\:prose-xl :where(dt):not(:where([class~=not-prose],[class~=not-prose] *)) {
        margin-top: 1.2em
    }

    .lg\:prose-xl :where(dd):not(:where([class~=not-prose],[class~=not-prose] *)) {
        margin-top: .6em;
        padding-inline-start:1.6em}

    .lg\:prose-xl :where(hr):not(:where([class~=not-prose],[class~=not-prose] *)) {
        margin-top: 2.8em;
        margin-bottom: 2.8em
    }

    .lg\:prose-xl :where(hr+*):not(:where([class~=not-prose],[class~=not-prose] *)) {
        margin-top: 0
    }

    .lg\:prose-xl :where(h2+*):not(:where([class~=not-prose],[class~=not-prose] *)) {
        margin-top: 0
    }

    .lg\:prose-xl :where(h3+*):not(:where([class~=not-prose],[class~=not-prose] *)) {
        margin-top: 0
    }

    .lg\:prose-xl :where(h4+*):not(:where([class~=not-prose],[class~=not-prose] *)) {
        margin-top: 0
    }

    .lg\:prose-xl :where(table):not(:where([class~=not-prose],[class~=not-prose] *)) {
        font-size: .9em;
        line-height: 1.5555556
    }

    .lg\:prose-xl :where(thead th):not(:where([class~=not-prose],[class~=not-prose] *)) {
        padding-inline-end:.6666667em;padding-bottom: .8888889em;
        padding-inline-start:.6666667em}

    .lg\:prose-xl :where(thead th:first-child):not(:where([class~=not-prose],[class~=not-prose] *)) {
        padding-inline-start:0}

    .lg\:prose-xl :where(thead th:last-child):not(:where([class~=not-prose],[class~=not-prose] *)) {
        padding-inline-end:0}

    .lg\:prose-xl :where(tbody td,tfoot td):not(:where([class~=not-prose],[class~=not-prose] *)) {
        padding-top: .8888889em;
        padding-inline-end:.6666667em;padding-bottom: .8888889em;
        padding-inline-start:.6666667em}

    .lg\:prose-xl :where(tbody td:first-child,tfoot td:first-child):not(:where([class~=not-prose],[class~=not-prose] *)) {
        padding-inline-start:0}

    .lg\:prose-xl :where(tbody td:last-child,tfoot td:last-child):not(:where([class~=not-prose],[class~=not-prose] *)) {
        padding-inline-end:0}

    .lg\:prose-xl :where(figure):not(:where([class~=not-prose],[class~=not-prose] *)) {
        margin-top: 2em;
        margin-bottom: 2em
    }

    .lg\:prose-xl :where(figure>*):not(:where([class~=not-prose],[class~=not-prose] *)) {
        margin-top: 0;
        margin-bottom: 0
    }

    .lg\:prose-xl :where(figcaption):not(:where([class~=not-prose],[class~=not-prose] *)) {
        font-size: .9em;
        line-height: 1.5555556;
        margin-top: 1em
    }

    .lg\:prose-xl :where(.lg\:prose-xl>:first-child):not(:where([class~=not-prose],[class~=not-prose] *)) {
        margin-top: 0
    }

    .lg\:prose-xl :where(.lg\:prose-xl>:last-child):not(:where([class~=not-prose],[class~=not-prose] *)) {
        margin-bottom: 0
    }
}

.file\:border-0::file-selector-button {
    border-width: 0px
}

.file\:bg-transparent::file-selector-button {
    background-color: transparent
}

.file\:text-sm::file-selector-button {
    font-size: .875rem;
    line-height: 1.25rem
}

.file\:font-medium::file-selector-button {
    font-weight: 500
}

.file\:text-foreground::file-selector-button {
    --tw-text-opacity: 1;
    color: hsl(var(--foreground) / var(--tw-text-opacity, 1))
}

.placeholder\:text-muted-foreground::-moz-placeholder {
    --tw-text-opacity: 1;
    color: hsl(var(--muted-foreground) / var(--tw-text-opacity, 1))
}

.placeholder\:text-muted-foreground::placeholder {
    --tw-text-opacity: 1;
    color: hsl(var(--muted-foreground) / var(--tw-text-opacity, 1))
}

.after\:pointer-events-none:after {
    content: var(--tw-content);
    pointer-events: none
}

.after\:absolute:after {
    content: var(--tw-content);
    position: absolute
}

.after\:-inset-2:after {
    content: var(--tw-content);
    inset: -.5rem
}

.after\:inset-0:after {
    content: var(--tw-content);
    inset: 0
}

.after\:inset-y-0:after {
    content: var(--tw-content);
    top: 0;
    bottom: 0
}

.after\:left-1\/2:after {
    content: var(--tw-content);
    left: 50%
}

.after\:block:after {
    content: var(--tw-content);
    display: block
}

.after\:w-1:after {
    content: var(--tw-content);
    width: .25rem
}

.after\:w-\[2px\]:after {
    content: var(--tw-content);
    width: 2px
}

.after\:-translate-x-1\/2:after {
    content: var(--tw-content);
    --tw-translate-x: -50%;
    transform: translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))
}

.after\:rounded-full:after {
    content: var(--tw-content);
    border-radius: 9999px
}

.after\:border:after {
    content: var(--tw-content);
    border-width: 1px
}

.after\:border-black\/10:after {
    content: var(--tw-content);
    border-color: #0000001a
}

.after\:content-\[\'\'\]:after{--tw-content: "";content:var(--tw-content)}.first\:rounded-l-md:first-child{border-top-left-radius:.375rem;border-bottom-left-radius:.375rem}.first\:border-l:first-child{border-left-width:1px}.last\:rounded-r-md:last-child{border-top-right-radius:.375rem;border-bottom-right-radius:.375rem}.focus-within\:relative:focus-within{position:relative}.focus-within\:z-20:focus-within{z-index:20}.hover\:scale-105:hover{--tw-scale-x: 1.05;--tw-scale-y: 1.05;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.hover\:border-primary\/50:hover{border-color:hsl(var(--primary) / .5)}.hover\:bg-\[\#3a4150\]:hover{--tw-bg-opacity: 1;background-color:rgb(58 65 80 / var(--tw-bg-opacity, 1))}.hover\:bg-accent:hover{--tw-bg-opacity: 1;background-color:hsl(var(--accent) / var(--tw-bg-opacity, 1))}.hover\:bg-accent\/90:hover{background-color:hsl(var(--accent) / .9)}.hover\:bg-destructive\/10:hover{background-color:hsl(var(--destructive) / .1)}.hover\:bg-muted:hover{--tw-bg-opacity: 1;background-color:hsl(var(--muted) / var(--tw-bg-opacity, 1))}.hover\:bg-muted\/50:hover{background-color:hsl(var(--muted) / .5)}.hover\:bg-primary:hover{--tw-bg-opacity: 1;background-color:hsl(var(--primary) / var(--tw-bg-opacity, 1))}.hover\:bg-primary\/90:hover{background-color:hsl(var(--primary) / .9)}.hover\:bg-secondary:hover{--tw-bg-opacity: 1;background-color:hsl(var(--secondary) / var(--tw-bg-opacity, 1))}.hover\:bg-sidebar-accent:hover{--tw-bg-opacity: 1;background-color:hsl(var(--sidebar-accent) / var(--tw-bg-opacity, 1))}.hover\:bg-white\/10:hover{background-color:#ffffff1a}.hover\:bg-white\/5:hover{background-color:#ffffff0d}.hover\:bg-white\/90:hover{background-color:#ffffffe6}.hover\:text-accent-foreground:hover{--tw-text-opacity: 1;color:hsl(var(--accent-foreground) / var(--tw-text-opacity, 1))}.hover\:text-destructive\/80:hover{color:hsl(var(--destructive) / .8)}.hover\:text-foreground:hover{--tw-text-opacity: 1;color:hsl(var(--foreground) / var(--tw-text-opacity, 1))}.hover\:text-muted-foreground:hover{--tw-text-opacity: 1;color:hsl(var(--muted-foreground) / var(--tw-text-opacity, 1))}.hover\:text-primary-foreground:hover{--tw-text-opacity: 1;color:hsl(var(--primary-foreground) / var(--tw-text-opacity, 1))}.hover\:text-primary\/80:hover{color:hsl(var(--primary) / .8)}.hover\:text-sidebar-accent-foreground:hover{--tw-text-opacity: 1;color:hsl(var(--sidebar-accent-foreground) / var(--tw-text-opacity, 1))}.hover\:text-white:hover{--tw-text-opacity: 1;color:rgb(255 255 255 / var(--tw-text-opacity, 1))}.hover\:underline:hover{text-decoration-line:underline}.hover\:opacity-100:hover{opacity:1}.hover\:shadow-\[0_0_0_1px_hsl\(var\(--sidebar-accent\)\)\]:hover{--tw-shadow: 0 0 0 1px hsl(var(--sidebar-accent));--tw-shadow-colored: 0 0 0 1px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow)}.hover\:grayscale-0:hover{--tw-grayscale: grayscale(0);filter:var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow)}.hover\:after\:bg-sidebar-border:hover:after{content:var(--tw-content);--tw-bg-opacity: 1;background-color:hsl(var(--sidebar-border) / var(--tw-bg-opacity, 1))}.focus\:border-primary:focus{--tw-border-opacity: 1;border-color:hsl(var(--primary) / var(--tw-border-opacity, 1))}.focus\:bg-accent:focus{--tw-bg-opacity: 1;background-color:hsl(var(--accent) / var(--tw-bg-opacity, 1))}.focus\:bg-primary:focus{--tw-bg-opacity: 1;background-color:hsl(var(--primary) / var(--tw-bg-opacity, 1))}.focus\:text-accent-foreground:focus{--tw-text-opacity: 1;color:hsl(var(--accent-foreground) / var(--tw-text-opacity, 1))}.focus\:text-primary-foreground:focus{--tw-text-opacity: 1;color:hsl(var(--primary-foreground) / var(--tw-text-opacity, 1))}.focus\:opacity-100:focus{opacity:1}.focus\:outline-none:focus{outline:2px solid transparent;outline-offset:2px}.focus\:ring-2:focus{--tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color);box-shadow:var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow, 0 0 #0000)}.focus\:ring-ring:focus{--tw-ring-opacity: 1;--tw-ring-color: hsl(var(--ring) / var(--tw-ring-opacity, 1))}.focus\:ring-offset-2:focus{--tw-ring-offset-width: 2px}.focus-visible\:outline-none:focus-visible{outline:2px solid transparent;outline-offset:2px}.focus-visible\:ring-1:focus-visible{--tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(1px + var(--tw-ring-offset-width)) var(--tw-ring-color);box-shadow:var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow, 0 0 #0000)}.focus-visible\:ring-2:focus-visible{--tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color);box-shadow:var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow, 0 0 #0000)}.focus-visible\:ring-ring:focus-visible{--tw-ring-opacity: 1;--tw-ring-color: hsl(var(--ring) / var(--tw-ring-opacity, 1))}.focus-visible\:ring-offset-1:focus-visible{--tw-ring-offset-width: 1px}.focus-visible\:ring-offset-2:focus-visible{--tw-ring-offset-width: 2px}.focus-visible\:ring-offset-background:focus-visible{--tw-ring-offset-color: hsl(var(--background) / 1)}.active\:bg-sidebar-accent:active{--tw-bg-opacity: 1;background-color:hsl(var(--sidebar-accent) / var(--tw-bg-opacity, 1))}.active\:text-sidebar-accent-foreground:active{--tw-text-opacity: 1;color:hsl(var(--sidebar-accent-foreground) / var(--tw-text-opacity, 1))}.active\:shadow-none:active{--tw-shadow: 0 0 #0000;--tw-shadow-colored: 0 0 #0000;box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow)}.disabled\:pointer-events-none:disabled{pointer-events:none}.disabled\:cursor-not-allowed:disabled{cursor:not-allowed}.disabled\:opacity-50:disabled{opacity:.5}.group\/menu-item:focus-within .group-focus-within\/menu-item\:opacity-100{opacity:1}.group:hover .group-hover\:scale-105{--tw-scale-x: 1.05;--tw-scale-y: 1.05;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.group:hover .group-hover\:scale-110{--tw-scale-x: 1.1;--tw-scale-y: 1.1;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.group:hover .group-hover\:bg-primary{--tw-bg-opacity: 1;background-color:hsl(var(--primary) / var(--tw-bg-opacity, 1))}.group:hover .group-hover\:text-black{--tw-text-opacity: 1;color:rgb(0 0 0 / var(--tw-text-opacity, 1))}.group:hover .group-hover\:text-primary{--tw-text-opacity: 1;color:hsl(var(--primary) / var(--tw-text-opacity, 1))}.group:hover .group-hover\:text-white{--tw-text-opacity: 1;color:rgb(255 255 255 / var(--tw-text-opacity, 1))}.group\/menu-item:hover .group-hover\/menu-item\:opacity-100,.group:hover .group-hover\:opacity-100{opacity:1}.group.destructive .group-\[\.destructive\]\:border-muted\/40{border-color:hsl(var(--muted) / .4)}.group.destructive .group-\[\.destructive\]\:text-red-300{--tw-text-opacity: 1;color:rgb(252 165 165 / var(--tw-text-opacity, 1))}.group.destructive .group-\[\.destructive\]\:hover\:border-destructive\/30:hover{border-color:hsl(var(--destructive) / .3)}.group.destructive .group-\[\.destructive\]\:hover\:bg-destructive:hover{--tw-bg-opacity: 1;background-color:hsl(var(--destructive) / var(--tw-bg-opacity, 1))}.group.destructive .group-\[\.destructive\]\:hover\:text-destructive-foreground:hover{--tw-text-opacity: 1;color:hsl(var(--destructive-foreground) / var(--tw-text-opacity, 1))}.group.destructive .group-\[\.destructive\]\:hover\:text-red-50:hover{--tw-text-opacity: 1;color:rgb(254 242 242 / var(--tw-text-opacity, 1))}.group.destructive .group-\[\.destructive\]\:focus\:ring-destructive:focus{--tw-ring-opacity: 1;--tw-ring-color: hsl(var(--destructive) / var(--tw-ring-opacity, 1))}.group.destructive .group-\[\.destructive\]\:focus\:ring-red-400:focus{--tw-ring-opacity: 1;--tw-ring-color: rgb(248 113 113 / var(--tw-ring-opacity, 1))}.group.destructive .group-\[\.destructive\]\:focus\:ring-offset-red-600:focus{--tw-ring-offset-color: #dc2626}.peer\/menu-button:hover~.peer-hover\/menu-button\:text-sidebar-accent-foreground{--tw-text-opacity: 1;color:hsl(var(--sidebar-accent-foreground) / var(--tw-text-opacity, 1))}.peer:disabled~.peer-disabled\:cursor-not-allowed{cursor:not-allowed}.peer:disabled~.peer-disabled\:opacity-70{opacity:.7}.has-\[\:disabled\]\:opacity-50:has(:disabled){opacity:.5}.aria-disabled\:pointer-events-none[aria-disabled=true]{pointer-events:none}.aria-disabled\:opacity-50[aria-disabled=true]{opacity:.5}.aria-selected\:bg-accent[aria-selected=true]{--tw-bg-opacity: 1;background-color:hsl(var(--accent) / var(--tw-bg-opacity, 1))}.aria-selected\:bg-accent\/50[aria-selected=true]{background-color:hsl(var(--accent) / .5)}.aria-selected\:text-accent-foreground[aria-selected=true]{--tw-text-opacity: 1;color:hsl(var(--accent-foreground) / var(--tw-text-opacity, 1))}.aria-selected\:text-muted-foreground[aria-selected=true]{--tw-text-opacity: 1;color:hsl(var(--muted-foreground) / var(--tw-text-opacity, 1))}.aria-selected\:opacity-100[aria-selected=true]{opacity:1}.data-\[disabled\=true\]\:pointer-events-none[data-disabled=true],.data-\[disabled\]\:pointer-events-none[data-disabled]{pointer-events:none}.data-\[panel-group-direction\=vertical\]\:h-px[data-panel-group-direction=vertical]{height:1px}.data-\[panel-group-direction\=vertical\]\:w-full[data-panel-group-direction=vertical]{width:100%}.data-\[side\=bottom\]\:translate-y-1[data-side=bottom]{--tw-translate-y: .25rem;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.data-\[side\=left\]\:-translate-x-1[data-side=left]{--tw-translate-x: -.25rem;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.data-\[side\=right\]\:translate-x-1[data-side=right]{--tw-translate-x: .25rem;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.data-\[side\=top\]\:-translate-y-1[data-side=top]{--tw-translate-y: -.25rem;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.data-\[state\=checked\]\:translate-x-5[data-state=checked]{--tw-translate-x: 1.25rem;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.data-\[state\=unchecked\]\:translate-x-0[data-state=unchecked],.data-\[swipe\=cancel\]\:translate-x-0[data-swipe=cancel]{--tw-translate-x: 0px;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.data-\[swipe\=end\]\:translate-x-\[var\(--radix-toast-swipe-end-x\)\][data-swipe=end]{--tw-translate-x: var(--radix-toast-swipe-end-x);transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.data-\[swipe\=move\]\:translate-x-\[var\(--radix-toast-swipe-move-x\)\][data-swipe=move]{--tw-translate-x: var(--radix-toast-swipe-move-x);transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}@keyframes accordion-up{0%{height:var(--radix-accordion-content-height)}to{height:0}}.data-\[state\=closed\]\:animate-accordion-up[data-state=closed]{animation:accordion-up .2s ease-out}@keyframes accordion-down{0%{height:0}to{height:var(--radix-accordion-content-height)}}.data-\[state\=open\]\:animate-accordion-down[data-state=open]{animation:accordion-down .2s ease-out}.data-\[panel-group-direction\=vertical\]\:flex-col[data-panel-group-direction=vertical]{flex-direction:column}.data-\[active\=true\]\:bg-sidebar-accent[data-active=true]{--tw-bg-opacity: 1;background-color:hsl(var(--sidebar-accent) / var(--tw-bg-opacity, 1))}.data-\[selected\=\'true\'\]\:bg-accent[data-selected=true]{--tw-bg-opacity: 1;background-color:hsl(var(--accent) / var(--tw-bg-opacity, 1))}.data-\[state\=active\]\:bg-background[data-state=active]{--tw-bg-opacity: 1;background-color:hsl(var(--background) / var(--tw-bg-opacity, 1))}.data-\[state\=active\]\:bg-primary[data-state=active],.data-\[state\=checked\]\:bg-primary[data-state=checked]{--tw-bg-opacity: 1;background-color:hsl(var(--primary) / var(--tw-bg-opacity, 1))}.data-\[state\=on\]\:bg-accent[data-state=on],.data-\[state\=open\]\:bg-accent[data-state=open]{--tw-bg-opacity: 1;background-color:hsl(var(--accent) / var(--tw-bg-opacity, 1))}.data-\[state\=open\]\:bg-accent\/50[data-state=open]{background-color:hsl(var(--accent) / .5)}.data-\[state\=open\]\:bg-secondary[data-state=open]{--tw-bg-opacity: 1;background-color:hsl(var(--secondary) / var(--tw-bg-opacity, 1))}.data-\[state\=selected\]\:bg-muted[data-state=selected]{--tw-bg-opacity: 1;background-color:hsl(var(--muted) / var(--tw-bg-opacity, 1))}.data-\[state\=unchecked\]\:bg-input[data-state=unchecked]{--tw-bg-opacity: 1;background-color:hsl(var(--input) / var(--tw-bg-opacity, 1))}.data-\[active\=true\]\:font-medium[data-active=true]{font-weight:500}.data-\[active\=true\]\:text-sidebar-accent-foreground[data-active=true]{--tw-text-opacity: 1;color:hsl(var(--sidebar-accent-foreground) / var(--tw-text-opacity, 1))}.data-\[placeholder\]\:text-muted-foreground[data-placeholder]{--tw-text-opacity: 1;color:hsl(var(--muted-foreground) / var(--tw-text-opacity, 1))}.data-\[selected\=true\]\:text-accent-foreground[data-selected=true]{--tw-text-opacity: 1;color:hsl(var(--accent-foreground) / var(--tw-text-opacity, 1))}.data-\[state\=active\]\:text-black[data-state=active]{--tw-text-opacity: 1;color:rgb(0 0 0 / var(--tw-text-opacity, 1))}.data-\[state\=active\]\:text-foreground[data-state=active]{--tw-text-opacity: 1;color:hsl(var(--foreground) / var(--tw-text-opacity, 1))}.data-\[state\=checked\]\:text-primary-foreground[data-state=checked]{--tw-text-opacity: 1;color:hsl(var(--primary-foreground) / var(--tw-text-opacity, 1))}.data-\[state\=on\]\:text-accent-foreground[data-state=on],.data-\[state\=open\]\:text-accent-foreground[data-state=open]{--tw-text-opacity: 1;color:hsl(var(--accent-foreground) / var(--tw-text-opacity, 1))}.data-\[state\=open\]\:text-muted-foreground[data-state=open]{--tw-text-opacity: 1;color:hsl(var(--muted-foreground) / var(--tw-text-opacity, 1))}.data-\[disabled\=true\]\:opacity-50[data-disabled=true],.data-\[disabled\]\:opacity-50[data-disabled]{opacity:.5}.data-\[state\=open\]\:opacity-100[data-state=open]{opacity:1}.data-\[state\=active\]\:shadow-sm[data-state=active]{--tw-shadow: 0 1px 2px 0 rgb(0 0 0 / .05);--tw-shadow-colored: 0 1px 2px 0 var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow)}.data-\[swipe\=move\]\:transition-none[data-swipe=move]{transition-property:none}.data-\[state\=closed\]\:duration-300[data-state=closed]{transition-duration:.3s}.data-\[state\=open\]\:duration-500[data-state=open]{transition-duration:.5s}.data-\[motion\^\=from-\]\:animate-in[data-motion^=from-],.data-\[state\=open\]\:animate-in[data-state=open],.data-\[state\=visible\]\:animate-in[data-state=visible]{animation-name:enter;animation-duration:.15s;--tw-enter-opacity: initial;--tw-enter-scale: initial;--tw-enter-rotate: initial;--tw-enter-translate-x: initial;--tw-enter-translate-y: initial}.data-\[motion\^\=to-\]\:animate-out[data-motion^=to-],.data-\[state\=closed\]\:animate-out[data-state=closed],.data-\[state\=hidden\]\:animate-out[data-state=hidden],.data-\[swipe\=end\]\:animate-out[data-swipe=end]{animation-name:exit;animation-duration:.15s;--tw-exit-opacity: initial;--tw-exit-scale: initial;--tw-exit-rotate: initial;--tw-exit-translate-x: initial;--tw-exit-translate-y: initial}.data-\[motion\^\=from-\]\:fade-in[data-motion^=from-]{--tw-enter-opacity: 0}.data-\[motion\^\=to-\]\:fade-out[data-motion^=to-],.data-\[state\=closed\]\:fade-out-0[data-state=closed]{--tw-exit-opacity: 0}.data-\[state\=closed\]\:fade-out-80[data-state=closed]{--tw-exit-opacity: .8}.data-\[state\=hidden\]\:fade-out[data-state=hidden]{--tw-exit-opacity: 0}.data-\[state\=open\]\:fade-in-0[data-state=open],.data-\[state\=visible\]\:fade-in[data-state=visible]{--tw-enter-opacity: 0}.data-\[state\=closed\]\:zoom-out-95[data-state=closed]{--tw-exit-scale: .95}.data-\[state\=open\]\:zoom-in-90[data-state=open]{--tw-enter-scale: .9}.data-\[state\=open\]\:zoom-in-95[data-state=open]{--tw-enter-scale: .95}.data-\[motion\=from-end\]\:slide-in-from-right-52[data-motion=from-end]{--tw-enter-translate-x: 13rem}.data-\[motion\=from-start\]\:slide-in-from-left-52[data-motion=from-start]{--tw-enter-translate-x: -13rem}.data-\[motion\=to-end\]\:slide-out-to-right-52[data-motion=to-end]{--tw-exit-translate-x: 13rem}.data-\[motion\=to-start\]\:slide-out-to-left-52[data-motion=to-start]{--tw-exit-translate-x: -13rem}.data-\[side\=bottom\]\:slide-in-from-top-2[data-side=bottom]{--tw-enter-translate-y: -.5rem}.data-\[side\=left\]\:slide-in-from-right-2[data-side=left]{--tw-enter-translate-x: .5rem}.data-\[side\=right\]\:slide-in-from-left-2[data-side=right]{--tw-enter-translate-x: -.5rem}.data-\[side\=top\]\:slide-in-from-bottom-2[data-side=top]{--tw-enter-translate-y: .5rem}.data-\[state\=closed\]\:slide-out-to-bottom[data-state=closed]{--tw-exit-translate-y: 100%}.data-\[state\=closed\]\:slide-out-to-left[data-state=closed]{--tw-exit-translate-x: -100%}.data-\[state\=closed\]\:slide-out-to-left-1\/2[data-state=closed]{--tw-exit-translate-x: -50%}.data-\[state\=closed\]\:slide-out-to-right[data-state=closed],.data-\[state\=closed\]\:slide-out-to-right-full[data-state=closed]{--tw-exit-translate-x: 100%}.data-\[state\=closed\]\:slide-out-to-top[data-state=closed]{--tw-exit-translate-y: -100%}.data-\[state\=closed\]\:slide-out-to-top-\[48\%\][data-state=closed]{--tw-exit-translate-y: -48%}.data-\[state\=open\]\:slide-in-from-bottom[data-state=open]{--tw-enter-translate-y: 100%}.data-\[state\=open\]\:slide-in-from-left[data-state=open]{--tw-enter-translate-x: -100%}.data-\[state\=open\]\:slide-in-from-left-1\/2[data-state=open]{--tw-enter-translate-x: -50%}.data-\[state\=open\]\:slide-in-from-right[data-state=open]{--tw-enter-translate-x: 100%}.data-\[state\=open\]\:slide-in-from-top[data-state=open]{--tw-enter-translate-y: -100%}.data-\[state\=open\]\:slide-in-from-top-\[48\%\][data-state=open]{--tw-enter-translate-y: -48%}.data-\[state\=open\]\:slide-in-from-top-full[data-state=open]{--tw-enter-translate-y: -100%}.data-\[state\=closed\]\:duration-300[data-state=closed]{animation-duration:.3s}.data-\[state\=open\]\:duration-500[data-state=open]{animation-duration:.5s}.data-\[panel-group-direction\=vertical\]\:after\:left-0[data-panel-group-direction=vertical]:after{content:var(--tw-content);left:0}.data-\[panel-group-direction\=vertical\]\:after\:h-1[data-panel-group-direction=vertical]:after{content:var(--tw-content);height:.25rem}.data-\[panel-group-direction\=vertical\]\:after\:w-full[data-panel-group-direction=vertical]:after{content:var(--tw-content);width:100%}.data-\[panel-group-direction\=vertical\]\:after\:-translate-y-1\/2[data-panel-group-direction=vertical]:after{content:var(--tw-content);--tw-translate-y: -50%;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.data-\[panel-group-direction\=vertical\]\:after\:translate-x-0[data-panel-group-direction=vertical]:after{content:var(--tw-content);--tw-translate-x: 0px;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.data-\[state\=open\]\:hover\:bg-accent:hover[data-state=open]{--tw-bg-opacity: 1;background-color:hsl(var(--accent) / var(--tw-bg-opacity, 1))}.data-\[state\=open\]\:hover\:bg-sidebar-accent:hover[data-state=open]{--tw-bg-opacity: 1;background-color:hsl(var(--sidebar-accent) / var(--tw-bg-opacity, 1))}.data-\[state\=open\]\:hover\:text-sidebar-accent-foreground:hover[data-state=open]{--tw-text-opacity: 1;color:hsl(var(--sidebar-accent-foreground) / var(--tw-text-opacity, 1))}.data-\[state\=open\]\:focus\:bg-accent:focus[data-state=open]{--tw-bg-opacity: 1;background-color:hsl(var(--accent) / var(--tw-bg-opacity, 1))}.group[data-collapsible=offcanvas] .group-data-\[collapsible\=offcanvas\]\:left-\[calc\(var\(--sidebar-width\)\*-1\)\]{left:calc(var(--sidebar-width) * -1)}.group[data-collapsible=offcanvas] .group-data-\[collapsible\=offcanvas\]\:right-\[calc\(var\(--sidebar-width\)\*-1\)\]{right:calc(var(--sidebar-width) * -1)}.group[data-side=left] .group-data-\[side\=left\]\:-right-4{right:-1rem}.group[data-side=right] .group-data-\[side\=right\]\:left-0{left:0}.group[data-collapsible=icon] .group-data-\[collapsible\=icon\]\:-mt-8{margin-top:-2rem}.group[data-collapsible=icon] .group-data-\[collapsible\=icon\]\:hidden{display:none}.group[data-collapsible=icon] .group-data-\[collapsible\=icon\]\:w-\[calc\(var\(--sidebar-width-icon\)\+var\(--spacing-4\)\)\]{width:calc(var(--sidebar-width-icon) + var(--spacing-4))}.group[data-collapsible=icon] .group-data-\[collapsible\=icon\]\:w-\[calc\(var\(--sidebar-width-icon\)\+var\(--spacing-4\)\+2px\)\]{width:calc(var(--sidebar-width-icon) + var(--spacing-4) + 2px)}.group[data-collapsible=icon] .group-data-\[collapsible\=icon\]\:w-\[var\(--sidebar-width-icon\)\]{width:var(--sidebar-width-icon)}.group[data-collapsible=offcanvas] .group-data-\[collapsible\=offcanvas\]\:w-0{width:0px}.group[data-collapsible=offcanvas] .group-data-\[collapsible\=offcanvas\]\:translate-x-0{--tw-translate-x: 0px;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.group[data-side=right] .group-data-\[side\=right\]\:rotate-180,.group[data-state=open] .group-data-\[state\=open\]\:rotate-180{--tw-rotate: 180deg;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.group[data-collapsible=icon] .group-data-\[collapsible\=icon\]\:overflow-hidden{overflow:hidden}.group[data-variant=floating] .group-data-\[variant\=floating\]\:rounded-lg{border-radius:.5625rem}.group[data-variant=floating] .group-data-\[variant\=floating\]\:border{border-width:1px}.group[data-side=left] .group-data-\[side\=left\]\:border-r{border-right-width:1px}.group[data-side=right] .group-data-\[side\=right\]\:border-l{border-left-width:1px}.group[data-variant=floating] .group-data-\[variant\=floating\]\:border-sidebar-border{--tw-border-opacity: 1;border-color:hsl(var(--sidebar-border) / var(--tw-border-opacity, 1))}.group[data-collapsible=icon] .group-data-\[collapsible\=icon\]\:opacity-0{opacity:0}.group[data-variant=floating] .group-data-\[variant\=floating\]\:shadow-sm{--tw-shadow: 0 1px 2px 0 rgb(0 0 0 / .05);--tw-shadow-colored: 0 1px 2px 0 var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow)}.group[data-collapsible=offcanvas] .group-data-\[collapsible\=offcanvas\]\:after\:left-full:after{content:var(--tw-content);left:100%}.group[data-collapsible=offcanvas] .hover\:group-data-\[collapsible\=offcanvas\]\:bg-sidebar:hover{--tw-bg-opacity: 1;background-color:hsl(var(--sidebar) / var(--tw-bg-opacity, 1))}.peer\/menu-button[data-size=default]~.peer-data-\[size\=default\]\/menu-button\:top-1\.5{top:.375rem}.peer\/menu-button[data-size=lg]~.peer-data-\[size\=lg\]\/menu-button\:top-2\.5{top:.625rem}.peer\/menu-button[data-size=sm]~.peer-data-\[size\=sm\]\/menu-button\:top-1{top:.25rem}.peer\/menu-button[data-active=true]~.peer-data-\[active\=true\]\/menu-button\:text-sidebar-accent-foreground{--tw-text-opacity: 1;color:hsl(var(--sidebar-accent-foreground) / var(--tw-text-opacity, 1))}.dark\:border-destructive:is(.dark *){--tw-border-opacity: 1;border-color:hsl(var(--destructive) / var(--tw-border-opacity, 1))}.dark\:after\:border-white\/10:is(.dark *):after{content:var(--tw-content);border-color:#ffffff1a}@media(min-width:640px){.sm\:bottom-0{bottom:0}.sm\:right-0{right:0}.sm\:top-auto{top:auto}.sm\:mt-0{margin-top:0}.sm\:flex{display:flex}.sm\:w-auto{width:auto}.sm\:max-w-sm{max-width:24rem}.sm\:grid-cols-2{grid-template-columns:repeat(2,minmax(0,1fr))}.sm\:flex-row{flex-direction:row}.sm\:flex-col{flex-direction:column}.sm\:justify-end{justify-content:flex-end}.sm\:gap-2\.5{gap:.625rem}.sm\:space-x-2>:not([hidden])~:not([hidden]){--tw-space-x-reverse: 0;margin-right:calc(.5rem * var(--tw-space-x-reverse));margin-left:calc(.5rem * calc(1 - var(--tw-space-x-reverse)))}.sm\:space-x-4>:not([hidden])~:not([hidden]){--tw-space-x-reverse: 0;margin-right:calc(1rem * var(--tw-space-x-reverse));margin-left:calc(1rem * calc(1 - var(--tw-space-x-reverse)))}.sm\:space-y-0>:not([hidden])~:not([hidden]){--tw-space-y-reverse: 0;margin-top:calc(0px * calc(1 - var(--tw-space-y-reverse)));margin-bottom:calc(0px * var(--tw-space-y-reverse))}.sm\:rounded-lg{border-radius:.5625rem}.sm\:text-left{text-align:left}.data-\[state\=open\]\:sm\:slide-in-from-bottom-full[data-state=open]{--tw-enter-translate-y: 100%}}@media(min-width:768px){.md\:absolute{position:absolute}.md\:block{display:block}.md\:flex{display:flex}.md\:hidden{display:none}.md\:h-\[500px\]{height:500px}.md\:w-\[var\(--radix-navigation-menu-viewport-width\)\]{width:var(--radix-navigation-menu-viewport-width)}.md\:w-auto{width:auto}.md\:max-w-\[420px\]{max-width:420px}.md\:grid-cols-2{grid-template-columns:repeat(2,minmax(0,1fr))}.md\:grid-cols-4{grid-template-columns:repeat(4,minmax(0,1fr))}.md\:flex-row{flex-direction:row}.md\:p-12{padding:3rem}.md\:py-20{padding-top:5rem;padding-bottom:5rem}.md\:pb-20{padding-bottom:5rem}.md\:pb-48{padding-bottom:12rem}.md\:pt-32{padding-top:8rem}.md\:text-2xl{font-size:1.5rem;line-height:2rem}.md\:text-5xl{font-size:3rem;line-height:1}.md\:text-6xl{font-size:3.75rem;line-height:1}.md\:text-7xl{font-size:4.5rem;line-height:1}.md\:text-sm{font-size:.875rem;line-height:1.25rem}.md\:opacity-0{opacity:0}.md\:after\:hidden:after{content:var(--tw-content);display:none}.peer[data-variant=inset]~.md\:peer-data-\[variant\=inset\]\:m-2{margin:.5rem}.peer[data-variant=inset]~.md\:peer-data-\[variant\=inset\]\:ml-0{margin-left:0}.peer[data-variant=inset][data-state=collapsed]~.md\:peer-data-\[variant\=inset\]\:peer-data-\[state\=collapsed\]\:ml-2{margin-left:.5rem}.peer[data-variant=inset]~.md\:peer-data-\[variant\=inset\]\:rounded-xl{border-radius:.75rem}.peer[data-variant=inset]~.md\:peer-data-\[variant\=inset\]\:shadow-sm{--tw-shadow: 0 1px 2px 0 rgb(0 0 0 / .05);--tw-shadow-colored: 0 1px 2px 0 var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow)}}@media(min-width:1024px){.lg\:col-span-2{grid-column:span 2 / span 2}.lg\:grid-cols-3{grid-template-columns:repeat(3,minmax(0,1fr))}.lg\:text-7xl{font-size:4.5rem;line-height:1}.lg\:text-8xl{font-size:6rem;line-height:1}}.\[\&\:has\(\[aria-selected\]\)\]\:bg-accent:has([aria-selected]){--tw-bg-opacity: 1;background-color:hsl(var(--accent) / var(--tw-bg-opacity, 1))}.first\:\[\&\:has\(\[aria-selected\]\)\]\:rounded-l-md:has([aria-selected]):first-child{border-top-left-radius:.375rem;border-bottom-left-radius:.375rem}.last\:\[\&\:has\(\[aria-selected\]\)\]\:rounded-r-md:has([aria-selected]):last-child{border-top-right-radius:.375rem;border-bottom-right-radius:.375rem}.\[\&\:has\(\[aria-selected\]\.day-outside\)\]\:bg-accent\/50:has([aria-selected].day-outside){background-color:hsl(var(--accent) / .5)}.\[\&\:has\(\[aria-selected\]\.day-range-end\)\]\:rounded-r-md:has([aria-selected].day-range-end){border-top-right-radius:.375rem;border-bottom-right-radius:.375rem}.\[\&\:has\(\[role\=checkbox\]\)\]\:pr-0:has([role=checkbox]){padding-right:0}.\[\&\>button\]\:hidden>button{display:none}.\[\&\>span\:last-child\]\:truncate>span:last-child{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.\[\&\>span\]\:line-clamp-1>span{overflow:hidden;display:-webkit-box;-webkit-box-orient:vertical;-webkit-line-clamp:1}.\[\&\>svg\+div\]\:translate-y-\[-3px\]>svg+div{--tw-translate-y: -3px;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.\[\&\>svg\]\:absolute>svg{position:absolute}.\[\&\>svg\]\:left-4>svg{left:1rem}.\[\&\>svg\]\:top-4>svg{top:1rem}.\[\&\>svg\]\:size-4>svg{width:1rem;height:1rem}.\[\&\>svg\]\:h-2\.5>svg{height:.625rem}.\[\&\>svg\]\:h-3>svg{height:.75rem}.\[\&\>svg\]\:h-3\.5>svg{height:.875rem}.\[\&\>svg\]\:h-4>svg{height:1rem}.\[\&\>svg\]\:w-2\.5>svg{width:.625rem}.\[\&\>svg\]\:w-3>svg{width:.75rem}.\[\&\>svg\]\:w-3\.5>svg{width:.875rem}.\[\&\>svg\]\:w-4>svg{width:1rem}.\[\&\>svg\]\:shrink-0>svg{flex-shrink:0}.\[\&\>svg\]\:text-destructive>svg{--tw-text-opacity: 1;color:hsl(var(--destructive) / var(--tw-text-opacity, 1))}.\[\&\>svg\]\:text-foreground>svg{--tw-text-opacity: 1;color:hsl(var(--foreground) / var(--tw-text-opacity, 1))}.\[\&\>svg\]\:text-muted-foreground>svg{--tw-text-opacity: 1;color:hsl(var(--muted-foreground) / var(--tw-text-opacity, 1))}.\[\&\>svg\]\:text-sidebar-accent-foreground>svg{--tw-text-opacity: 1;color:hsl(var(--sidebar-accent-foreground) / var(--tw-text-opacity, 1))}.\[\&\>svg\~\*\]\:pl-7>svg~*{padding-left:1.75rem}.\[\&\>tr\]\:last\:border-b-0:last-child>tr{border-bottom-width:0px}.\[\&\[data-panel-group-direction\=vertical\]\>div\]\:rotate-90[data-panel-group-direction=vertical]>div{--tw-rotate: 90deg;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.\[\&\[data-state\=open\]\>svg\]\:rotate-180[data-state=open]>svg{--tw-rotate: 180deg;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.\[\&_\.recharts-cartesian-axis-tick_text\]\:fill-muted-foreground .recharts-cartesian-axis-tick text{fill:hsl(var(--muted-foreground) / 1)}.\[\&_\.recharts-cartesian-grid_line\[stroke\=\'\#ccc\'\]\]\:stroke-border\/50 .recharts-cartesian-grid line[stroke="#ccc"]{stroke:hsl(var(--border) / .5)}.\[\&_\.recharts-curve\.recharts-tooltip-cursor\]\:stroke-border .recharts-curve.recharts-tooltip-cursor{stroke:hsl(var(--border) / 1)}.\[\&_\.recharts-dot\[stroke\=\'\#fff\'\]\]\:stroke-transparent .recharts-dot[stroke="#fff"]{stroke:transparent}.\[\&_\.recharts-layer\]\:outline-none .recharts-layer{outline:2px solid transparent;outline-offset:2px}.\[\&_\.recharts-polar-grid_\[stroke\=\'\#ccc\'\]\]\:stroke-border .recharts-polar-grid [stroke="#ccc"]{stroke:hsl(var(--border) / 1)}.\[\&_\.recharts-radial-bar-background-sector\]\:fill-muted .recharts-radial-bar-background-sector,.\[\&_\.recharts-rectangle\.recharts-tooltip-cursor\]\:fill-muted .recharts-rectangle.recharts-tooltip-cursor{fill:hsl(var(--muted) / 1)}.\[\&_\.recharts-reference-line_\[stroke\=\'\#ccc\'\]\]\:stroke-border .recharts-reference-line [stroke="#ccc"]{stroke:hsl(var(--border) / 1)}.\[\&_\.recharts-sector\[stroke\=\'\#fff\'\]\]\:stroke-transparent .recharts-sector[stroke="#fff"]{stroke:transparent}.\[\&_\.recharts-sector\]\:outline-none .recharts-sector,.\[\&_\.recharts-surface\]\:outline-none .recharts-surface{outline:2px solid transparent;outline-offset:2px}.\[\&_\[cmdk-group-heading\]\]\:px-2 [cmdk-group-heading]{padding-left:.5rem;padding-right:.5rem}.\[\&_\[cmdk-group-heading\]\]\:py-1\.5 [cmdk-group-heading]{padding-top:.375rem;padding-bottom:.375rem}.\[\&_\[cmdk-group-heading\]\]\:text-xs [cmdk-group-heading]{font-size:.75rem;line-height:1rem}.\[\&_\[cmdk-group-heading\]\]\:font-medium [cmdk-group-heading]{font-weight:500}.\[\&_\[cmdk-group-heading\]\]\:text-muted-foreground [cmdk-group-heading]{--tw-text-opacity: 1;color:hsl(var(--muted-foreground) / var(--tw-text-opacity, 1))}.\[\&_\[cmdk-group\]\:not\(\[hidden\]\)_\~\[cmdk-group\]\]\:pt-0 [cmdk-group]:not([hidden])~[cmdk-group]{padding-top:0}.\[\&_\[cmdk-group\]\]\:px-2 [cmdk-group]{padding-left:.5rem;padding-right:.5rem}.\[\&_\[cmdk-input-wrapper\]_svg\]\:h-5 [cmdk-input-wrapper] svg{height:1.25rem}.\[\&_\[cmdk-input-wrapper\]_svg\]\:w-5 [cmdk-input-wrapper] svg{width:1.25rem}.\[\&_\[cmdk-input\]\]\:h-12 [cmdk-input]{height:3rem}.\[\&_\[cmdk-item\]\]\:px-2 [cmdk-item]{padding-left:.5rem;padding-right:.5rem}.\[\&_\[cmdk-item\]\]\:py-3 [cmdk-item]{padding-top:.75rem;padding-bottom:.75rem}.\[\&_\[cmdk-item\]_svg\]\:h-5 [cmdk-item] svg{height:1.25rem}.\[\&_\[cmdk-item\]_svg\]\:w-5 [cmdk-item] svg{width:1.25rem}.\[\&_p\]\:leading-relaxed p{line-height:1.625}.\[\&_svg\]\:pointer-events-none svg{pointer-events:none}.\[\&_svg\]\:size-4 svg{width:1rem;height:1rem}.\[\&_svg\]\:shrink-0 svg{flex-shrink:0}.\[\&_tr\:last-child\]\:border-0 tr:last-child{border-width:0px}.\[\&_tr\]\:border-b tr{border-bottom-width:1px}[data-side=left][data-collapsible=offcanvas] .\[\[data-side\=left\]\[data-collapsible\=offcanvas\]_\&\]\:-right-2{right:-.5rem}[data-side=left][data-state=collapsed] .\[\[data-side\=left\]\[data-state\=collapsed\]_\&\]\:cursor-e-resize{cursor:e-resize}[data-side=right][data-collapsible=offcanvas] .\[\[data-side\=right\]\[data-collapsible\=offcanvas\]_\&\]\:-left-2{left:-.5rem}[data-side=right][data-state=collapsed] .\[\[data-side\=right\]\[data-state\=collapsed\]_\&\]\:cursor-w-resize{cursor:w-resize}
    </style>
    <body>
        <div id="root"></div>
        
    </body>
    <script> 
      function wE(e, t) {
    for (var n = 0; n < t.length; n++) {
        const s = t[n];
        if (typeof s != "string" && !Array.isArray(s)) {
            for (const o in s)
                if (o !== "default" && !(o in e)) {
                    const a = Object.getOwnPropertyDescriptor(s, o);
                    a && Object.defineProperty(e, o, a.get ? a : {
                        enumerable: !0,
                        get: () => s[o]
                    })
                }
        }
    }
    return Object.freeze(Object.defineProperty(e, Symbol.toStringTag, {
        value: "Module"
    }))
}
(function() {
    const t = document.createElement("link").relList;
    if (t && t.supports && t.supports("modulepreload"))
        return;
    for (const o of document.querySelectorAll('link[rel="modulepreload"]'))
        s(o);
    new MutationObserver(o => {
        for (const a of o)
            if (a.type === "childList")
                for (const u of a.addedNodes)
                    u.tagName === "LINK" && u.rel === "modulepreload" && s(u)
    }
    ).observe(document, {
        childList: !0,
        subtree: !0
    });
    function n(o) {
        const a = {};
        return o.integrity && (a.integrity = o.integrity),
        o.referrerPolicy && (a.referrerPolicy = o.referrerPolicy),
        o.crossOrigin === "use-credentials" ? a.credentials = "include" : o.crossOrigin === "anonymous" ? a.credentials = "omit" : a.credentials = "same-origin",
        a
    }
    function s(o) {
        if (o.ep)
            return;
        o.ep = !0;
        const a = n(o);
        fetch(o.href, a)
    }
}
)();
function rw(e) {
    return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e
}
var Nf = {
    exports: {}
}
  , ta = {}
  , Af = {
    exports: {}
}
  , Ie = {};
var pv;
function bE() {
    if (pv)
        return Ie;
    pv = 1;
    var e = Symbol.for("react.element")
      , t = Symbol.for("react.portal")
      , n = Symbol.for("react.fragment")
      , s = Symbol.for("react.strict_mode")
      , o = Symbol.for("react.profiler")
      , a = Symbol.for("react.provider")
      , u = Symbol.for("react.context")
      , c = Symbol.for("react.forward_ref")
      , f = Symbol.for("react.suspense")
      , h = Symbol.for("react.memo")
      , m = Symbol.for("react.lazy")
      , v = Symbol.iterator;
    function x(D) {
        return D === null || typeof D != "object" ? null : (D = v && D[v] || D["@@iterator"],
        typeof D == "function" ? D : null)
    }
    var T = {
        isMounted: function() {
            return !1
        },
        enqueueForceUpdate: function() {},
        enqueueReplaceState: function() {},
        enqueueSetState: function() {}
    }
      , C = Object.assign
      , S = {};
    function P(D, H, Ce) {
        this.props = D,
        this.context = H,
        this.refs = S,
        this.updater = Ce || T
    }
    P.prototype.isReactComponent = {},
    P.prototype.setState = function(D, H) {
        if (typeof D != "object" && typeof D != "function" && D != null)
            throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
        this.updater.enqueueSetState(this, D, H, "setState")
    }
    ,
    P.prototype.forceUpdate = function(D) {
        this.updater.enqueueForceUpdate(this, D, "forceUpdate")
    }
    ;
    function _() {}
    _.prototype = P.prototype;
    function k(D, H, Ce) {
        this.props = D,
        this.context = H,
        this.refs = S,
        this.updater = Ce || T
    }
    var j = k.prototype = new _;
    j.constructor = k,
    C(j, P.prototype),
    j.isPureReactComponent = !0;
    var M = Array.isArray
      , O = Object.prototype.hasOwnProperty
      , z = {
        current: null
    }
      , U = {
        key: !0,
        ref: !0,
        __self: !0,
        __source: !0
    };
    function W(D, H, Ce) {
        var Ne, Fe = {}, Le = null, Ve = null;
        if (H != null)
            for (Ne in H.ref !== void 0 && (Ve = H.ref),
            H.key !== void 0 && (Le = "" + H.key),
            H)
                O.call(H, Ne) && !U.hasOwnProperty(Ne) && (Fe[Ne] = H[Ne]);
        var ze = arguments.length - 2;
        if (ze === 1)
            Fe.children = Ce;
        else if (1 < ze) {
            for (var Qe = Array(ze), kt = 0; kt < ze; kt++)
                Qe[kt] = arguments[kt + 2];
            Fe.children = Qe
        }
        if (D && D.defaultProps)
            for (Ne in ze = D.defaultProps,
            ze)
                Fe[Ne] === void 0 && (Fe[Ne] = ze[Ne]);
        return {
            $$typeof: e,
            type: D,
            key: Le,
            ref: Ve,
            props: Fe,
            _owner: z.current
        }
    }
    function oe(D, H) {
        return {
            $$typeof: e,
            type: D.type,
            key: H,
            ref: D.ref,
            props: D.props,
            _owner: D._owner
        }
    }
    function fe(D) {
        return typeof D == "object" && D !== null && D.$$typeof === e
    }
    function we(D) {
        var H = {
            "=": "=0",
            ":": "=2"
        };
        return "$" + D.replace(/[=:]/g, function(Ce) {
            return H[Ce]
        })
    }
    var X = /\/+/g;
    function se(D, H) {
        return typeof D == "object" && D !== null && D.key != null ? we("" + D.key) : H.toString(36)
    }
    function G(D, H, Ce, Ne, Fe) {
        var Le = typeof D;
        (Le === "undefined" || Le === "boolean") && (D = null);
        var Ve = !1;
        if (D === null)
            Ve = !0;
        else
            switch (Le) {
            case "string":
            case "number":
                Ve = !0;
                break;
            case "object":
                switch (D.$$typeof) {
                case e:
                case t:
                    Ve = !0
                }
            }
        if (Ve)
            return Ve = D,
            Fe = Fe(Ve),
            D = Ne === "" ? "." + se(Ve, 0) : Ne,
            M(Fe) ? (Ce = "",
            D != null && (Ce = D.replace(X, "$&/") + "/"),
            G(Fe, H, Ce, "", function(kt) {
                return kt
            })) : Fe != null && (fe(Fe) && (Fe = oe(Fe, Ce + (!Fe.key || Ve && Ve.key === Fe.key ? "" : ("" + Fe.key).replace(X, "$&/") + "/") + D)),
            H.push(Fe)),
            1;
        if (Ve = 0,
        Ne = Ne === "" ? "." : Ne + ":",
        M(D))
            for (var ze = 0; ze < D.length; ze++) {
                Le = D[ze];
                var Qe = Ne + se(Le, ze);
                Ve += G(Le, H, Ce, Qe, Fe)
            }
        else if (Qe = x(D),
        typeof Qe == "function")
            for (D = Qe.call(D),
            ze = 0; !(Le = D.next()).done; )
                Le = Le.value,
                Qe = Ne + se(Le, ze++),
                Ve += G(Le, H, Ce, Qe, Fe);
        else if (Le === "object")
            throw H = String(D),
            Error("Objects are not valid as a React child (found: " + (H === "[object Object]" ? "object with keys {" + Object.keys(D).join(", ") + "}" : H) + "). If you meant to render a collection of children, use an array instead.");
        return Ve
    }
    function be(D, H, Ce) {
        if (D == null)
            return D;
        var Ne = []
          , Fe = 0;
        return G(D, Ne, "", "", function(Le) {
            return H.call(Ce, Le, Fe++)
        }),
        Ne
    }
    function ce(D) {
        if (D._status === -1) {
            var H = D._result;
            H = H(),
            H.then(function(Ce) {
                (D._status === 0 || D._status === -1) && (D._status = 1,
                D._result = Ce)
            }, function(Ce) {
                (D._status === 0 || D._status === -1) && (D._status = 2,
                D._result = Ce)
            }),
            D._status === -1 && (D._status = 0,
            D._result = H)
        }
        if (D._status === 1)
            return D._result.default;
        throw D._result
    }
    var ie = {
        current: null
    }
      , B = {
        transition: null
    }
      , ne = {
        ReactCurrentDispatcher: ie,
        ReactCurrentBatchConfig: B,
        ReactCurrentOwner: z
    };
    function J() {
        throw Error("act(...) is not supported in production builds of React.")
    }
    return Ie.Children = {
        map: be,
        forEach: function(D, H, Ce) {
            be(D, function() {
                H.apply(this, arguments)
            }, Ce)
        },
        count: function(D) {
            var H = 0;
            return be(D, function() {
                H++
            }),
            H
        },
        toArray: function(D) {
            return be(D, function(H) {
                return H
            }) || []
        },
        only: function(D) {
            if (!fe(D))
                throw Error("React.Children.only expected to receive a single React element child.");
            return D
        }
    },
    Ie.Component = P,
    Ie.Fragment = n,
    Ie.Profiler = o,
    Ie.PureComponent = k,
    Ie.StrictMode = s,
    Ie.Suspense = f,
    Ie.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ne,
    Ie.act = J,
    Ie.cloneElement = function(D, H, Ce) {
        if (D == null)
            throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + D + ".");
        var Ne = C({}, D.props)
          , Fe = D.key
          , Le = D.ref
          , Ve = D._owner;
        if (H != null) {
            if (H.ref !== void 0 && (Le = H.ref,
            Ve = z.current),
            H.key !== void 0 && (Fe = "" + H.key),
            D.type && D.type.defaultProps)
                var ze = D.type.defaultProps;
            for (Qe in H)
                O.call(H, Qe) && !U.hasOwnProperty(Qe) && (Ne[Qe] = H[Qe] === void 0 && ze !== void 0 ? ze[Qe] : H[Qe])
        }
        var Qe = arguments.length - 2;
        if (Qe === 1)
            Ne.children = Ce;
        else if (1 < Qe) {
            ze = Array(Qe);
            for (var kt = 0; kt < Qe; kt++)
                ze[kt] = arguments[kt + 2];
            Ne.children = ze
        }
        return {
            $$typeof: e,
            type: D.type,
            key: Fe,
            ref: Le,
            props: Ne,
            _owner: Ve
        }
    }
    ,
    Ie.createContext = function(D) {
        return D = {
            $$typeof: u,
            _currentValue: D,
            _currentValue2: D,
            _threadCount: 0,
            Provider: null,
            Consumer: null,
            _defaultValue: null,
            _globalName: null
        },
        D.Provider = {
            $$typeof: a,
            _context: D
        },
        D.Consumer = D
    }
    ,
    Ie.createElement = W,
    Ie.createFactory = function(D) {
        var H = W.bind(null, D);
        return H.type = D,
        H
    }
    ,
    Ie.createRef = function() {
        return {
            current: null
        }
    }
    ,
    Ie.forwardRef = function(D) {
        return {
            $$typeof: c,
            render: D
        }
    }
    ,
    Ie.isValidElement = fe,
    Ie.lazy = function(D) {
        return {
            $$typeof: m,
            _payload: {
                _status: -1,
                _result: D
            },
            _init: ce
        }
    }
    ,
    Ie.memo = function(D, H) {
        return {
            $$typeof: h,
            type: D,
            compare: H === void 0 ? null : H
        }
    }
    ,
    Ie.startTransition = function(D) {
        var H = B.transition;
        B.transition = {};
        try {
            D()
        } finally {
            B.transition = H
        }
    }
    ,
    Ie.unstable_act = J,
    Ie.useCallback = function(D, H) {
        return ie.current.useCallback(D, H)
    }
    ,
    Ie.useContext = function(D) {
        return ie.current.useContext(D)
    }
    ,
    Ie.useDebugValue = function() {}
    ,
    Ie.useDeferredValue = function(D) {
        return ie.current.useDeferredValue(D)
    }
    ,
    Ie.useEffect = function(D, H) {
        return ie.current.useEffect(D, H)
    }
    ,
    Ie.useId = function() {
        return ie.current.useId()
    }
    ,
    Ie.useImperativeHandle = function(D, H, Ce) {
        return ie.current.useImperativeHandle(D, H, Ce)
    }
    ,
    Ie.useInsertionEffect = function(D, H) {
        return ie.current.useInsertionEffect(D, H)
    }
    ,
    Ie.useLayoutEffect = function(D, H) {
        return ie.current.useLayoutEffect(D, H)
    }
    ,
    Ie.useMemo = function(D, H) {
        return ie.current.useMemo(D, H)
    }
    ,
    Ie.useReducer = function(D, H, Ce) {
        return ie.current.useReducer(D, H, Ce)
    }
    ,
    Ie.useRef = function(D) {
        return ie.current.useRef(D)
    }
    ,
    Ie.useState = function(D) {
        return ie.current.useState(D)
    }
    ,
    Ie.useSyncExternalStore = function(D, H, Ce) {
        return ie.current.useSyncExternalStore(D, H, Ce)
    }
    ,
    Ie.useTransition = function() {
        return ie.current.useTransition()
    }
    ,
    Ie.version = "18.3.1",
    Ie
}
var mv;
function lc() {
    return mv || (mv = 1,
    Af.exports = bE()),
    Af.exports
}
var gv;
function SE() {
    if (gv)
        return ta;
    gv = 1;
    var e = lc()
      , t = Symbol.for("react.element")
      , n = Symbol.for("react.fragment")
      , s = Object.prototype.hasOwnProperty
      , o = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner
      , a = {
        key: !0,
        ref: !0,
        __self: !0,
        __source: !0
    };
    function u(c, f, h) {
        var m, v = {}, x = null, T = null;
        h !== void 0 && (x = "" + h),
        f.key !== void 0 && (x = "" + f.key),
        f.ref !== void 0 && (T = f.ref);
        for (m in f)
            s.call(f, m) && !a.hasOwnProperty(m) && (v[m] = f[m]);
        if (c && c.defaultProps)
            for (m in f = c.defaultProps,
            f)
                v[m] === void 0 && (v[m] = f[m]);
        return {
            $$typeof: t,
            type: c,
            key: x,
            ref: T,
            props: v,
            _owner: o.current
        }
    }
    return ta.Fragment = n,
    ta.jsx = u,
    ta.jsxs = u,
    ta
}
var yv;
function TE() {
    return yv || (yv = 1,
    Nf.exports = SE()),
    Nf.exports
}
var y = TE()
  , fu = {}
  , Rf = {
    exports: {}
}
  , sn = {}
  , jf = {
    exports: {}
}
  , Df = {};
var vv;
function PE() {
    return vv || (vv = 1,
    (function(e) {
        function t(B, ne) {
            var J = B.length;
            B.push(ne);
            e: for (; 0 < J; ) {
                var D = J - 1 >>> 1
                  , H = B[D];
                if (0 < o(H, ne))
                    B[D] = ne,
                    B[J] = H,
                    J = D;
                else
                    break e
            }
        }
        function n(B) {
            return B.length === 0 ? null : B[0]
        }
        function s(B) {
            if (B.length === 0)
                return null;
            var ne = B[0]
              , J = B.pop();
            if (J !== ne) {
                B[0] = J;
                e: for (var D = 0, H = B.length, Ce = H >>> 1; D < Ce; ) {
                    var Ne = 2 * (D + 1) - 1
                      , Fe = B[Ne]
                      , Le = Ne + 1
                      , Ve = B[Le];
                    if (0 > o(Fe, J))
                        Le < H && 0 > o(Ve, Fe) ? (B[D] = Ve,
                        B[Le] = J,
                        D = Le) : (B[D] = Fe,
                        B[Ne] = J,
                        D = Ne);
                    else if (Le < H && 0 > o(Ve, J))
                        B[D] = Ve,
                        B[Le] = J,
                        D = Le;
                    else
                        break e
                }
            }
            return ne
        }
        function o(B, ne) {
            var J = B.sortIndex - ne.sortIndex;
            return J !== 0 ? J : B.id - ne.id
        }
        if (typeof performance == "object" && typeof performance.now == "function") {
            var a = performance;
            e.unstable_now = function() {
                return a.now()
            }
        } else {
            var u = Date
              , c = u.now();
            e.unstable_now = function() {
                return u.now() - c
            }
        }
        var f = []
          , h = []
          , m = 1
          , v = null
          , x = 3
          , T = !1
          , C = !1
          , S = !1
          , P = typeof setTimeout == "function" ? setTimeout : null
          , _ = typeof clearTimeout == "function" ? clearTimeout : null
          , k = typeof setImmediate < "u" ? setImmediate : null;
        typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
        function j(B) {
            for (var ne = n(h); ne !== null; ) {
                if (ne.callback === null)
                    s(h);
                else if (ne.startTime <= B)
                    s(h),
                    ne.sortIndex = ne.expirationTime,
                    t(f, ne);
                else
                    break;
                ne = n(h)
            }
        }
        function M(B) {
            if (S = !1,
            j(B),
            !C)
                if (n(f) !== null)
                    C = !0,
                    ce(O);
                else {
                    var ne = n(h);
                    ne !== null && ie(M, ne.startTime - B)
                }
        }
        function O(B, ne) {
            C = !1,
            S && (S = !1,
            _(W),
            W = -1),
            T = !0;
            var J = x;
            try {
                for (j(ne),
                v = n(f); v !== null && (!(v.expirationTime > ne) || B && !we()); ) {
                    var D = v.callback;
                    if (typeof D == "function") {
                        v.callback = null,
                        x = v.priorityLevel;
                        var H = D(v.expirationTime <= ne);
                        ne = e.unstable_now(),
                        typeof H == "function" ? v.callback = H : v === n(f) && s(f),
                        j(ne)
                    } else
                        s(f);
                    v = n(f)
                }
                if (v !== null)
                    var Ce = !0;
                else {
                    var Ne = n(h);
                    Ne !== null && ie(M, Ne.startTime - ne),
                    Ce = !1
                }
                return Ce
            } finally {
                v = null,
                x = J,
                T = !1
            }
        }
        var z = !1
          , U = null
          , W = -1
          , oe = 5
          , fe = -1;
        function we() {
            return !(e.unstable_now() - fe < oe)
        }
        function X() {
            if (U !== null) {
                var B = e.unstable_now();
                fe = B;
                var ne = !0;
                try {
                    ne = U(!0, B)
                } finally {
                    ne ? se() : (z = !1,
                    U = null)
                }
            } else
                z = !1
        }
        var se;
        if (typeof k == "function")
            se = function() {
                k(X)
            }
            ;
        else if (typeof MessageChannel < "u") {
            var G = new MessageChannel
              , be = G.port2;
            G.port1.onmessage = X,
            se = function() {
                be.postMessage(null)
            }
        } else
            se = function() {
                P(X, 0)
            }
            ;
        function ce(B) {
            U = B,
            z || (z = !0,
            se())
        }
        function ie(B, ne) {
            W = P(function() {
                B(e.unstable_now())
            }, ne)
        }
        e.unstable_IdlePriority = 5,
        e.unstable_ImmediatePriority = 1,
        e.unstable_LowPriority = 4,
        e.unstable_NormalPriority = 3,
        e.unstable_Profiling = null,
        e.unstable_UserBlockingPriority = 2,
        e.unstable_cancelCallback = function(B) {
            B.callback = null
        }
        ,
        e.unstable_continueExecution = function() {
            C || T || (C = !0,
            ce(O))
        }
        ,
        e.unstable_forceFrameRate = function(B) {
            0 > B || 125 < B ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : oe = 0 < B ? Math.floor(1e3 / B) : 5
        }
        ,
        e.unstable_getCurrentPriorityLevel = function() {
            return x
        }
        ,
        e.unstable_getFirstCallbackNode = function() {
            return n(f)
        }
        ,
        e.unstable_next = function(B) {
            switch (x) {
            case 1:
            case 2:
            case 3:
                var ne = 3;
                break;
            default:
                ne = x
            }
            var J = x;
            x = ne;
            try {
                return B()
            } finally {
                x = J
            }
        }
        ,
        e.unstable_pauseExecution = function() {}
        ,
        e.unstable_requestPaint = function() {}
        ,
        e.unstable_runWithPriority = function(B, ne) {
            switch (B) {
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
                break;
            default:
                B = 3
            }
            var J = x;
            x = B;
            try {
                return ne()
            } finally {
                x = J
            }
        }
        ,
        e.unstable_scheduleCallback = function(B, ne, J) {
            var D = e.unstable_now();
            switch (typeof J == "object" && J !== null ? (J = J.delay,
            J = typeof J == "number" && 0 < J ? D + J : D) : J = D,
            B) {
            case 1:
                var H = -1;
                break;
            case 2:
                H = 250;
                break;
            case 5:
                H = 1073741823;
                break;
            case 4:
                H = 1e4;
                break;
            default:
                H = 5e3
            }
            return H = J + H,
            B = {
                id: m++,
                callback: ne,
                priorityLevel: B,
                startTime: J,
                expirationTime: H,
                sortIndex: -1
            },
            J > D ? (B.sortIndex = J,
            t(h, B),
            n(f) === null && B === n(h) && (S ? (_(W),
            W = -1) : S = !0,
            ie(M, J - D))) : (B.sortIndex = H,
            t(f, B),
            C || T || (C = !0,
            ce(O))),
            B
        }
        ,
        e.unstable_shouldYield = we,
        e.unstable_wrapCallback = function(B) {
            var ne = x;
            return function() {
                var J = x;
                x = ne;
                try {
                    return B.apply(this, arguments)
                } finally {
                    x = J
                }
            }
        }
    }
    )(Df)),
    Df
}
var xv;
function CE() {
    return xv || (xv = 1,
    jf.exports = PE()),
    jf.exports
}
var wv;
function EE() {
    if (wv)
        return sn;
    wv = 1;
    var e = lc()
      , t = CE();
    function n(r) {
        for (var i = "https://reactjs.org/docs/error-decoder.html?invariant=" + r, l = 1; l < arguments.length; l++)
            i += "&args[]=" + encodeURIComponent(arguments[l]);
        return "Minified React error #" + r + "; visit " + i + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
    }
    var s = new Set
      , o = {};
    function a(r, i) {
        u(r, i),
        u(r + "Capture", i)
    }
    function u(r, i) {
        for (o[r] = i,
        r = 0; r < i.length; r++)
            s.add(i[r])
    }
    var c = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u")
      , f = Object.prototype.hasOwnProperty
      , h = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/
      , m = {}
      , v = {};
    function x(r) {
        return f.call(v, r) ? !0 : f.call(m, r) ? !1 : h.test(r) ? v[r] = !0 : (m[r] = !0,
        !1)
    }
    function T(r, i, l, d) {
        if (l !== null && l.type === 0)
            return !1;
        switch (typeof i) {
        case "function":
        case "symbol":
            return !0;
        case "boolean":
            return d ? !1 : l !== null ? !l.acceptsBooleans : (r = r.toLowerCase().slice(0, 5),
            r !== "data-" && r !== "aria-");
        default:
            return !1
        }
    }
    function C(r, i, l, d) {
        if (i === null || typeof i > "u" || T(r, i, l, d))
            return !0;
        if (d)
            return !1;
        if (l !== null)
            switch (l.type) {
            case 3:
                return !i;
            case 4:
                return i === !1;
            case 5:
                return isNaN(i);
            case 6:
                return isNaN(i) || 1 > i
            }
        return !1
    }
    function S(r, i, l, d, p, g, b) {
        this.acceptsBooleans = i === 2 || i === 3 || i === 4,
        this.attributeName = d,
        this.attributeNamespace = p,
        this.mustUseProperty = l,
        this.propertyName = r,
        this.type = i,
        this.sanitizeURL = g,
        this.removeEmptyString = b
    }
    var P = {};
    "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(r) {
        P[r] = new S(r,0,!1,r,null,!1,!1)
    }),
    [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(r) {
        var i = r[0];
        P[i] = new S(i,1,!1,r[1],null,!1,!1)
    }),
    ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(r) {
        P[r] = new S(r,2,!1,r.toLowerCase(),null,!1,!1)
    }),
    ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(r) {
        P[r] = new S(r,2,!1,r,null,!1,!1)
    }),
    "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(r) {
        P[r] = new S(r,3,!1,r.toLowerCase(),null,!1,!1)
    }),
    ["checked", "multiple", "muted", "selected"].forEach(function(r) {
        P[r] = new S(r,3,!0,r,null,!1,!1)
    }),
    ["capture", "download"].forEach(function(r) {
        P[r] = new S(r,4,!1,r,null,!1,!1)
    }),
    ["cols", "rows", "size", "span"].forEach(function(r) {
        P[r] = new S(r,6,!1,r,null,!1,!1)
    }),
    ["rowSpan", "start"].forEach(function(r) {
        P[r] = new S(r,5,!1,r.toLowerCase(),null,!1,!1)
    });
    var _ = /[\-:]([a-z])/g;
    function k(r) {
        return r[1].toUpperCase()
    }
    "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(r) {
        var i = r.replace(_, k);
        P[i] = new S(i,1,!1,r,null,!1,!1)
    }),
    "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(r) {
        var i = r.replace(_, k);
        P[i] = new S(i,1,!1,r,"http://www.w3.org/1999/xlink",!1,!1)
    }),
    ["xml:base", "xml:lang", "xml:space"].forEach(function(r) {
        var i = r.replace(_, k);
        P[i] = new S(i,1,!1,r,"http://www.w3.org/XML/1998/namespace",!1,!1)
    }),
    ["tabIndex", "crossOrigin"].forEach(function(r) {
        P[r] = new S(r,1,!1,r.toLowerCase(),null,!1,!1)
    }),
    P.xlinkHref = new S("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0,!1),
    ["src", "href", "action", "formAction"].forEach(function(r) {
        P[r] = new S(r,1,!1,r.toLowerCase(),null,!0,!0)
    });
    function j(r, i, l, d) {
        var p = P.hasOwnProperty(i) ? P[i] : null;
        (p !== null ? p.type !== 0 : d || !(2 < i.length) || i[0] !== "o" && i[0] !== "O" || i[1] !== "n" && i[1] !== "N") && (C(i, l, p, d) && (l = null),
        d || p === null ? x(i) && (l === null ? r.removeAttribute(i) : r.setAttribute(i, "" + l)) : p.mustUseProperty ? r[p.propertyName] = l === null ? p.type === 3 ? !1 : "" : l : (i = p.attributeName,
        d = p.attributeNamespace,
        l === null ? r.removeAttribute(i) : (p = p.type,
        l = p === 3 || p === 4 && l === !0 ? "" : "" + l,
        d ? r.setAttributeNS(d, i, l) : r.setAttribute(i, l))))
    }
    var M = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED
      , O = Symbol.for("react.element")
      , z = Symbol.for("react.portal")
      , U = Symbol.for("react.fragment")
      , W = Symbol.for("react.strict_mode")
      , oe = Symbol.for("react.profiler")
      , fe = Symbol.for("react.provider")
      , we = Symbol.for("react.context")
      , X = Symbol.for("react.forward_ref")
      , se = Symbol.for("react.suspense")
      , G = Symbol.for("react.suspense_list")
      , be = Symbol.for("react.memo")
      , ce = Symbol.for("react.lazy")
      , ie = Symbol.for("react.offscreen")
      , B = Symbol.iterator;
    function ne(r) {
        return r === null || typeof r != "object" ? null : (r = B && r[B] || r["@@iterator"],
        typeof r == "function" ? r : null)
    }
    var J = Object.assign, D;
    function H(r) {
        if (D === void 0)
            try {
                throw Error()
            } catch (l) {
                var i = l.stack.trim().match(/\n( *(at )?)/);
                D = i && i[1] || ""
            }
        return `
` + D + r
    }
    var Ce = !1;
    function Ne(r, i) {
        if (!r || Ce)
            return "";
        Ce = !0;
        var l = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        try {
            if (i)
                if (i = function() {
                    throw Error()
                }
                ,
                Object.defineProperty(i.prototype, "props", {
                    set: function() {
                        throw Error()
                    }
                }),
                typeof Reflect == "object" && Reflect.construct) {
                    try {
                        Reflect.construct(i, [])
                    } catch (V) {
                        var d = V
                    }
                    Reflect.construct(r, [], i)
                } else {
                    try {
                        i.call()
                    } catch (V) {
                        d = V
                    }
                    r.call(i.prototype)
                }
            else {
                try {
                    throw Error()
                } catch (V) {
                    d = V
                }
                r()
            }
        } catch (V) {
            if (V && d && typeof V.stack == "string") {
                for (var p = V.stack.split(`
`), g = d.stack.split(`
`), b = p.length - 1, E = g.length - 1; 1 <= b && 0 <= E && p[b] !== g[E]; )
                    E--;
                for (; 1 <= b && 0 <= E; b--,
                E--)
                    if (p[b] !== g[E]) {
                        if (b !== 1 || E !== 1)
                            do
                                if (b--,
                                E--,
                                0 > E || p[b] !== g[E]) {
                                    var A = `
` + p[b].replace(" at new ", " at ");
                                    return r.displayName && A.includes("<anonymous>") && (A = A.replace("<anonymous>", r.displayName)),
                                    A
                                }
                            while (1 <= b && 0 <= E);
                        break
                    }
            }
        } finally {
            Ce = !1,
            Error.prepareStackTrace = l
        }
        return (r = r ? r.displayName || r.name : "") ? H(r) : ""
    }
    function Fe(r) {
        switch (r.tag) {
        case 5:
            return H(r.type);
        case 16:
            return H("Lazy");
        case 13:
            return H("Suspense");
        case 19:
            return H("SuspenseList");
        case 0:
        case 2:
        case 15:
            return r = Ne(r.type, !1),
            r;
        case 11:
            return r = Ne(r.type.render, !1),
            r;
        case 1:
            return r = Ne(r.type, !0),
            r;
        default:
            return ""
        }
    }
    function Le(r) {
        if (r == null)
            return null;
        if (typeof r == "function")
            return r.displayName || r.name || null;
        if (typeof r == "string")
            return r;
        switch (r) {
        case U:
            return "Fragment";
        case z:
            return "Portal";
        case oe:
            return "Profiler";
        case W:
            return "StrictMode";
        case se:
            return "Suspense";
        case G:
            return "SuspenseList"
        }
        if (typeof r == "object")
            switch (r.$$typeof) {
            case we:
                return (r.displayName || "Context") + ".Consumer";
            case fe:
                return (r._context.displayName || "Context") + ".Provider";
            case X:
                var i = r.render;
                return r = r.displayName,
                r || (r = i.displayName || i.name || "",
                r = r !== "" ? "ForwardRef(" + r + ")" : "ForwardRef"),
                r;
            case be:
                return i = r.displayName || null,
                i !== null ? i : Le(r.type) || "Memo";
            case ce:
                i = r._payload,
                r = r._init;
                try {
                    return Le(r(i))
                } catch {}
            }
        return null
    }
    function Ve(r) {
        var i = r.type;
        switch (r.tag) {
        case 24:
            return "Cache";
        case 9:
            return (i.displayName || "Context") + ".Consumer";
        case 10:
            return (i._context.displayName || "Context") + ".Provider";
        case 18:
            return "DehydratedFragment";
        case 11:
            return r = i.render,
            r = r.displayName || r.name || "",
            i.displayName || (r !== "" ? "ForwardRef(" + r + ")" : "ForwardRef");
        case 7:
            return "Fragment";
        case 5:
            return i;
        case 4:
            return "Portal";
        case 3:
            return "Root";
        case 6:
            return "Text";
        case 16:
            return Le(i);
        case 8:
            return i === W ? "StrictMode" : "Mode";
        case 22:
            return "Offscreen";
        case 12:
            return "Profiler";
        case 21:
            return "Scope";
        case 13:
            return "Suspense";
        case 19:
            return "SuspenseList";
        case 25:
            return "TracingMarker";
        case 1:
        case 0:
        case 17:
        case 2:
        case 14:
        case 15:
            if (typeof i == "function")
                return i.displayName || i.name || null;
            if (typeof i == "string")
                return i
        }
        return null
    }
    function ze(r) {
        switch (typeof r) {
        case "boolean":
        case "number":
        case "string":
        case "undefined":
            return r;
        case "object":
            return r;
        default:
            return ""
        }
    }
    function Qe(r) {
        var i = r.type;
        return (r = r.nodeName) && r.toLowerCase() === "input" && (i === "checkbox" || i === "radio")
    }
    function kt(r) {
        var i = Qe(r) ? "checked" : "value"
          , l = Object.getOwnPropertyDescriptor(r.constructor.prototype, i)
          , d = "" + r[i];
        if (!r.hasOwnProperty(i) && typeof l < "u" && typeof l.get == "function" && typeof l.set == "function") {
            var p = l.get
              , g = l.set;
            return Object.defineProperty(r, i, {
                configurable: !0,
                get: function() {
                    return p.call(this)
                },
                set: function(b) {
                    d = "" + b,
                    g.call(this, b)
                }
            }),
            Object.defineProperty(r, i, {
                enumerable: l.enumerable
            }),
            {
                getValue: function() {
                    return d
                },
                setValue: function(b) {
                    d = "" + b
                },
                stopTracking: function() {
                    r._valueTracker = null,
                    delete r[i]
                }
            }
        }
    }
    function Kn(r) {
        r._valueTracker || (r._valueTracker = kt(r))
    }
    function Ts(r) {
        if (!r)
            return !1;
        var i = r._valueTracker;
        if (!i)
            return !0;
        var l = i.getValue()
          , d = "";
        return r && (d = Qe(r) ? r.checked ? "true" : "false" : r.value),
        r = d,
        r !== l ? (i.setValue(r),
        !0) : !1
    }
    function kn(r) {
        if (r = r || (typeof document < "u" ? document : void 0),
        typeof r > "u")
            return null;
        try {
            return r.activeElement || r.body
        } catch {
            return r.body
        }
    }
    function ri(r, i) {
        var l = i.checked;
        return J({}, i, {
            defaultChecked: void 0,
            defaultValue: void 0,
            value: void 0,
            checked: l ?? r._wrapperState.initialChecked
        })
    }
    function rl(r, i) {
        var l = i.defaultValue == null ? "" : i.defaultValue
          , d = i.checked != null ? i.checked : i.defaultChecked;
        l = ze(i.value != null ? i.value : l),
        r._wrapperState = {
            initialChecked: d,
            initialValue: l,
            controlled: i.type === "checkbox" || i.type === "radio" ? i.checked != null : i.value != null
        }
    }
    function go(r, i) {
        i = i.checked,
        i != null && j(r, "checked", i, !1)
    }
    function si(r, i) {
        go(r, i);
        var l = ze(i.value)
          , d = i.type;
        if (l != null)
            d === "number" ? (l === 0 && r.value === "" || r.value != l) && (r.value = "" + l) : r.value !== "" + l && (r.value = "" + l);
        else if (d === "submit" || d === "reset") {
            r.removeAttribute("value");
            return
        }
        i.hasOwnProperty("value") ? yo(r, i.type, l) : i.hasOwnProperty("defaultValue") && yo(r, i.type, ze(i.defaultValue)),
        i.checked == null && i.defaultChecked != null && (r.defaultChecked = !!i.defaultChecked)
    }
    function sl(r, i, l) {
        if (i.hasOwnProperty("value") || i.hasOwnProperty("defaultValue")) {
            var d = i.type;
            if (!(d !== "submit" && d !== "reset" || i.value !== void 0 && i.value !== null))
                return;
            i = "" + r._wrapperState.initialValue,
            l || i === r.value || (r.value = i),
            r.defaultValue = i
        }
        l = r.name,
        l !== "" && (r.name = ""),
        r.defaultChecked = !!r._wrapperState.initialChecked,
        l !== "" && (r.name = l)
    }
    function yo(r, i, l) {
        (i !== "number" || kn(r.ownerDocument) !== r) && (l == null ? r.defaultValue = "" + r._wrapperState.initialValue : r.defaultValue !== "" + l && (r.defaultValue = "" + l))
    }
    var ii = Array.isArray;
    function mr(r, i, l, d) {
        if (r = r.options,
        i) {
            i = {};
            for (var p = 0; p < l.length; p++)
                i["$" + l[p]] = !0;
            for (l = 0; l < r.length; l++)
                p = i.hasOwnProperty("$" + r[l].value),
                r[l].selected !== p && (r[l].selected = p),
                p && d && (r[l].defaultSelected = !0)
        } else {
            for (l = "" + ze(l),
            i = null,
            p = 0; p < r.length; p++) {
                if (r[p].value === l) {
                    r[p].selected = !0,
                    d && (r[p].defaultSelected = !0);
                    return
                }
                i !== null || r[p].disabled || (i = r[p])
            }
            i !== null && (i.selected = !0)
        }
    }
    function N(r, i) {
        if (i.dangerouslySetInnerHTML != null)
            throw Error(n(91));
        return J({}, i, {
            value: void 0,
            defaultValue: void 0,
            children: "" + r._wrapperState.initialValue
        })
    }
    function L(r, i) {
        var l = i.value;
        if (l == null) {
            if (l = i.children,
            i = i.defaultValue,
            l != null) {
                if (i != null)
                    throw Error(n(92));
                if (ii(l)) {
                    if (1 < l.length)
                        throw Error(n(93));
                    l = l[0]
                }
                i = l
            }
            i == null && (i = ""),
            l = i
        }
        r._wrapperState = {
            initialValue: ze(l)
        }
    }
    function $(r, i) {
        var l = ze(i.value)
          , d = ze(i.defaultValue);
        l != null && (l = "" + l,
        l !== r.value && (r.value = l),
        i.defaultValue == null && r.defaultValue !== l && (r.defaultValue = l)),
        d != null && (r.defaultValue = "" + d)
    }
    function ue(r) {
        var i = r.textContent;
        i === r._wrapperState.initialValue && i !== "" && i !== null && (r.value = i)
    }
    function re(r) {
        switch (r) {
        case "svg":
            return "http://www.w3.org/2000/svg";
        case "math":
            return "http://www.w3.org/1998/Math/MathML";
        default:
            return "http://www.w3.org/1999/xhtml"
        }
    }
    function ee(r, i) {
        return r == null || r === "http://www.w3.org/1999/xhtml" ? re(i) : r === "http://www.w3.org/2000/svg" && i === "foreignObject" ? "http://www.w3.org/1999/xhtml" : r
    }
    var pe, Be = (function(r) {
        return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function(i, l, d, p) {
            MSApp.execUnsafeLocalFunction(function() {
                return r(i, l, d, p)
            })
        }
        : r
    }
    )(function(r, i) {
        if (r.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML"in r)
            r.innerHTML = i;
        else {
            for (pe = pe || document.createElement("div"),
            pe.innerHTML = "<svg>" + i.valueOf().toString() + "</svg>",
            i = pe.firstChild; r.firstChild; )
                r.removeChild(r.firstChild);
            for (; i.firstChild; )
                r.appendChild(i.firstChild)
        }
    });
    function Je(r, i) {
        if (i) {
            var l = r.firstChild;
            if (l && l === r.lastChild && l.nodeType === 3) {
                l.nodeValue = i;
                return
            }
        }
        r.textContent = i
    }
    var ft = {
        animationIterationCount: !0,
        aspectRatio: !0,
        borderImageOutset: !0,
        borderImageSlice: !0,
        borderImageWidth: !0,
        boxFlex: !0,
        boxFlexGroup: !0,
        boxOrdinalGroup: !0,
        columnCount: !0,
        columns: !0,
        flex: !0,
        flexGrow: !0,
        flexPositive: !0,
        flexShrink: !0,
        flexNegative: !0,
        flexOrder: !0,
        gridArea: !0,
        gridRow: !0,
        gridRowEnd: !0,
        gridRowSpan: !0,
        gridRowStart: !0,
        gridColumn: !0,
        gridColumnEnd: !0,
        gridColumnSpan: !0,
        gridColumnStart: !0,
        fontWeight: !0,
        lineClamp: !0,
        lineHeight: !0,
        opacity: !0,
        order: !0,
        orphans: !0,
        tabSize: !0,
        widows: !0,
        zIndex: !0,
        zoom: !0,
        fillOpacity: !0,
        floodOpacity: !0,
        stopOpacity: !0,
        strokeDasharray: !0,
        strokeDashoffset: !0,
        strokeMiterlimit: !0,
        strokeOpacity: !0,
        strokeWidth: !0
    }
      , zc = ["Webkit", "ms", "Moz", "O"];
    Object.keys(ft).forEach(function(r) {
        zc.forEach(function(i) {
            i = i + r.charAt(0).toUpperCase() + r.substring(1),
            ft[i] = ft[r]
        })
    });
    function oi(r, i, l) {
        return i == null || typeof i == "boolean" || i === "" ? "" : l || typeof i != "number" || i === 0 || ft.hasOwnProperty(r) && ft[r] ? ("" + i).trim() : i + "px"
    }
    function ai(r, i) {
        r = r.style;
        for (var l in i)
            if (i.hasOwnProperty(l)) {
                var d = l.indexOf("--") === 0
                  , p = oi(l, i[l], d);
                l === "float" && (l = "cssFloat"),
                d ? r.setProperty(l, p) : r[l] = p
            }
    }
    var Uc = J({
        menuitem: !0
    }, {
        area: !0,
        base: !0,
        br: !0,
        col: !0,
        embed: !0,
        hr: !0,
        img: !0,
        input: !0,
        keygen: !0,
        link: !0,
        meta: !0,
        param: !0,
        source: !0,
        track: !0,
        wbr: !0
    });
    function li(r, i) {
        if (i) {
            if (Uc[r] && (i.children != null || i.dangerouslySetInnerHTML != null))
                throw Error(n(137, r));
            if (i.dangerouslySetInnerHTML != null) {
                if (i.children != null)
                    throw Error(n(60));
                if (typeof i.dangerouslySetInnerHTML != "object" || !("__html"in i.dangerouslySetInnerHTML))
                    throw Error(n(61))
            }
            if (i.style != null && typeof i.style != "object")
                throw Error(n(62))
        }
    }
    function vo(r, i) {
        if (r.indexOf("-") === -1)
            return typeof i.is == "string";
        switch (r) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
            return !1;
        default:
            return !0
        }
    }
    var ui = null;
    function $c(r) {
        return r = r.target || r.srcElement || window,
        r.correspondingUseElement && (r = r.correspondingUseElement),
        r.nodeType === 3 ? r.parentNode : r
    }
    var Wc = null
      , ci = null
      , di = null;
    function Rm(r) {
        if (r = Bo(r)) {
            if (typeof Wc != "function")
                throw Error(n(280));
            var i = r.stateNode;
            i && (i = _l(i),
            Wc(r.stateNode, r.type, i))
        }
    }
    function jm(r) {
        ci ? di ? di.push(r) : di = [r] : ci = r
    }
    function Dm() {
        if (ci) {
            var r = ci
              , i = di;
            if (di = ci = null,
            Rm(r),
            i)
                for (r = 0; r < i.length; r++)
                    Rm(i[r])
        }
    }
    function Om(r, i) {
        return r(i)
    }
    function Mm() {}
    var Hc = !1;
    function Im(r, i, l) {
        if (Hc)
            return r(i, l);
        Hc = !0;
        try {
            return Om(r, i, l)
        } finally {
            Hc = !1,
            (ci !== null || di !== null) && (Mm(),
            Dm())
        }
    }
    function xo(r, i) {
        var l = r.stateNode;
        if (l === null)
            return null;
        var d = _l(l);
        if (d === null)
            return null;
        l = d[i];
        e: switch (i) {
        case "onClick":
        case "onClickCapture":
        case "onDoubleClick":
        case "onDoubleClickCapture":
        case "onMouseDown":
        case "onMouseDownCapture":
        case "onMouseMove":
        case "onMouseMoveCapture":
        case "onMouseUp":
        case "onMouseUpCapture":
        case "onMouseEnter":
            (d = !d.disabled) || (r = r.type,
            d = !(r === "button" || r === "input" || r === "select" || r === "textarea")),
            r = !d;
            break e;
        default:
            r = !1
        }
        if (r)
            return null;
        if (l && typeof l != "function")
            throw Error(n(231, i, typeof l));
        return l
    }
    var qc = !1;
    if (c)
        try {
            var wo = {};
            Object.defineProperty(wo, "passive", {
                get: function() {
                    qc = !0
                }
            }),
            window.addEventListener("test", wo, wo),
            window.removeEventListener("test", wo, wo)
        } catch {
            qc = !1
        }
    function EP(r, i, l, d, p, g, b, E, A) {
        var V = Array.prototype.slice.call(arguments, 3);
        try {
            i.apply(l, V)
        } catch (K) {
            this.onError(K)
        }
    }
    var bo = !1
      , il = null
      , ol = !1
      , Qc = null
      , _P = {
        onError: function(r) {
            bo = !0,
            il = r
        }
    };
    function kP(r, i, l, d, p, g, b, E, A) {
        bo = !1,
        il = null,
        EP.apply(_P, arguments)
    }
    function NP(r, i, l, d, p, g, b, E, A) {
        if (kP.apply(this, arguments),
        bo) {
            if (bo) {
                var V = il;
                bo = !1,
                il = null
            } else
                throw Error(n(198));
            ol || (ol = !0,
            Qc = V)
        }
    }
    function Ps(r) {
        var i = r
          , l = r;
        if (r.alternate)
            for (; i.return; )
                i = i.return;
        else {
            r = i;
            do
                i = r,
                (i.flags & 4098) !== 0 && (l = i.return),
                r = i.return;
            while (r)
        }
        return i.tag === 3 ? l : null
    }
    function Fm(r) {
        if (r.tag === 13) {
            var i = r.memoizedState;
            if (i === null && (r = r.alternate,
            r !== null && (i = r.memoizedState)),
            i !== null)
                return i.dehydrated
        }
        return null
    }
    function Lm(r) {
        if (Ps(r) !== r)
            throw Error(n(188))
    }
    function AP(r) {
        var i = r.alternate;
        if (!i) {
            if (i = Ps(r),
            i === null)
                throw Error(n(188));
            return i !== r ? null : r
        }
        for (var l = r, d = i; ; ) {
            var p = l.return;
            if (p === null)
                break;
            var g = p.alternate;
            if (g === null) {
                if (d = p.return,
                d !== null) {
                    l = d;
                    continue
                }
                break
            }
            if (p.child === g.child) {
                for (g = p.child; g; ) {
                    if (g === l)
                        return Lm(p),
                        r;
                    if (g === d)
                        return Lm(p),
                        i;
                    g = g.sibling
                }
                throw Error(n(188))
            }
            if (l.return !== d.return)
                l = p,
                d = g;
            else {
                for (var b = !1, E = p.child; E; ) {
                    if (E === l) {
                        b = !0,
                        l = p,
                        d = g;
                        break
                    }
                    if (E === d) {
                        b = !0,
                        d = p,
                        l = g;
                        break
                    }
                    E = E.sibling
                }
                if (!b) {
                    for (E = g.child; E; ) {
                        if (E === l) {
                            b = !0,
                            l = g,
                            d = p;
                            break
                        }
                        if (E === d) {
                            b = !0,
                            d = g,
                            l = p;
                            break
                        }
                        E = E.sibling
                    }
                    if (!b)
                        throw Error(n(189))
                }
            }
            if (l.alternate !== d)
                throw Error(n(190))
        }
        if (l.tag !== 3)
            throw Error(n(188));
        return l.stateNode.current === l ? r : i
    }
    function Vm(r) {
        return r = AP(r),
        r !== null ? Bm(r) : null
    }
    function Bm(r) {
        if (r.tag === 5 || r.tag === 6)
            return r;
        for (r = r.child; r !== null; ) {
            var i = Bm(r);
            if (i !== null)
                return i;
            r = r.sibling
        }
        return null
    }
    var zm = t.unstable_scheduleCallback
      , Um = t.unstable_cancelCallback
      , RP = t.unstable_shouldYield
      , jP = t.unstable_requestPaint
      , mt = t.unstable_now
      , DP = t.unstable_getCurrentPriorityLevel
      , Kc = t.unstable_ImmediatePriority
      , $m = t.unstable_UserBlockingPriority
      , al = t.unstable_NormalPriority
      , OP = t.unstable_LowPriority
      , Wm = t.unstable_IdlePriority
      , ll = null
      , Gn = null;
    function MP(r) {
        if (Gn && typeof Gn.onCommitFiberRoot == "function")
            try {
                Gn.onCommitFiberRoot(ll, r, void 0, (r.current.flags & 128) === 128)
            } catch {}
    }
    var Nn = Math.clz32 ? Math.clz32 : LP
      , IP = Math.log
      , FP = Math.LN2;
    function LP(r) {
        return r >>>= 0,
        r === 0 ? 32 : 31 - (IP(r) / FP | 0) | 0
    }
    var ul = 64
      , cl = 4194304;
    function So(r) {
        switch (r & -r) {
        case 1:
            return 1;
        case 2:
            return 2;
        case 4:
            return 4;
        case 8:
            return 8;
        case 16:
            return 16;
        case 32:
            return 32;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
            return r & 4194240;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
            return r & 130023424;
        case 134217728:
            return 134217728;
        case 268435456:
            return 268435456;
        case 536870912:
            return 536870912;
        case 1073741824:
            return 1073741824;
        default:
            return r
        }
    }
    function dl(r, i) {
        var l = r.pendingLanes;
        if (l === 0)
            return 0;
        var d = 0
          , p = r.suspendedLanes
          , g = r.pingedLanes
          , b = l & 268435455;
        if (b !== 0) {
            var E = b & ~p;
            E !== 0 ? d = So(E) : (g &= b,
            g !== 0 && (d = So(g)))
        } else
            b = l & ~p,
            b !== 0 ? d = So(b) : g !== 0 && (d = So(g));
        if (d === 0)
            return 0;
        if (i !== 0 && i !== d && (i & p) === 0 && (p = d & -d,
        g = i & -i,
        p >= g || p === 16 && (g & 4194240) !== 0))
            return i;
        if ((d & 4) !== 0 && (d |= l & 16),
        i = r.entangledLanes,
        i !== 0)
            for (r = r.entanglements,
            i &= d; 0 < i; )
                l = 31 - Nn(i),
                p = 1 << l,
                d |= r[l],
                i &= ~p;
        return d
    }
    function VP(r, i) {
        switch (r) {
        case 1:
        case 2:
        case 4:
            return i + 250;
        case 8:
        case 16:
        case 32:
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
            return i + 5e3;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
            return -1;
        case 134217728:
        case 268435456:
        case 536870912:
        case 1073741824:
            return -1;
        default:
            return -1
        }
    }
    function BP(r, i) {
        for (var l = r.suspendedLanes, d = r.pingedLanes, p = r.expirationTimes, g = r.pendingLanes; 0 < g; ) {
            var b = 31 - Nn(g)
              , E = 1 << b
              , A = p[b];
            A === -1 ? ((E & l) === 0 || (E & d) !== 0) && (p[b] = VP(E, i)) : A <= i && (r.expiredLanes |= E),
            g &= ~E
        }
    }
    function Gc(r) {
        return r = r.pendingLanes & -1073741825,
        r !== 0 ? r : r & 1073741824 ? 1073741824 : 0
    }
    function Hm() {
        var r = ul;
        return ul <<= 1,
        (ul & 4194240) === 0 && (ul = 64),
        r
    }
    function Zc(r) {
        for (var i = [], l = 0; 31 > l; l++)
            i.push(r);
        return i
    }
    function To(r, i, l) {
        r.pendingLanes |= i,
        i !== 536870912 && (r.suspendedLanes = 0,
        r.pingedLanes = 0),
        r = r.eventTimes,
        i = 31 - Nn(i),
        r[i] = l
    }
    function zP(r, i) {
        var l = r.pendingLanes & ~i;
        r.pendingLanes = i,
        r.suspendedLanes = 0,
        r.pingedLanes = 0,
        r.expiredLanes &= i,
        r.mutableReadLanes &= i,
        r.entangledLanes &= i,
        i = r.entanglements;
        var d = r.eventTimes;
        for (r = r.expirationTimes; 0 < l; ) {
            var p = 31 - Nn(l)
              , g = 1 << p;
            i[p] = 0,
            d[p] = -1,
            r[p] = -1,
            l &= ~g
        }
    }
    function Yc(r, i) {
        var l = r.entangledLanes |= i;
        for (r = r.entanglements; l; ) {
            var d = 31 - Nn(l)
              , p = 1 << d;
            p & i | r[d] & i && (r[d] |= i),
            l &= ~p
        }
    }
    var Ze = 0;
    function qm(r) {
        return r &= -r,
        1 < r ? 4 < r ? (r & 268435455) !== 0 ? 16 : 536870912 : 4 : 1
    }
    var Qm, Xc, Km, Gm, Zm, Jc = !1, fl = [], Lr = null, Vr = null, Br = null, Po = new Map, Co = new Map, zr = [], UP = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
    function Ym(r, i) {
        switch (r) {
        case "focusin":
        case "focusout":
            Lr = null;
            break;
        case "dragenter":
        case "dragleave":
            Vr = null;
            break;
        case "mouseover":
        case "mouseout":
            Br = null;
            break;
        case "pointerover":
        case "pointerout":
            Po.delete(i.pointerId);
            break;
        case "gotpointercapture":
        case "lostpointercapture":
            Co.delete(i.pointerId)
        }
    }
    function Eo(r, i, l, d, p, g) {
        return r === null || r.nativeEvent !== g ? (r = {
            blockedOn: i,
            domEventName: l,
            eventSystemFlags: d,
            nativeEvent: g,
            targetContainers: [p]
        },
        i !== null && (i = Bo(i),
        i !== null && Xc(i)),
        r) : (r.eventSystemFlags |= d,
        i = r.targetContainers,
        p !== null && i.indexOf(p) === -1 && i.push(p),
        r)
    }
    function $P(r, i, l, d, p) {
        switch (i) {
        case "focusin":
            return Lr = Eo(Lr, r, i, l, d, p),
            !0;
        case "dragenter":
            return Vr = Eo(Vr, r, i, l, d, p),
            !0;
        case "mouseover":
            return Br = Eo(Br, r, i, l, d, p),
            !0;
        case "pointerover":
            var g = p.pointerId;
            return Po.set(g, Eo(Po.get(g) || null, r, i, l, d, p)),
            !0;
        case "gotpointercapture":
            return g = p.pointerId,
            Co.set(g, Eo(Co.get(g) || null, r, i, l, d, p)),
            !0
        }
        return !1
    }
    function Xm(r) {
        var i = Cs(r.target);
        if (i !== null) {
            var l = Ps(i);
            if (l !== null) {
                if (i = l.tag,
                i === 13) {
                    if (i = Fm(l),
                    i !== null) {
                        r.blockedOn = i,
                        Zm(r.priority, function() {
                            Km(l)
                        });
                        return
                    }
                } else if (i === 3 && l.stateNode.current.memoizedState.isDehydrated) {
                    r.blockedOn = l.tag === 3 ? l.stateNode.containerInfo : null;
                    return
                }
            }
        }
        r.blockedOn = null
    }
    function hl(r) {
        if (r.blockedOn !== null)
            return !1;
        for (var i = r.targetContainers; 0 < i.length; ) {
            var l = td(r.domEventName, r.eventSystemFlags, i[0], r.nativeEvent);
            if (l === null) {
                l = r.nativeEvent;
                var d = new l.constructor(l.type,l);
                ui = d,
                l.target.dispatchEvent(d),
                ui = null
            } else
                return i = Bo(l),
                i !== null && Xc(i),
                r.blockedOn = l,
                !1;
            i.shift()
        }
        return !0
    }
    function Jm(r, i, l) {
        hl(r) && l.delete(i)
    }
    function WP() {
        Jc = !1,
        Lr !== null && hl(Lr) && (Lr = null),
        Vr !== null && hl(Vr) && (Vr = null),
        Br !== null && hl(Br) && (Br = null),
        Po.forEach(Jm),
        Co.forEach(Jm)
    }
    function _o(r, i) {
        r.blockedOn === i && (r.blockedOn = null,
        Jc || (Jc = !0,
        t.unstable_scheduleCallback(t.unstable_NormalPriority, WP)))
    }
    function ko(r) {
        function i(p) {
            return _o(p, r)
        }
        if (0 < fl.length) {
            _o(fl[0], r);
            for (var l = 1; l < fl.length; l++) {
                var d = fl[l];
                d.blockedOn === r && (d.blockedOn = null)
            }
        }
        for (Lr !== null && _o(Lr, r),
        Vr !== null && _o(Vr, r),
        Br !== null && _o(Br, r),
        Po.forEach(i),
        Co.forEach(i),
        l = 0; l < zr.length; l++)
            d = zr[l],
            d.blockedOn === r && (d.blockedOn = null);
        for (; 0 < zr.length && (l = zr[0],
        l.blockedOn === null); )
            Xm(l),
            l.blockedOn === null && zr.shift()
    }
    var fi = M.ReactCurrentBatchConfig
      , pl = !0;
    function HP(r, i, l, d) {
        var p = Ze
          , g = fi.transition;
        fi.transition = null;
        try {
            Ze = 1,
            ed(r, i, l, d)
        } finally {
            Ze = p,
            fi.transition = g
        }
    }
    function qP(r, i, l, d) {
        var p = Ze
          , g = fi.transition;
        fi.transition = null;
        try {
            Ze = 4,
            ed(r, i, l, d)
        } finally {
            Ze = p,
            fi.transition = g
        }
    }
    function ed(r, i, l, d) {
        if (pl) {
            var p = td(r, i, l, d);
            if (p === null)
                vd(r, i, d, ml, l),
                Ym(r, d);
            else if ($P(p, r, i, l, d))
                d.stopPropagation();
            else if (Ym(r, d),
            i & 4 && -1 < UP.indexOf(r)) {
                for (; p !== null; ) {
                    var g = Bo(p);
                    if (g !== null && Qm(g),
                    g = td(r, i, l, d),
                    g === null && vd(r, i, d, ml, l),
                    g === p)
                        break;
                    p = g
                }
                p !== null && d.stopPropagation()
            } else
                vd(r, i, d, null, l)
        }
    }
    var ml = null;
    function td(r, i, l, d) {
        if (ml = null,
        r = $c(d),
        r = Cs(r),
        r !== null)
            if (i = Ps(r),
            i === null)
                r = null;
            else if (l = i.tag,
            l === 13) {
                if (r = Fm(i),
                r !== null)
                    return r;
                r = null
            } else if (l === 3) {
                if (i.stateNode.current.memoizedState.isDehydrated)
                    return i.tag === 3 ? i.stateNode.containerInfo : null;
                r = null
            } else
                i !== r && (r = null);
        return ml = r,
        null
    }
    function eg(r) {
        switch (r) {
        case "cancel":
        case "click":
        case "close":
        case "contextmenu":
        case "copy":
        case "cut":
        case "auxclick":
        case "dblclick":
        case "dragend":
        case "dragstart":
        case "drop":
        case "focusin":
        case "focusout":
        case "input":
        case "invalid":
        case "keydown":
        case "keypress":
        case "keyup":
        case "mousedown":
        case "mouseup":
        case "paste":
        case "pause":
        case "play":
        case "pointercancel":
        case "pointerdown":
        case "pointerup":
        case "ratechange":
        case "reset":
        case "resize":
        case "seeked":
        case "submit":
        case "touchcancel":
        case "touchend":
        case "touchstart":
        case "volumechange":
        case "change":
        case "selectionchange":
        case "textInput":
        case "compositionstart":
        case "compositionend":
        case "compositionupdate":
        case "beforeblur":
        case "afterblur":
        case "beforeinput":
        case "blur":
        case "fullscreenchange":
        case "focus":
        case "hashchange":
        case "popstate":
        case "select":
        case "selectstart":
            return 1;
        case "drag":
        case "dragenter":
        case "dragexit":
        case "dragleave":
        case "dragover":
        case "mousemove":
        case "mouseout":
        case "mouseover":
        case "pointermove":
        case "pointerout":
        case "pointerover":
        case "scroll":
        case "toggle":
        case "touchmove":
        case "wheel":
        case "mouseenter":
        case "mouseleave":
        case "pointerenter":
        case "pointerleave":
            return 4;
        case "message":
            switch (DP()) {
            case Kc:
                return 1;
            case $m:
                return 4;
            case al:
            case OP:
                return 16;
            case Wm:
                return 536870912;
            default:
                return 16
            }
        default:
            return 16
        }
    }
    var Ur = null
      , nd = null
      , gl = null;
    function tg() {
        if (gl)
            return gl;
        var r, i = nd, l = i.length, d, p = "value"in Ur ? Ur.value : Ur.textContent, g = p.length;
        for (r = 0; r < l && i[r] === p[r]; r++)
            ;
        var b = l - r;
        for (d = 1; d <= b && i[l - d] === p[g - d]; d++)
            ;
        return gl = p.slice(r, 1 < d ? 1 - d : void 0)
    }
    function yl(r) {
        var i = r.keyCode;
        return "charCode"in r ? (r = r.charCode,
        r === 0 && i === 13 && (r = 13)) : r = i,
        r === 10 && (r = 13),
        32 <= r || r === 13 ? r : 0
    }
    function vl() {
        return !0
    }
    function ng() {
        return !1
    }
    function on(r) {
        function i(l, d, p, g, b) {
            this._reactName = l,
            this._targetInst = p,
            this.type = d,
            this.nativeEvent = g,
            this.target = b,
            this.currentTarget = null;
            for (var E in r)
                r.hasOwnProperty(E) && (l = r[E],
                this[E] = l ? l(g) : g[E]);
            return this.isDefaultPrevented = (g.defaultPrevented != null ? g.defaultPrevented : g.returnValue === !1) ? vl : ng,
            this.isPropagationStopped = ng,
            this
        }
        return J(i.prototype, {
            preventDefault: function() {
                this.defaultPrevented = !0;
                var l = this.nativeEvent;
                l && (l.preventDefault ? l.preventDefault() : typeof l.returnValue != "unknown" && (l.returnValue = !1),
                this.isDefaultPrevented = vl)
            },
            stopPropagation: function() {
                var l = this.nativeEvent;
                l && (l.stopPropagation ? l.stopPropagation() : typeof l.cancelBubble != "unknown" && (l.cancelBubble = !0),
                this.isPropagationStopped = vl)
            },
            persist: function() {},
            isPersistent: vl
        }),
        i
    }
    var hi = {
        eventPhase: 0,
        bubbles: 0,
        cancelable: 0,
        timeStamp: function(r) {
            return r.timeStamp || Date.now()
        },
        defaultPrevented: 0,
        isTrusted: 0
    }, rd = on(hi), No = J({}, hi, {
        view: 0,
        detail: 0
    }), QP = on(No), sd, id, Ao, xl = J({}, No, {
        screenX: 0,
        screenY: 0,
        clientX: 0,
        clientY: 0,
        pageX: 0,
        pageY: 0,
        ctrlKey: 0,
        shiftKey: 0,
        altKey: 0,
        metaKey: 0,
        getModifierState: ad,
        button: 0,
        buttons: 0,
        relatedTarget: function(r) {
            return r.relatedTarget === void 0 ? r.fromElement === r.srcElement ? r.toElement : r.fromElement : r.relatedTarget
        },
        movementX: function(r) {
            return "movementX"in r ? r.movementX : (r !== Ao && (Ao && r.type === "mousemove" ? (sd = r.screenX - Ao.screenX,
            id = r.screenY - Ao.screenY) : id = sd = 0,
            Ao = r),
            sd)
        },
        movementY: function(r) {
            return "movementY"in r ? r.movementY : id
        }
    }), rg = on(xl), KP = J({}, xl, {
        dataTransfer: 0
    }), GP = on(KP), ZP = J({}, No, {
        relatedTarget: 0
    }), od = on(ZP), YP = J({}, hi, {
        animationName: 0,
        elapsedTime: 0,
        pseudoElement: 0
    }), XP = on(YP), JP = J({}, hi, {
        clipboardData: function(r) {
            return "clipboardData"in r ? r.clipboardData : window.clipboardData
        }
    }), eC = on(JP), tC = J({}, hi, {
        data: 0
    }), sg = on(tC), nC = {
        Esc: "Escape",
        Spacebar: " ",
        Left: "ArrowLeft",
        Up: "ArrowUp",
        Right: "ArrowRight",
        Down: "ArrowDown",
        Del: "Delete",
        Win: "OS",
        Menu: "ContextMenu",
        Apps: "ContextMenu",
        Scroll: "ScrollLock",
        MozPrintableKey: "Unidentified"
    }, rC = {
        8: "Backspace",
        9: "Tab",
        12: "Clear",
        13: "Enter",
        16: "Shift",
        17: "Control",
        18: "Alt",
        19: "Pause",
        20: "CapsLock",
        27: "Escape",
        32: " ",
        33: "PageUp",
        34: "PageDown",
        35: "End",
        36: "Home",
        37: "ArrowLeft",
        38: "ArrowUp",
        39: "ArrowRight",
        40: "ArrowDown",
        45: "Insert",
        46: "Delete",
        112: "F1",
        113: "F2",
        114: "F3",
        115: "F4",
        116: "F5",
        117: "F6",
        118: "F7",
        119: "F8",
        120: "F9",
        121: "F10",
        122: "F11",
        123: "F12",
        144: "NumLock",
        145: "ScrollLock",
        224: "Meta"
    }, sC = {
        Alt: "altKey",
        Control: "ctrlKey",
        Meta: "metaKey",
        Shift: "shiftKey"
    };
    function iC(r) {
        var i = this.nativeEvent;
        return i.getModifierState ? i.getModifierState(r) : (r = sC[r]) ? !!i[r] : !1
    }
    function ad() {
        return iC
    }
    var oC = J({}, No, {
        key: function(r) {
            if (r.key) {
                var i = nC[r.key] || r.key;
                if (i !== "Unidentified")
                    return i
            }
            return r.type === "keypress" ? (r = yl(r),
            r === 13 ? "Enter" : String.fromCharCode(r)) : r.type === "keydown" || r.type === "keyup" ? rC[r.keyCode] || "Unidentified" : ""
        },
        code: 0,
        location: 0,
        ctrlKey: 0,
        shiftKey: 0,
        altKey: 0,
        metaKey: 0,
        repeat: 0,
        locale: 0,
        getModifierState: ad,
        charCode: function(r) {
            return r.type === "keypress" ? yl(r) : 0
        },
        keyCode: function(r) {
            return r.type === "keydown" || r.type === "keyup" ? r.keyCode : 0
        },
        which: function(r) {
            return r.type === "keypress" ? yl(r) : r.type === "keydown" || r.type === "keyup" ? r.keyCode : 0
        }
    })
      , aC = on(oC)
      , lC = J({}, xl, {
        pointerId: 0,
        width: 0,
        height: 0,
        pressure: 0,
        tangentialPressure: 0,
        tiltX: 0,
        tiltY: 0,
        twist: 0,
        pointerType: 0,
        isPrimary: 0
    })
      , ig = on(lC)
      , uC = J({}, No, {
        touches: 0,
        targetTouches: 0,
        changedTouches: 0,
        altKey: 0,
        metaKey: 0,
        ctrlKey: 0,
        shiftKey: 0,
        getModifierState: ad
    })
      , cC = on(uC)
      , dC = J({}, hi, {
        propertyName: 0,
        elapsedTime: 0,
        pseudoElement: 0
    })
      , fC = on(dC)
      , hC = J({}, xl, {
        deltaX: function(r) {
            return "deltaX"in r ? r.deltaX : "wheelDeltaX"in r ? -r.wheelDeltaX : 0
        },
        deltaY: function(r) {
            return "deltaY"in r ? r.deltaY : "wheelDeltaY"in r ? -r.wheelDeltaY : "wheelDelta"in r ? -r.wheelDelta : 0
        },
        deltaZ: 0,
        deltaMode: 0
    })
      , pC = on(hC)
      , mC = [9, 13, 27, 32]
      , ld = c && "CompositionEvent"in window
      , Ro = null;
    c && "documentMode"in document && (Ro = document.documentMode);
    var gC = c && "TextEvent"in window && !Ro
      , og = c && (!ld || Ro && 8 < Ro && 11 >= Ro)
      , ag = " "
      , lg = !1;
    function ug(r, i) {
        switch (r) {
        case "keyup":
            return mC.indexOf(i.keyCode) !== -1;
        case "keydown":
            return i.keyCode !== 229;
        case "keypress":
        case "mousedown":
        case "focusout":
            return !0;
        default:
            return !1
        }
    }
    function cg(r) {
        return r = r.detail,
        typeof r == "object" && "data"in r ? r.data : null
    }
    var pi = !1;
    function yC(r, i) {
        switch (r) {
        case "compositionend":
            return cg(i);
        case "keypress":
            return i.which !== 32 ? null : (lg = !0,
            ag);
        case "textInput":
            return r = i.data,
            r === ag && lg ? null : r;
        default:
            return null
        }
    }
    function vC(r, i) {
        if (pi)
            return r === "compositionend" || !ld && ug(r, i) ? (r = tg(),
            gl = nd = Ur = null,
            pi = !1,
            r) : null;
        switch (r) {
        case "paste":
            return null;
        case "keypress":
            if (!(i.ctrlKey || i.altKey || i.metaKey) || i.ctrlKey && i.altKey) {
                if (i.char && 1 < i.char.length)
                    return i.char;
                if (i.which)
                    return String.fromCharCode(i.which)
            }
            return null;
        case "compositionend":
            return og && i.locale !== "ko" ? null : i.data;
        default:
            return null
        }
    }
    var xC = {
        color: !0,
        date: !0,
        datetime: !0,
        "datetime-local": !0,
        email: !0,
        month: !0,
        number: !0,
        password: !0,
        range: !0,
        search: !0,
        tel: !0,
        text: !0,
        time: !0,
        url: !0,
        week: !0
    };
    function dg(r) {
        var i = r && r.nodeName && r.nodeName.toLowerCase();
        return i === "input" ? !!xC[r.type] : i === "textarea"
    }
    function fg(r, i, l, d) {
        jm(d),
        i = Pl(i, "onChange"),
        0 < i.length && (l = new rd("onChange","change",null,l,d),
        r.push({
            event: l,
            listeners: i
        }))
    }
    var jo = null
      , Do = null;
    function wC(r) {
        Ag(r, 0)
    }
    function wl(r) {
        var i = xi(r);
        if (Ts(i))
            return r
    }
    function bC(r, i) {
        if (r === "change")
            return i
    }
    var hg = !1;
    if (c) {
        var ud;
        if (c) {
            var cd = "oninput"in document;
            if (!cd) {
                var pg = document.createElement("div");
                pg.setAttribute("oninput", "return;"),
                cd = typeof pg.oninput == "function"
            }
            ud = cd
        } else
            ud = !1;
        hg = ud && (!document.documentMode || 9 < document.documentMode)
    }
    function mg() {
        jo && (jo.detachEvent("onpropertychange", gg),
        Do = jo = null)
    }
    function gg(r) {
        if (r.propertyName === "value" && wl(Do)) {
            var i = [];
            fg(i, Do, r, $c(r)),
            Im(wC, i)
        }
    }
    function SC(r, i, l) {
        r === "focusin" ? (mg(),
        jo = i,
        Do = l,
        jo.attachEvent("onpropertychange", gg)) : r === "focusout" && mg()
    }
    function TC(r) {
        if (r === "selectionchange" || r === "keyup" || r === "keydown")
            return wl(Do)
    }
    function PC(r, i) {
        if (r === "click")
            return wl(i)
    }
    function CC(r, i) {
        if (r === "input" || r === "change")
            return wl(i)
    }
    function EC(r, i) {
        return r === i && (r !== 0 || 1 / r === 1 / i) || r !== r && i !== i
    }
    var An = typeof Object.is == "function" ? Object.is : EC;
    function Oo(r, i) {
        if (An(r, i))
            return !0;
        if (typeof r != "object" || r === null || typeof i != "object" || i === null)
            return !1;
        var l = Object.keys(r)
          , d = Object.keys(i);
        if (l.length !== d.length)
            return !1;
        for (d = 0; d < l.length; d++) {
            var p = l[d];
            if (!f.call(i, p) || !An(r[p], i[p]))
                return !1
        }
        return !0
    }
    function yg(r) {
        for (; r && r.firstChild; )
            r = r.firstChild;
        return r
    }
    function vg(r, i) {
        var l = yg(r);
        r = 0;
        for (var d; l; ) {
            if (l.nodeType === 3) {
                if (d = r + l.textContent.length,
                r <= i && d >= i)
                    return {
                        node: l,
                        offset: i - r
                    };
                r = d
            }
            e: {
                for (; l; ) {
                    if (l.nextSibling) {
                        l = l.nextSibling;
                        break e
                    }
                    l = l.parentNode
                }
                l = void 0
            }
            l = yg(l)
        }
    }
    function xg(r, i) {
        return r && i ? r === i ? !0 : r && r.nodeType === 3 ? !1 : i && i.nodeType === 3 ? xg(r, i.parentNode) : "contains"in r ? r.contains(i) : r.compareDocumentPosition ? !!(r.compareDocumentPosition(i) & 16) : !1 : !1
    }
    function wg() {
        for (var r = window, i = kn(); i instanceof r.HTMLIFrameElement; ) {
            try {
                var l = typeof i.contentWindow.location.href == "string"
            } catch {
                l = !1
            }
            if (l)
                r = i.contentWindow;
            else
                break;
            i = kn(r.document)
        }
        return i
    }
    function dd(r) {
        var i = r && r.nodeName && r.nodeName.toLowerCase();
        return i && (i === "input" && (r.type === "text" || r.type === "search" || r.type === "tel" || r.type === "url" || r.type === "password") || i === "textarea" || r.contentEditable === "true")
    }
    function _C(r) {
        var i = wg()
          , l = r.focusedElem
          , d = r.selectionRange;
        if (i !== l && l && l.ownerDocument && xg(l.ownerDocument.documentElement, l)) {
            if (d !== null && dd(l)) {
                if (i = d.start,
                r = d.end,
                r === void 0 && (r = i),
                "selectionStart"in l)
                    l.selectionStart = i,
                    l.selectionEnd = Math.min(r, l.value.length);
                else if (r = (i = l.ownerDocument || document) && i.defaultView || window,
                r.getSelection) {
                    r = r.getSelection();
                    var p = l.textContent.length
                      , g = Math.min(d.start, p);
                    d = d.end === void 0 ? g : Math.min(d.end, p),
                    !r.extend && g > d && (p = d,
                    d = g,
                    g = p),
                    p = vg(l, g);
                    var b = vg(l, d);
                    p && b && (r.rangeCount !== 1 || r.anchorNode !== p.node || r.anchorOffset !== p.offset || r.focusNode !== b.node || r.focusOffset !== b.offset) && (i = i.createRange(),
                    i.setStart(p.node, p.offset),
                    r.removeAllRanges(),
                    g > d ? (r.addRange(i),
                    r.extend(b.node, b.offset)) : (i.setEnd(b.node, b.offset),
                    r.addRange(i)))
                }
            }
            for (i = [],
            r = l; r = r.parentNode; )
                r.nodeType === 1 && i.push({
                    element: r,
                    left: r.scrollLeft,
                    top: r.scrollTop
                });
            for (typeof l.focus == "function" && l.focus(),
            l = 0; l < i.length; l++)
                r = i[l],
                r.element.scrollLeft = r.left,
                r.element.scrollTop = r.top
        }
    }
    var kC = c && "documentMode"in document && 11 >= document.documentMode
      , mi = null
      , fd = null
      , Mo = null
      , hd = !1;
    function bg(r, i, l) {
        var d = l.window === l ? l.document : l.nodeType === 9 ? l : l.ownerDocument;
        hd || mi == null || mi !== kn(d) || (d = mi,
        "selectionStart"in d && dd(d) ? d = {
            start: d.selectionStart,
            end: d.selectionEnd
        } : (d = (d.ownerDocument && d.ownerDocument.defaultView || window).getSelection(),
        d = {
            anchorNode: d.anchorNode,
            anchorOffset: d.anchorOffset,
            focusNode: d.focusNode,
            focusOffset: d.focusOffset
        }),
        Mo && Oo(Mo, d) || (Mo = d,
        d = Pl(fd, "onSelect"),
        0 < d.length && (i = new rd("onSelect","select",null,i,l),
        r.push({
            event: i,
            listeners: d
        }),
        i.target = mi)))
    }
    function bl(r, i) {
        var l = {};
        return l[r.toLowerCase()] = i.toLowerCase(),
        l["Webkit" + r] = "webkit" + i,
        l["Moz" + r] = "moz" + i,
        l
    }
    var gi = {
        animationend: bl("Animation", "AnimationEnd"),
        animationiteration: bl("Animation", "AnimationIteration"),
        animationstart: bl("Animation", "AnimationStart"),
        transitionend: bl("Transition", "TransitionEnd")
    }
      , pd = {}
      , Sg = {};
    c && (Sg = document.createElement("div").style,
    "AnimationEvent"in window || (delete gi.animationend.animation,
    delete gi.animationiteration.animation,
    delete gi.animationstart.animation),
    "TransitionEvent"in window || delete gi.transitionend.transition);
    function Sl(r) {
        if (pd[r])
            return pd[r];
        if (!gi[r])
            return r;
        var i = gi[r], l;
        for (l in i)
            if (i.hasOwnProperty(l) && l in Sg)
                return pd[r] = i[l];
        return r
    }
    var Tg = Sl("animationend")
      , Pg = Sl("animationiteration")
      , Cg = Sl("animationstart")
      , Eg = Sl("transitionend")
      , _g = new Map
      , kg = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
    function $r(r, i) {
        _g.set(r, i),
        a(i, [r])
    }
    for (var md = 0; md < kg.length; md++) {
        var gd = kg[md]
          , NC = gd.toLowerCase()
          , AC = gd[0].toUpperCase() + gd.slice(1);
        $r(NC, "on" + AC)
    }
    $r(Tg, "onAnimationEnd"),
    $r(Pg, "onAnimationIteration"),
    $r(Cg, "onAnimationStart"),
    $r("dblclick", "onDoubleClick"),
    $r("focusin", "onFocus"),
    $r("focusout", "onBlur"),
    $r(Eg, "onTransitionEnd"),
    u("onMouseEnter", ["mouseout", "mouseover"]),
    u("onMouseLeave", ["mouseout", "mouseover"]),
    u("onPointerEnter", ["pointerout", "pointerover"]),
    u("onPointerLeave", ["pointerout", "pointerover"]),
    a("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")),
    a("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")),
    a("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]),
    a("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")),
    a("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")),
    a("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
    var Io = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" ")
      , RC = new Set("cancel close invalid load scroll toggle".split(" ").concat(Io));
    function Ng(r, i, l) {
        var d = r.type || "unknown-event";
        r.currentTarget = l,
        NP(d, i, void 0, r),
        r.currentTarget = null
    }
    function Ag(r, i) {
        i = (i & 4) !== 0;
        for (var l = 0; l < r.length; l++) {
            var d = r[l]
              , p = d.event;
            d = d.listeners;
            e: {
                var g = void 0;
                if (i)
                    for (var b = d.length - 1; 0 <= b; b--) {
                        var E = d[b]
                          , A = E.instance
                          , V = E.currentTarget;
                        if (E = E.listener,
                        A !== g && p.isPropagationStopped())
                            break e;
                        Ng(p, E, V),
                        g = A
                    }
                else
                    for (b = 0; b < d.length; b++) {
                        if (E = d[b],
                        A = E.instance,
                        V = E.currentTarget,
                        E = E.listener,
                        A !== g && p.isPropagationStopped())
                            break e;
                        Ng(p, E, V),
                        g = A
                    }
            }
        }
        if (ol)
            throw r = Qc,
            ol = !1,
            Qc = null,
            r
    }
    function tt(r, i) {
        var l = i[Pd];
        l === void 0 && (l = i[Pd] = new Set);
        var d = r + "__bubble";
        l.has(d) || (Rg(i, r, 2, !1),
        l.add(d))
    }
    function yd(r, i, l) {
        var d = 0;
        i && (d |= 4),
        Rg(l, r, d, i)
    }
    var Tl = "_reactListening" + Math.random().toString(36).slice(2);
    function Fo(r) {
        if (!r[Tl]) {
            r[Tl] = !0,
            s.forEach(function(l) {
                l !== "selectionchange" && (RC.has(l) || yd(l, !1, r),
                yd(l, !0, r))
            });
            var i = r.nodeType === 9 ? r : r.ownerDocument;
            i === null || i[Tl] || (i[Tl] = !0,
            yd("selectionchange", !1, i))
        }
    }
    function Rg(r, i, l, d) {
        switch (eg(i)) {
        case 1:
            var p = HP;
            break;
        case 4:
            p = qP;
            break;
        default:
            p = ed
        }
        l = p.bind(null, i, l, r),
        p = void 0,
        !qc || i !== "touchstart" && i !== "touchmove" && i !== "wheel" || (p = !0),
        d ? p !== void 0 ? r.addEventListener(i, l, {
            capture: !0,
            passive: p
        }) : r.addEventListener(i, l, !0) : p !== void 0 ? r.addEventListener(i, l, {
            passive: p
        }) : r.addEventListener(i, l, !1)
    }
    function vd(r, i, l, d, p) {
        var g = d;
        if ((i & 1) === 0 && (i & 2) === 0 && d !== null)
            e: for (; ; ) {
                if (d === null)
                    return;
                var b = d.tag;
                if (b === 3 || b === 4) {
                    var E = d.stateNode.containerInfo;
                    if (E === p || E.nodeType === 8 && E.parentNode === p)
                        break;
                    if (b === 4)
                        for (b = d.return; b !== null; ) {
                            var A = b.tag;
                            if ((A === 3 || A === 4) && (A = b.stateNode.containerInfo,
                            A === p || A.nodeType === 8 && A.parentNode === p))
                                return;
                            b = b.return
                        }
                    for (; E !== null; ) {
                        if (b = Cs(E),
                        b === null)
                            return;
                        if (A = b.tag,
                        A === 5 || A === 6) {
                            d = g = b;
                            continue e
                        }
                        E = E.parentNode
                    }
                }
                d = d.return
            }
        Im(function() {
            var V = g
              , K = $c(l)
              , Z = [];
            e: {
                var Q = _g.get(r);
                if (Q !== void 0) {
                    var de = rd
                      , ge = r;
                    switch (r) {
                    case "keypress":
                        if (yl(l) === 0)
                            break e;
                    case "keydown":
                    case "keyup":
                        de = aC;
                        break;
                    case "focusin":
                        ge = "focus",
                        de = od;
                        break;
                    case "focusout":
                        ge = "blur",
                        de = od;
                        break;
                    case "beforeblur":
                    case "afterblur":
                        de = od;
                        break;
                    case "click":
                        if (l.button === 2)
                            break e;
                    case "auxclick":
                    case "dblclick":
                    case "mousedown":
                    case "mousemove":
                    case "mouseup":
                    case "mouseout":
                    case "mouseover":
                    case "contextmenu":
                        de = rg;
                        break;
                    case "drag":
                    case "dragend":
                    case "dragenter":
                    case "dragexit":
                    case "dragleave":
                    case "dragover":
                    case "dragstart":
                    case "drop":
                        de = GP;
                        break;
                    case "touchcancel":
                    case "touchend":
                    case "touchmove":
                    case "touchstart":
                        de = cC;
                        break;
                    case Tg:
                    case Pg:
                    case Cg:
                        de = XP;
                        break;
                    case Eg:
                        de = fC;
                        break;
                    case "scroll":
                        de = QP;
                        break;
                    case "wheel":
                        de = pC;
                        break;
                    case "copy":
                    case "cut":
                    case "paste":
                        de = eC;
                        break;
                    case "gotpointercapture":
                    case "lostpointercapture":
                    case "pointercancel":
                    case "pointerdown":
                    case "pointermove":
                    case "pointerout":
                    case "pointerover":
                    case "pointerup":
                        de = ig
                    }
                    var ye = (i & 4) !== 0
                      , gt = !ye && r === "scroll"
                      , I = ye ? Q !== null ? Q + "Capture" : null : Q;
                    ye = [];
                    for (var R = V, F; R !== null; ) {
                        F = R;
                        var te = F.stateNode;
                        if (F.tag === 5 && te !== null && (F = te,
                        I !== null && (te = xo(R, I),
                        te != null && ye.push(Lo(R, te, F)))),
                        gt)
                            break;
                        R = R.return
                    }
                    0 < ye.length && (Q = new de(Q,ge,null,l,K),
                    Z.push({
                        event: Q,
                        listeners: ye
                    }))
                }
            }
            if ((i & 7) === 0) {
                e: {
                    if (Q = r === "mouseover" || r === "pointerover",
                    de = r === "mouseout" || r === "pointerout",
                    Q && l !== ui && (ge = l.relatedTarget || l.fromElement) && (Cs(ge) || ge[gr]))
                        break e;
                    if ((de || Q) && (Q = K.window === K ? K : (Q = K.ownerDocument) ? Q.defaultView || Q.parentWindow : window,
                    de ? (ge = l.relatedTarget || l.toElement,
                    de = V,
                    ge = ge ? Cs(ge) : null,
                    ge !== null && (gt = Ps(ge),
                    ge !== gt || ge.tag !== 5 && ge.tag !== 6) && (ge = null)) : (de = null,
                    ge = V),
                    de !== ge)) {
                        if (ye = rg,
                        te = "onMouseLeave",
                        I = "onMouseEnter",
                        R = "mouse",
                        (r === "pointerout" || r === "pointerover") && (ye = ig,
                        te = "onPointerLeave",
                        I = "onPointerEnter",
                        R = "pointer"),
                        gt = de == null ? Q : xi(de),
                        F = ge == null ? Q : xi(ge),
                        Q = new ye(te,R + "leave",de,l,K),
                        Q.target = gt,
                        Q.relatedTarget = F,
                        te = null,
                        Cs(K) === V && (ye = new ye(I,R + "enter",ge,l,K),
                        ye.target = F,
                        ye.relatedTarget = gt,
                        te = ye),
                        gt = te,
                        de && ge)
                            t: {
                                for (ye = de,
                                I = ge,
                                R = 0,
                                F = ye; F; F = yi(F))
                                    R++;
                                for (F = 0,
                                te = I; te; te = yi(te))
                                    F++;
                                for (; 0 < R - F; )
                                    ye = yi(ye),
                                    R--;
                                for (; 0 < F - R; )
                                    I = yi(I),
                                    F--;
                                for (; R--; ) {
                                    if (ye === I || I !== null && ye === I.alternate)
                                        break t;
                                    ye = yi(ye),
                                    I = yi(I)
                                }
                                ye = null
                            }
                        else
                            ye = null;
                        de !== null && jg(Z, Q, de, ye, !1),
                        ge !== null && gt !== null && jg(Z, gt, ge, ye, !0)
                    }
                }
                e: {
                    if (Q = V ? xi(V) : window,
                    de = Q.nodeName && Q.nodeName.toLowerCase(),
                    de === "select" || de === "input" && Q.type === "file")
                        var ve = bC;
                    else if (dg(Q))
                        if (hg)
                            ve = CC;
                        else {
                            ve = TC;
                            var Se = SC
                        }
                    else
                        (de = Q.nodeName) && de.toLowerCase() === "input" && (Q.type === "checkbox" || Q.type === "radio") && (ve = PC);
                    if (ve && (ve = ve(r, V))) {
                        fg(Z, ve, l, K);
                        break e
                    }
                    Se && Se(r, Q, V),
                    r === "focusout" && (Se = Q._wrapperState) && Se.controlled && Q.type === "number" && yo(Q, "number", Q.value)
                }
                switch (Se = V ? xi(V) : window,
                r) {
                case "focusin":
                    (dg(Se) || Se.contentEditable === "true") && (mi = Se,
                    fd = V,
                    Mo = null);
                    break;
                case "focusout":
                    Mo = fd = mi = null;
                    break;
                case "mousedown":
                    hd = !0;
                    break;
                case "contextmenu":
                case "mouseup":
                case "dragend":
                    hd = !1,
                    bg(Z, l, K);
                    break;
                case "selectionchange":
                    if (kC)
                        break;
                case "keydown":
                case "keyup":
                    bg(Z, l, K)
                }
                var Te;
                if (ld)
                    e: {
                        switch (r) {
                        case "compositionstart":
                            var ke = "onCompositionStart";
                            break e;
                        case "compositionend":
                            ke = "onCompositionEnd";
                            break e;
                        case "compositionupdate":
                            ke = "onCompositionUpdate";
                            break e
                        }
                        ke = void 0
                    }
                else
                    pi ? ug(r, l) && (ke = "onCompositionEnd") : r === "keydown" && l.keyCode === 229 && (ke = "onCompositionStart");
                ke && (og && l.locale !== "ko" && (pi || ke !== "onCompositionStart" ? ke === "onCompositionEnd" && pi && (Te = tg()) : (Ur = K,
                nd = "value"in Ur ? Ur.value : Ur.textContent,
                pi = !0)),
                Se = Pl(V, ke),
                0 < Se.length && (ke = new sg(ke,r,null,l,K),
                Z.push({
                    event: ke,
                    listeners: Se
                }),
                Te ? ke.data = Te : (Te = cg(l),
                Te !== null && (ke.data = Te)))),
                (Te = gC ? yC(r, l) : vC(r, l)) && (V = Pl(V, "onBeforeInput"),
                0 < V.length && (K = new sg("onBeforeInput","beforeinput",null,l,K),
                Z.push({
                    event: K,
                    listeners: V
                }),
                K.data = Te))
            }
            Ag(Z, i)
        })
    }
    function Lo(r, i, l) {
        return {
            instance: r,
            listener: i,
            currentTarget: l
        }
    }
    function Pl(r, i) {
        for (var l = i + "Capture", d = []; r !== null; ) {
            var p = r
              , g = p.stateNode;
            p.tag === 5 && g !== null && (p = g,
            g = xo(r, l),
            g != null && d.unshift(Lo(r, g, p)),
            g = xo(r, i),
            g != null && d.push(Lo(r, g, p))),
            r = r.return
        }
        return d
    }
    function yi(r) {
        if (r === null)
            return null;
        do
            r = r.return;
        while (r && r.tag !== 5);
        return r || null
    }
    function jg(r, i, l, d, p) {
        for (var g = i._reactName, b = []; l !== null && l !== d; ) {
            var E = l
              , A = E.alternate
              , V = E.stateNode;
            if (A !== null && A === d)
                break;
            E.tag === 5 && V !== null && (E = V,
            p ? (A = xo(l, g),
            A != null && b.unshift(Lo(l, A, E))) : p || (A = xo(l, g),
            A != null && b.push(Lo(l, A, E)))),
            l = l.return
        }
        b.length !== 0 && r.push({
            event: i,
            listeners: b
        })
    }
    var jC = /\r\n?/g
      , DC = /\u0000|\uFFFD/g;
    function Dg(r) {
        return (typeof r == "string" ? r : "" + r).replace(jC, `
`).replace(DC, "")
    }
    function Cl(r, i, l) {
        if (i = Dg(i),
        Dg(r) !== i && l)
            throw Error(n(425))
    }
    function El() {}
    var xd = null
      , wd = null;
    function bd(r, i) {
        return r === "textarea" || r === "noscript" || typeof i.children == "string" || typeof i.children == "number" || typeof i.dangerouslySetInnerHTML == "object" && i.dangerouslySetInnerHTML !== null && i.dangerouslySetInnerHTML.__html != null
    }
    var Sd = typeof setTimeout == "function" ? setTimeout : void 0
      , OC = typeof clearTimeout == "function" ? clearTimeout : void 0
      , Og = typeof Promise == "function" ? Promise : void 0
      , MC = typeof queueMicrotask == "function" ? queueMicrotask : typeof Og < "u" ? function(r) {
        return Og.resolve(null).then(r).catch(IC)
    }
    : Sd;
    function IC(r) {
        setTimeout(function() {
            throw r
        })
    }
    function Td(r, i) {
        var l = i
          , d = 0;
        do {
            var p = l.nextSibling;
            if (r.removeChild(l),
            p && p.nodeType === 8)
                if (l = p.data,
                l === "/$") {
                    if (d === 0) {
                        r.removeChild(p),
                        ko(i);
                        return
                    }
                    d--
                } else
                    l !== "$" && l !== "$?" && l !== "$!" || d++;
            l = p
        } while (l);
        ko(i)
    }
    function Wr(r) {
        for (; r != null; r = r.nextSibling) {
            var i = r.nodeType;
            if (i === 1 || i === 3)
                break;
            if (i === 8) {
                if (i = r.data,
                i === "$" || i === "$!" || i === "$?")
                    break;
                if (i === "/$")
                    return null
            }
        }
        return r
    }
    function Mg(r) {
        r = r.previousSibling;
        for (var i = 0; r; ) {
            if (r.nodeType === 8) {
                var l = r.data;
                if (l === "$" || l === "$!" || l === "$?") {
                    if (i === 0)
                        return r;
                    i--
                } else
                    l === "/$" && i++
            }
            r = r.previousSibling
        }
        return null
    }
    var vi = Math.random().toString(36).slice(2)
      , Zn = "__reactFiber$" + vi
      , Vo = "__reactProps$" + vi
      , gr = "__reactContainer$" + vi
      , Pd = "__reactEvents$" + vi
      , FC = "__reactListeners$" + vi
      , LC = "__reactHandles$" + vi;
    function Cs(r) {
        var i = r[Zn];
        if (i)
            return i;
        for (var l = r.parentNode; l; ) {
            if (i = l[gr] || l[Zn]) {
                if (l = i.alternate,
                i.child !== null || l !== null && l.child !== null)
                    for (r = Mg(r); r !== null; ) {
                        if (l = r[Zn])
                            return l;
                        r = Mg(r)
                    }
                return i
            }
            r = l,
            l = r.parentNode
        }
        return null
    }
    function Bo(r) {
        return r = r[Zn] || r[gr],
        !r || r.tag !== 5 && r.tag !== 6 && r.tag !== 13 && r.tag !== 3 ? null : r
    }
    function xi(r) {
        if (r.tag === 5 || r.tag === 6)
            return r.stateNode;
        throw Error(n(33))
    }
    function _l(r) {
        return r[Vo] || null
    }
    var Cd = []
      , wi = -1;
    function Hr(r) {
        return {
            current: r
        }
    }
    function nt(r) {
        0 > wi || (r.current = Cd[wi],
        Cd[wi] = null,
        wi--)
    }
    function et(r, i) {
        wi++,
        Cd[wi] = r.current,
        r.current = i
    }
    var qr = {}
      , Lt = Hr(qr)
      , Jt = Hr(!1)
      , Es = qr;
    function bi(r, i) {
        var l = r.type.contextTypes;
        if (!l)
            return qr;
        var d = r.stateNode;
        if (d && d.__reactInternalMemoizedUnmaskedChildContext === i)
            return d.__reactInternalMemoizedMaskedChildContext;
        var p = {}, g;
        for (g in l)
            p[g] = i[g];
        return d && (r = r.stateNode,
        r.__reactInternalMemoizedUnmaskedChildContext = i,
        r.__reactInternalMemoizedMaskedChildContext = p),
        p
    }
    function en(r) {
        return r = r.childContextTypes,
        r != null
    }
    function kl() {
        nt(Jt),
        nt(Lt)
    }
    function Ig(r, i, l) {
        if (Lt.current !== qr)
            throw Error(n(168));
        et(Lt, i),
        et(Jt, l)
    }
    function Fg(r, i, l) {
        var d = r.stateNode;
        if (i = i.childContextTypes,
        typeof d.getChildContext != "function")
            return l;
        d = d.getChildContext();
        for (var p in d)
            if (!(p in i))
                throw Error(n(108, Ve(r) || "Unknown", p));
        return J({}, l, d)
    }
    function Nl(r) {
        return r = (r = r.stateNode) && r.__reactInternalMemoizedMergedChildContext || qr,
        Es = Lt.current,
        et(Lt, r),
        et(Jt, Jt.current),
        !0
    }
    function Lg(r, i, l) {
        var d = r.stateNode;
        if (!d)
            throw Error(n(169));
        l ? (r = Fg(r, i, Es),
        d.__reactInternalMemoizedMergedChildContext = r,
        nt(Jt),
        nt(Lt),
        et(Lt, r)) : nt(Jt),
        et(Jt, l)
    }
    var yr = null
      , Al = !1
      , Ed = !1;
    function Vg(r) {
        yr === null ? yr = [r] : yr.push(r)
    }
    function VC(r) {
        Al = !0,
        Vg(r)
    }
    function Qr() {
        if (!Ed && yr !== null) {
            Ed = !0;
            var r = 0
              , i = Ze;
            try {
                var l = yr;
                for (Ze = 1; r < l.length; r++) {
                    var d = l[r];
                    do
                        d = d(!0);
                    while (d !== null)
                }
                yr = null,
                Al = !1
            } catch (p) {
                throw yr !== null && (yr = yr.slice(r + 1)),
                zm(Kc, Qr),
                p
            } finally {
                Ze = i,
                Ed = !1
            }
        }
        return null
    }
    var Si = []
      , Ti = 0
      , Rl = null
      , jl = 0
      , xn = []
      , wn = 0
      , _s = null
      , vr = 1
      , xr = "";
    function ks(r, i) {
        Si[Ti++] = jl,
        Si[Ti++] = Rl,
        Rl = r,
        jl = i
    }
    function Bg(r, i, l) {
        xn[wn++] = vr,
        xn[wn++] = xr,
        xn[wn++] = _s,
        _s = r;
        var d = vr;
        r = xr;
        var p = 32 - Nn(d) - 1;
        d &= ~(1 << p),
        l += 1;
        var g = 32 - Nn(i) + p;
        if (30 < g) {
            var b = p - p % 5;
            g = (d & (1 << b) - 1).toString(32),
            d >>= b,
            p -= b,
            vr = 1 << 32 - Nn(i) + p | l << p | d,
            xr = g + r
        } else
            vr = 1 << g | l << p | d,
            xr = r
    }
    function _d(r) {
        r.return !== null && (ks(r, 1),
        Bg(r, 1, 0))
    }
    function kd(r) {
        for (; r === Rl; )
            Rl = Si[--Ti],
            Si[Ti] = null,
            jl = Si[--Ti],
            Si[Ti] = null;
        for (; r === _s; )
            _s = xn[--wn],
            xn[wn] = null,
            xr = xn[--wn],
            xn[wn] = null,
            vr = xn[--wn],
            xn[wn] = null
    }
    var an = null
      , ln = null
      , ot = !1
      , Rn = null;
    function zg(r, i) {
        var l = Pn(5, null, null, 0);
        l.elementType = "DELETED",
        l.stateNode = i,
        l.return = r,
        i = r.deletions,
        i === null ? (r.deletions = [l],
        r.flags |= 16) : i.push(l)
    }
    function Ug(r, i) {
        switch (r.tag) {
        case 5:
            var l = r.type;
            return i = i.nodeType !== 1 || l.toLowerCase() !== i.nodeName.toLowerCase() ? null : i,
            i !== null ? (r.stateNode = i,
            an = r,
            ln = Wr(i.firstChild),
            !0) : !1;
        case 6:
            return i = r.pendingProps === "" || i.nodeType !== 3 ? null : i,
            i !== null ? (r.stateNode = i,
            an = r,
            ln = null,
            !0) : !1;
        case 13:
            return i = i.nodeType !== 8 ? null : i,
            i !== null ? (l = _s !== null ? {
                id: vr,
                overflow: xr
            } : null,
            r.memoizedState = {
                dehydrated: i,
                treeContext: l,
                retryLane: 1073741824
            },
            l = Pn(18, null, null, 0),
            l.stateNode = i,
            l.return = r,
            r.child = l,
            an = r,
            ln = null,
            !0) : !1;
        default:
            return !1
        }
    }
    function Nd(r) {
        return (r.mode & 1) !== 0 && (r.flags & 128) === 0
    }
    function Ad(r) {
        if (ot) {
            var i = ln;
            if (i) {
                var l = i;
                if (!Ug(r, i)) {
                    if (Nd(r))
                        throw Error(n(418));
                    i = Wr(l.nextSibling);
                    var d = an;
                    i && Ug(r, i) ? zg(d, l) : (r.flags = r.flags & -4097 | 2,
                    ot = !1,
                    an = r)
                }
            } else {
                if (Nd(r))
                    throw Error(n(418));
                r.flags = r.flags & -4097 | 2,
                ot = !1,
                an = r
            }
        }
    }
    function $g(r) {
        for (r = r.return; r !== null && r.tag !== 5 && r.tag !== 3 && r.tag !== 13; )
            r = r.return;
        an = r
    }
    function Dl(r) {
        if (r !== an)
            return !1;
        if (!ot)
            return $g(r),
            ot = !0,
            !1;
        var i;
        if ((i = r.tag !== 3) && !(i = r.tag !== 5) && (i = r.type,
        i = i !== "head" && i !== "body" && !bd(r.type, r.memoizedProps)),
        i && (i = ln)) {
            if (Nd(r))
                throw Wg(),
                Error(n(418));
            for (; i; )
                zg(r, i),
                i = Wr(i.nextSibling)
        }
        if ($g(r),
        r.tag === 13) {
            if (r = r.memoizedState,
            r = r !== null ? r.dehydrated : null,
            !r)
                throw Error(n(317));
            e: {
                for (r = r.nextSibling,
                i = 0; r; ) {
                    if (r.nodeType === 8) {
                        var l = r.data;
                        if (l === "/$") {
                            if (i === 0) {
                                ln = Wr(r.nextSibling);
                                break e
                            }
                            i--
                        } else
                            l !== "$" && l !== "$!" && l !== "$?" || i++
                    }
                    r = r.nextSibling
                }
                ln = null
            }
        } else
            ln = an ? Wr(r.stateNode.nextSibling) : null;
        return !0
    }
    function Wg() {
        for (var r = ln; r; )
            r = Wr(r.nextSibling)
    }
    function Pi() {
        ln = an = null,
        ot = !1
    }
    function Rd(r) {
        Rn === null ? Rn = [r] : Rn.push(r)
    }
    var BC = M.ReactCurrentBatchConfig;
    function zo(r, i, l) {
        if (r = l.ref,
        r !== null && typeof r != "function" && typeof r != "object") {
            if (l._owner) {
                if (l = l._owner,
                l) {
                    if (l.tag !== 1)
                        throw Error(n(309));
                    var d = l.stateNode
                }
                if (!d)
                    throw Error(n(147, r));
                var p = d
                  , g = "" + r;
                return i !== null && i.ref !== null && typeof i.ref == "function" && i.ref._stringRef === g ? i.ref : (i = function(b) {
                    var E = p.refs;
                    b === null ? delete E[g] : E[g] = b
                }
                ,
                i._stringRef = g,
                i)
            }
            if (typeof r != "string")
                throw Error(n(284));
            if (!l._owner)
                throw Error(n(290, r))
        }
        return r
    }
    function Ol(r, i) {
        throw r = Object.prototype.toString.call(i),
        Error(n(31, r === "[object Object]" ? "object with keys {" + Object.keys(i).join(", ") + "}" : r))
    }
    function Hg(r) {
        var i = r._init;
        return i(r._payload)
    }
    function qg(r) {
        function i(I, R) {
            if (r) {
                var F = I.deletions;
                F === null ? (I.deletions = [R],
                I.flags |= 16) : F.push(R)
            }
        }
        function l(I, R) {
            if (!r)
                return null;
            for (; R !== null; )
                i(I, R),
                R = R.sibling;
            return null
        }
        function d(I, R) {
            for (I = new Map; R !== null; )
                R.key !== null ? I.set(R.key, R) : I.set(R.index, R),
                R = R.sibling;
            return I
        }
        function p(I, R) {
            return I = ts(I, R),
            I.index = 0,
            I.sibling = null,
            I
        }
        function g(I, R, F) {
            return I.index = F,
            r ? (F = I.alternate,
            F !== null ? (F = F.index,
            F < R ? (I.flags |= 2,
            R) : F) : (I.flags |= 2,
            R)) : (I.flags |= 1048576,
            R)
        }
        function b(I) {
            return r && I.alternate === null && (I.flags |= 2),
            I
        }
        function E(I, R, F, te) {
            return R === null || R.tag !== 6 ? (R = Tf(F, I.mode, te),
            R.return = I,
            R) : (R = p(R, F),
            R.return = I,
            R)
        }
        function A(I, R, F, te) {
            var ve = F.type;
            return ve === U ? K(I, R, F.props.children, te, F.key) : R !== null && (R.elementType === ve || typeof ve == "object" && ve !== null && ve.$$typeof === ce && Hg(ve) === R.type) ? (te = p(R, F.props),
            te.ref = zo(I, R, F),
            te.return = I,
            te) : (te = su(F.type, F.key, F.props, null, I.mode, te),
            te.ref = zo(I, R, F),
            te.return = I,
            te)
        }
        function V(I, R, F, te) {
            return R === null || R.tag !== 4 || R.stateNode.containerInfo !== F.containerInfo || R.stateNode.implementation !== F.implementation ? (R = Pf(F, I.mode, te),
            R.return = I,
            R) : (R = p(R, F.children || []),
            R.return = I,
            R)
        }
        function K(I, R, F, te, ve) {
            return R === null || R.tag !== 7 ? (R = Is(F, I.mode, te, ve),
            R.return = I,
            R) : (R = p(R, F),
            R.return = I,
            R)
        }
        function Z(I, R, F) {
            if (typeof R == "string" && R !== "" || typeof R == "number")
                return R = Tf("" + R, I.mode, F),
                R.return = I,
                R;
            if (typeof R == "object" && R !== null) {
                switch (R.$$typeof) {
                case O:
                    return F = su(R.type, R.key, R.props, null, I.mode, F),
                    F.ref = zo(I, null, R),
                    F.return = I,
                    F;
                case z:
                    return R = Pf(R, I.mode, F),
                    R.return = I,
                    R;
                case ce:
                    var te = R._init;
                    return Z(I, te(R._payload), F)
                }
                if (ii(R) || ne(R))
                    return R = Is(R, I.mode, F, null),
                    R.return = I,
                    R;
                Ol(I, R)
            }
            return null
        }
        function Q(I, R, F, te) {
            var ve = R !== null ? R.key : null;
            if (typeof F == "string" && F !== "" || typeof F == "number")
                return ve !== null ? null : E(I, R, "" + F, te);
            if (typeof F == "object" && F !== null) {
                switch (F.$$typeof) {
                case O:
                    return F.key === ve ? A(I, R, F, te) : null;
                case z:
                    return F.key === ve ? V(I, R, F, te) : null;
                case ce:
                    return ve = F._init,
                    Q(I, R, ve(F._payload), te)
                }
                if (ii(F) || ne(F))
                    return ve !== null ? null : K(I, R, F, te, null);
                Ol(I, F)
            }
            return null
        }
        function de(I, R, F, te, ve) {
            if (typeof te == "string" && te !== "" || typeof te == "number")
                return I = I.get(F) || null,
                E(R, I, "" + te, ve);
            if (typeof te == "object" && te !== null) {
                switch (te.$$typeof) {
                case O:
                    return I = I.get(te.key === null ? F : te.key) || null,
                    A(R, I, te, ve);
                case z:
                    return I = I.get(te.key === null ? F : te.key) || null,
                    V(R, I, te, ve);
                case ce:
                    var Se = te._init;
                    return de(I, R, F, Se(te._payload), ve)
                }
                if (ii(te) || ne(te))
                    return I = I.get(F) || null,
                    K(R, I, te, ve, null);
                Ol(R, te)
            }
            return null
        }
        function ge(I, R, F, te) {
            for (var ve = null, Se = null, Te = R, ke = R = 0, Rt = null; Te !== null && ke < F.length; ke++) {
                Te.index > ke ? (Rt = Te,
                Te = null) : Rt = Te.sibling;
                var qe = Q(I, Te, F[ke], te);
                if (qe === null) {
                    Te === null && (Te = Rt);
                    break
                }
                r && Te && qe.alternate === null && i(I, Te),
                R = g(qe, R, ke),
                Se === null ? ve = qe : Se.sibling = qe,
                Se = qe,
                Te = Rt
            }
            if (ke === F.length)
                return l(I, Te),
                ot && ks(I, ke),
                ve;
            if (Te === null) {
                for (; ke < F.length; ke++)
                    Te = Z(I, F[ke], te),
                    Te !== null && (R = g(Te, R, ke),
                    Se === null ? ve = Te : Se.sibling = Te,
                    Se = Te);
                return ot && ks(I, ke),
                ve
            }
            for (Te = d(I, Te); ke < F.length; ke++)
                Rt = de(Te, I, ke, F[ke], te),
                Rt !== null && (r && Rt.alternate !== null && Te.delete(Rt.key === null ? ke : Rt.key),
                R = g(Rt, R, ke),
                Se === null ? ve = Rt : Se.sibling = Rt,
                Se = Rt);
            return r && Te.forEach(function(ns) {
                return i(I, ns)
            }),
            ot && ks(I, ke),
            ve
        }
        function ye(I, R, F, te) {
            var ve = ne(F);
            if (typeof ve != "function")
                throw Error(n(150));
            if (F = ve.call(F),
            F == null)
                throw Error(n(151));
            for (var Se = ve = null, Te = R, ke = R = 0, Rt = null, qe = F.next(); Te !== null && !qe.done; ke++,
            qe = F.next()) {
                Te.index > ke ? (Rt = Te,
                Te = null) : Rt = Te.sibling;
                var ns = Q(I, Te, qe.value, te);
                if (ns === null) {
                    Te === null && (Te = Rt);
                    break
                }
                r && Te && ns.alternate === null && i(I, Te),
                R = g(ns, R, ke),
                Se === null ? ve = ns : Se.sibling = ns,
                Se = ns,
                Te = Rt
            }
            if (qe.done)
                return l(I, Te),
                ot && ks(I, ke),
                ve;
            if (Te === null) {
                for (; !qe.done; ke++,
                qe = F.next())
                    qe = Z(I, qe.value, te),
                    qe !== null && (R = g(qe, R, ke),
                    Se === null ? ve = qe : Se.sibling = qe,
                    Se = qe);
                return ot && ks(I, ke),
                ve
            }
            for (Te = d(I, Te); !qe.done; ke++,
            qe = F.next())
                qe = de(Te, I, ke, qe.value, te),
                qe !== null && (r && qe.alternate !== null && Te.delete(qe.key === null ? ke : qe.key),
                R = g(qe, R, ke),
                Se === null ? ve = qe : Se.sibling = qe,
                Se = qe);
            return r && Te.forEach(function(xE) {
                return i(I, xE)
            }),
            ot && ks(I, ke),
            ve
        }
        function gt(I, R, F, te) {
            if (typeof F == "object" && F !== null && F.type === U && F.key === null && (F = F.props.children),
            typeof F == "object" && F !== null) {
                switch (F.$$typeof) {
                case O:
                    e: {
                        for (var ve = F.key, Se = R; Se !== null; ) {
                            if (Se.key === ve) {
                                if (ve = F.type,
                                ve === U) {
                                    if (Se.tag === 7) {
                                        l(I, Se.sibling),
                                        R = p(Se, F.props.children),
                                        R.return = I,
                                        I = R;
                                        break e
                                    }
                                } else if (Se.elementType === ve || typeof ve == "object" && ve !== null && ve.$$typeof === ce && Hg(ve) === Se.type) {
                                    l(I, Se.sibling),
                                    R = p(Se, F.props),
                                    R.ref = zo(I, Se, F),
                                    R.return = I,
                                    I = R;
                                    break e
                                }
                                l(I, Se);
                                break
                            } else
                                i(I, Se);
                            Se = Se.sibling
                        }
                        F.type === U ? (R = Is(F.props.children, I.mode, te, F.key),
                        R.return = I,
                        I = R) : (te = su(F.type, F.key, F.props, null, I.mode, te),
                        te.ref = zo(I, R, F),
                        te.return = I,
                        I = te)
                    }
                    return b(I);
                case z:
                    e: {
                        for (Se = F.key; R !== null; ) {
                            if (R.key === Se)
                                if (R.tag === 4 && R.stateNode.containerInfo === F.containerInfo && R.stateNode.implementation === F.implementation) {
                                    l(I, R.sibling),
                                    R = p(R, F.children || []),
                                    R.return = I,
                                    I = R;
                                    break e
                                } else {
                                    l(I, R);
                                    break
                                }
                            else
                                i(I, R);
                            R = R.sibling
                        }
                        R = Pf(F, I.mode, te),
                        R.return = I,
                        I = R
                    }
                    return b(I);
                case ce:
                    return Se = F._init,
                    gt(I, R, Se(F._payload), te)
                }
                if (ii(F))
                    return ge(I, R, F, te);
                if (ne(F))
                    return ye(I, R, F, te);
                Ol(I, F)
            }
            return typeof F == "string" && F !== "" || typeof F == "number" ? (F = "" + F,
            R !== null && R.tag === 6 ? (l(I, R.sibling),
            R = p(R, F),
            R.return = I,
            I = R) : (l(I, R),
            R = Tf(F, I.mode, te),
            R.return = I,
            I = R),
            b(I)) : l(I, R)
        }
        return gt
    }
    var Ci = qg(!0)
      , Qg = qg(!1)
      , Ml = Hr(null)
      , Il = null
      , Ei = null
      , jd = null;
    function Dd() {
        jd = Ei = Il = null
    }
    function Od(r) {
        var i = Ml.current;
        nt(Ml),
        r._currentValue = i
    }
    function Md(r, i, l) {
        for (; r !== null; ) {
            var d = r.alternate;
            if ((r.childLanes & i) !== i ? (r.childLanes |= i,
            d !== null && (d.childLanes |= i)) : d !== null && (d.childLanes & i) !== i && (d.childLanes |= i),
            r === l)
                break;
            r = r.return
        }
    }
    function _i(r, i) {
        Il = r,
        jd = Ei = null,
        r = r.dependencies,
        r !== null && r.firstContext !== null && ((r.lanes & i) !== 0 && (tn = !0),
        r.firstContext = null)
    }
    function bn(r) {
        var i = r._currentValue;
        if (jd !== r)
            if (r = {
                context: r,
                memoizedValue: i,
                next: null
            },
            Ei === null) {
                if (Il === null)
                    throw Error(n(308));
                Ei = r,
                Il.dependencies = {
                    lanes: 0,
                    firstContext: r
                }
            } else
                Ei = Ei.next = r;
        return i
    }
    var Ns = null;
    function Id(r) {
        Ns === null ? Ns = [r] : Ns.push(r)
    }
    function Kg(r, i, l, d) {
        var p = i.interleaved;
        return p === null ? (l.next = l,
        Id(i)) : (l.next = p.next,
        p.next = l),
        i.interleaved = l,
        wr(r, d)
    }
    function wr(r, i) {
        r.lanes |= i;
        var l = r.alternate;
        for (l !== null && (l.lanes |= i),
        l = r,
        r = r.return; r !== null; )
            r.childLanes |= i,
            l = r.alternate,
            l !== null && (l.childLanes |= i),
            l = r,
            r = r.return;
        return l.tag === 3 ? l.stateNode : null
    }
    var Kr = !1;
    function Fd(r) {
        r.updateQueue = {
            baseState: r.memoizedState,
            firstBaseUpdate: null,
            lastBaseUpdate: null,
            shared: {
                pending: null,
                interleaved: null,
                lanes: 0
            },
            effects: null
        }
    }
    function Gg(r, i) {
        r = r.updateQueue,
        i.updateQueue === r && (i.updateQueue = {
            baseState: r.baseState,
            firstBaseUpdate: r.firstBaseUpdate,
            lastBaseUpdate: r.lastBaseUpdate,
            shared: r.shared,
            effects: r.effects
        })
    }
    function br(r, i) {
        return {
            eventTime: r,
            lane: i,
            tag: 0,
            payload: null,
            callback: null,
            next: null
        }
    }
    function Gr(r, i, l) {
        var d = r.updateQueue;
        if (d === null)
            return null;
        if (d = d.shared,
        ($e & 2) !== 0) {
            var p = d.pending;
            return p === null ? i.next = i : (i.next = p.next,
            p.next = i),
            d.pending = i,
            wr(r, l)
        }
        return p = d.interleaved,
        p === null ? (i.next = i,
        Id(d)) : (i.next = p.next,
        p.next = i),
        d.interleaved = i,
        wr(r, l)
    }
    function Fl(r, i, l) {
        if (i = i.updateQueue,
        i !== null && (i = i.shared,
        (l & 4194240) !== 0)) {
            var d = i.lanes;
            d &= r.pendingLanes,
            l |= d,
            i.lanes = l,
            Yc(r, l)
        }
    }
    function Zg(r, i) {
        var l = r.updateQueue
          , d = r.alternate;
        if (d !== null && (d = d.updateQueue,
        l === d)) {
            var p = null
              , g = null;
            if (l = l.firstBaseUpdate,
            l !== null) {
                do {
                    var b = {
                        eventTime: l.eventTime,
                        lane: l.lane,
                        tag: l.tag,
                        payload: l.payload,
                        callback: l.callback,
                        next: null
                    };
                    g === null ? p = g = b : g = g.next = b,
                    l = l.next
                } while (l !== null);
                g === null ? p = g = i : g = g.next = i
            } else
                p = g = i;
            l = {
                baseState: d.baseState,
                firstBaseUpdate: p,
                lastBaseUpdate: g,
                shared: d.shared,
                effects: d.effects
            },
            r.updateQueue = l;
            return
        }
        r = l.lastBaseUpdate,
        r === null ? l.firstBaseUpdate = i : r.next = i,
        l.lastBaseUpdate = i
    }
    function Ll(r, i, l, d) {
        var p = r.updateQueue;
        Kr = !1;
        var g = p.firstBaseUpdate
          , b = p.lastBaseUpdate
          , E = p.shared.pending;
        if (E !== null) {
            p.shared.pending = null;
            var A = E
              , V = A.next;
            A.next = null,
            b === null ? g = V : b.next = V,
            b = A;
            var K = r.alternate;
            K !== null && (K = K.updateQueue,
            E = K.lastBaseUpdate,
            E !== b && (E === null ? K.firstBaseUpdate = V : E.next = V,
            K.lastBaseUpdate = A))
        }
        if (g !== null) {
            var Z = p.baseState;
            b = 0,
            K = V = A = null,
            E = g;
            do {
                var Q = E.lane
                  , de = E.eventTime;
                if ((d & Q) === Q) {
                    K !== null && (K = K.next = {
                        eventTime: de,
                        lane: 0,
                        tag: E.tag,
                        payload: E.payload,
                        callback: E.callback,
                        next: null
                    });
                    e: {
                        var ge = r
                          , ye = E;
                        switch (Q = i,
                        de = l,
                        ye.tag) {
                        case 1:
                            if (ge = ye.payload,
                            typeof ge == "function") {
                                Z = ge.call(de, Z, Q);
                                break e
                            }
                            Z = ge;
                            break e;
                        case 3:
                            ge.flags = ge.flags & -65537 | 128;
                        case 0:
                            if (ge = ye.payload,
                            Q = typeof ge == "function" ? ge.call(de, Z, Q) : ge,
                            Q == null)
                                break e;
                            Z = J({}, Z, Q);
                            break e;
                        case 2:
                            Kr = !0
                        }
                    }
                    E.callback !== null && E.lane !== 0 && (r.flags |= 64,
                    Q = p.effects,
                    Q === null ? p.effects = [E] : Q.push(E))
                } else
                    de = {
                        eventTime: de,
                        lane: Q,
                        tag: E.tag,
                        payload: E.payload,
                        callback: E.callback,
                        next: null
                    },
                    K === null ? (V = K = de,
                    A = Z) : K = K.next = de,
                    b |= Q;
                if (E = E.next,
                E === null) {
                    if (E = p.shared.pending,
                    E === null)
                        break;
                    Q = E,
                    E = Q.next,
                    Q.next = null,
                    p.lastBaseUpdate = Q,
                    p.shared.pending = null
                }
            } while (!0);
            if (K === null && (A = Z),
            p.baseState = A,
            p.firstBaseUpdate = V,
            p.lastBaseUpdate = K,
            i = p.shared.interleaved,
            i !== null) {
                p = i;
                do
                    b |= p.lane,
                    p = p.next;
                while (p !== i)
            } else
                g === null && (p.shared.lanes = 0);
            js |= b,
            r.lanes = b,
            r.memoizedState = Z
        }
    }
    function Yg(r, i, l) {
        if (r = i.effects,
        i.effects = null,
        r !== null)
            for (i = 0; i < r.length; i++) {
                var d = r[i]
                  , p = d.callback;
                if (p !== null) {
                    if (d.callback = null,
                    d = l,
                    typeof p != "function")
                        throw Error(n(191, p));
                    p.call(d)
                }
            }
    }
    var Uo = {}
      , Yn = Hr(Uo)
      , $o = Hr(Uo)
      , Wo = Hr(Uo);
    function As(r) {
        if (r === Uo)
            throw Error(n(174));
        return r
    }
    function Ld(r, i) {
        switch (et(Wo, i),
        et($o, r),
        et(Yn, Uo),
        r = i.nodeType,
        r) {
        case 9:
        case 11:
            i = (i = i.documentElement) ? i.namespaceURI : ee(null, "");
            break;
        default:
            r = r === 8 ? i.parentNode : i,
            i = r.namespaceURI || null,
            r = r.tagName,
            i = ee(i, r)
        }
        nt(Yn),
        et(Yn, i)
    }
    function ki() {
        nt(Yn),
        nt($o),
        nt(Wo)
    }
    function Xg(r) {
        As(Wo.current);
        var i = As(Yn.current)
          , l = ee(i, r.type);
        i !== l && (et($o, r),
        et(Yn, l))
    }
    function Vd(r) {
        $o.current === r && (nt(Yn),
        nt($o))
    }
    var at = Hr(0);
    function Vl(r) {
        for (var i = r; i !== null; ) {
            if (i.tag === 13) {
                var l = i.memoizedState;
                if (l !== null && (l = l.dehydrated,
                l === null || l.data === "$?" || l.data === "$!"))
                    return i
            } else if (i.tag === 19 && i.memoizedProps.revealOrder !== void 0) {
                if ((i.flags & 128) !== 0)
                    return i
            } else if (i.child !== null) {
                i.child.return = i,
                i = i.child;
                continue
            }
            if (i === r)
                break;
            for (; i.sibling === null; ) {
                if (i.return === null || i.return === r)
                    return null;
                i = i.return
            }
            i.sibling.return = i.return,
            i = i.sibling
        }
        return null
    }
    var Bd = [];
    function zd() {
        for (var r = 0; r < Bd.length; r++)
            Bd[r]._workInProgressVersionPrimary = null;
        Bd.length = 0
    }
    var Bl = M.ReactCurrentDispatcher
      , Ud = M.ReactCurrentBatchConfig
      , Rs = 0
      , lt = null
      , Pt = null
      , Nt = null
      , zl = !1
      , Ho = !1
      , qo = 0
      , zC = 0;
    function Vt() {
        throw Error(n(321))
    }
    function $d(r, i) {
        if (i === null)
            return !1;
        for (var l = 0; l < i.length && l < r.length; l++)
            if (!An(r[l], i[l]))
                return !1;
        return !0
    }
    function Wd(r, i, l, d, p, g) {
        if (Rs = g,
        lt = i,
        i.memoizedState = null,
        i.updateQueue = null,
        i.lanes = 0,
        Bl.current = r === null || r.memoizedState === null ? HC : qC,
        r = l(d, p),
        Ho) {
            g = 0;
            do {
                if (Ho = !1,
                qo = 0,
                25 <= g)
                    throw Error(n(301));
                g += 1,
                Nt = Pt = null,
                i.updateQueue = null,
                Bl.current = QC,
                r = l(d, p)
            } while (Ho)
        }
        if (Bl.current = Wl,
        i = Pt !== null && Pt.next !== null,
        Rs = 0,
        Nt = Pt = lt = null,
        zl = !1,
        i)
            throw Error(n(300));
        return r
    }
    function Hd() {
        var r = qo !== 0;
        return qo = 0,
        r
    }
    function Xn() {
        var r = {
            memoizedState: null,
            baseState: null,
            baseQueue: null,
            queue: null,
            next: null
        };
        return Nt === null ? lt.memoizedState = Nt = r : Nt = Nt.next = r,
        Nt
    }
    function Sn() {
        if (Pt === null) {
            var r = lt.alternate;
            r = r !== null ? r.memoizedState : null
        } else
            r = Pt.next;
        var i = Nt === null ? lt.memoizedState : Nt.next;
        if (i !== null)
            Nt = i,
            Pt = r;
        else {
            if (r === null)
                throw Error(n(310));
            Pt = r,
            r = {
                memoizedState: Pt.memoizedState,
                baseState: Pt.baseState,
                baseQueue: Pt.baseQueue,
                queue: Pt.queue,
                next: null
            },
            Nt === null ? lt.memoizedState = Nt = r : Nt = Nt.next = r
        }
        return Nt
    }
    function Qo(r, i) {
        return typeof i == "function" ? i(r) : i
    }
    function qd(r) {
        var i = Sn()
          , l = i.queue;
        if (l === null)
            throw Error(n(311));
        l.lastRenderedReducer = r;
        var d = Pt
          , p = d.baseQueue
          , g = l.pending;
        if (g !== null) {
            if (p !== null) {
                var b = p.next;
                p.next = g.next,
                g.next = b
            }
            d.baseQueue = p = g,
            l.pending = null
        }
        if (p !== null) {
            g = p.next,
            d = d.baseState;
            var E = b = null
              , A = null
              , V = g;
            do {
                var K = V.lane;
                if ((Rs & K) === K)
                    A !== null && (A = A.next = {
                        lane: 0,
                        action: V.action,
                        hasEagerState: V.hasEagerState,
                        eagerState: V.eagerState,
                        next: null
                    }),
                    d = V.hasEagerState ? V.eagerState : r(d, V.action);
                else {
                    var Z = {
                        lane: K,
                        action: V.action,
                        hasEagerState: V.hasEagerState,
                        eagerState: V.eagerState,
                        next: null
                    };
                    A === null ? (E = A = Z,
                    b = d) : A = A.next = Z,
                    lt.lanes |= K,
                    js |= K
                }
                V = V.next
            } while (V !== null && V !== g);
            A === null ? b = d : A.next = E,
            An(d, i.memoizedState) || (tn = !0),
            i.memoizedState = d,
            i.baseState = b,
            i.baseQueue = A,
            l.lastRenderedState = d
        }
        if (r = l.interleaved,
        r !== null) {
            p = r;
            do
                g = p.lane,
                lt.lanes |= g,
                js |= g,
                p = p.next;
            while (p !== r)
        } else
            p === null && (l.lanes = 0);
        return [i.memoizedState, l.dispatch]
    }
    function Qd(r) {
        var i = Sn()
          , l = i.queue;
        if (l === null)
            throw Error(n(311));
        l.lastRenderedReducer = r;
        var d = l.dispatch
          , p = l.pending
          , g = i.memoizedState;
        if (p !== null) {
            l.pending = null;
            var b = p = p.next;
            do
                g = r(g, b.action),
                b = b.next;
            while (b !== p);
            An(g, i.memoizedState) || (tn = !0),
            i.memoizedState = g,
            i.baseQueue === null && (i.baseState = g),
            l.lastRenderedState = g
        }
        return [g, d]
    }
    function Jg() {}
    function ey(r, i) {
        var l = lt
          , d = Sn()
          , p = i()
          , g = !An(d.memoizedState, p);
        if (g && (d.memoizedState = p,
        tn = !0),
        d = d.queue,
        Kd(ry.bind(null, l, d, r), [r]),
        d.getSnapshot !== i || g || Nt !== null && Nt.memoizedState.tag & 1) {
            if (l.flags |= 2048,
            Ko(9, ny.bind(null, l, d, p, i), void 0, null),
            At === null)
                throw Error(n(349));
            (Rs & 30) !== 0 || ty(l, i, p)
        }
        return p
    }
    function ty(r, i, l) {
        r.flags |= 16384,
        r = {
            getSnapshot: i,
            value: l
        },
        i = lt.updateQueue,
        i === null ? (i = {
            lastEffect: null,
            stores: null
        },
        lt.updateQueue = i,
        i.stores = [r]) : (l = i.stores,
        l === null ? i.stores = [r] : l.push(r))
    }
    function ny(r, i, l, d) {
        i.value = l,
        i.getSnapshot = d,
        sy(i) && iy(r)
    }
    function ry(r, i, l) {
        return l(function() {
            sy(i) && iy(r)
        })
    }
    function sy(r) {
        var i = r.getSnapshot;
        r = r.value;
        try {
            var l = i();
            return !An(r, l)
        } catch {
            return !0
        }
    }
    function iy(r) {
        var i = wr(r, 1);
        i !== null && Mn(i, r, 1, -1)
    }
    function oy(r) {
        var i = Xn();
        return typeof r == "function" && (r = r()),
        i.memoizedState = i.baseState = r,
        r = {
            pending: null,
            interleaved: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: Qo,
            lastRenderedState: r
        },
        i.queue = r,
        r = r.dispatch = WC.bind(null, lt, r),
        [i.memoizedState, r]
    }
    function Ko(r, i, l, d) {
        return r = {
            tag: r,
            create: i,
            destroy: l,
            deps: d,
            next: null
        },
        i = lt.updateQueue,
        i === null ? (i = {
            lastEffect: null,
            stores: null
        },
        lt.updateQueue = i,
        i.lastEffect = r.next = r) : (l = i.lastEffect,
        l === null ? i.lastEffect = r.next = r : (d = l.next,
        l.next = r,
        r.next = d,
        i.lastEffect = r)),
        r
    }
    function ay() {
        return Sn().memoizedState
    }
    function Ul(r, i, l, d) {
        var p = Xn();
        lt.flags |= r,
        p.memoizedState = Ko(1 | i, l, void 0, d === void 0 ? null : d)
    }
    function $l(r, i, l, d) {
        var p = Sn();
        d = d === void 0 ? null : d;
        var g = void 0;
        if (Pt !== null) {
            var b = Pt.memoizedState;
            if (g = b.destroy,
            d !== null && $d(d, b.deps)) {
                p.memoizedState = Ko(i, l, g, d);
                return
            }
        }
        lt.flags |= r,
        p.memoizedState = Ko(1 | i, l, g, d)
    }
    function ly(r, i) {
        return Ul(8390656, 8, r, i)
    }
    function Kd(r, i) {
        return $l(2048, 8, r, i)
    }
    function uy(r, i) {
        return $l(4, 2, r, i)
    }
    function cy(r, i) {
        return $l(4, 4, r, i)
    }
    function dy(r, i) {
        if (typeof i == "function")
            return r = r(),
            i(r),
            function() {
                i(null)
            }
            ;
        if (i != null)
            return r = r(),
            i.current = r,
            function() {
                i.current = null
            }
    }
    function fy(r, i, l) {
        return l = l != null ? l.concat([r]) : null,
        $l(4, 4, dy.bind(null, i, r), l)
    }
    function Gd() {}
    function hy(r, i) {
        var l = Sn();
        i = i === void 0 ? null : i;
        var d = l.memoizedState;
        return d !== null && i !== null && $d(i, d[1]) ? d[0] : (l.memoizedState = [r, i],
        r)
    }
    function py(r, i) {
        var l = Sn();
        i = i === void 0 ? null : i;
        var d = l.memoizedState;
        return d !== null && i !== null && $d(i, d[1]) ? d[0] : (r = r(),
        l.memoizedState = [r, i],
        r)
    }
    function my(r, i, l) {
        return (Rs & 21) === 0 ? (r.baseState && (r.baseState = !1,
        tn = !0),
        r.memoizedState = l) : (An(l, i) || (l = Hm(),
        lt.lanes |= l,
        js |= l,
        r.baseState = !0),
        i)
    }
    function UC(r, i) {
        var l = Ze;
        Ze = l !== 0 && 4 > l ? l : 4,
        r(!0);
        var d = Ud.transition;
        Ud.transition = {};
        try {
            r(!1),
            i()
        } finally {
            Ze = l,
            Ud.transition = d
        }
    }
    function gy() {
        return Sn().memoizedState
    }
    function $C(r, i, l) {
        var d = Jr(r);
        if (l = {
            lane: d,
            action: l,
            hasEagerState: !1,
            eagerState: null,
            next: null
        },
        yy(r))
            vy(i, l);
        else if (l = Kg(r, i, l, d),
        l !== null) {
            var p = Gt();
            Mn(l, r, d, p),
            xy(l, i, d)
        }
    }
    function WC(r, i, l) {
        var d = Jr(r)
          , p = {
            lane: d,
            action: l,
            hasEagerState: !1,
            eagerState: null,
            next: null
        };
        if (yy(r))
            vy(i, p);
        else {
            var g = r.alternate;
            if (r.lanes === 0 && (g === null || g.lanes === 0) && (g = i.lastRenderedReducer,
            g !== null))
                try {
                    var b = i.lastRenderedState
                      , E = g(b, l);
                    if (p.hasEagerState = !0,
                    p.eagerState = E,
                    An(E, b)) {
                        var A = i.interleaved;
                        A === null ? (p.next = p,
                        Id(i)) : (p.next = A.next,
                        A.next = p),
                        i.interleaved = p;
                        return
                    }
                } catch {}
            l = Kg(r, i, p, d),
            l !== null && (p = Gt(),
            Mn(l, r, d, p),
            xy(l, i, d))
        }
    }
    function yy(r) {
        var i = r.alternate;
        return r === lt || i !== null && i === lt
    }
    function vy(r, i) {
        Ho = zl = !0;
        var l = r.pending;
        l === null ? i.next = i : (i.next = l.next,
        l.next = i),
        r.pending = i
    }
    function xy(r, i, l) {
        if ((l & 4194240) !== 0) {
            var d = i.lanes;
            d &= r.pendingLanes,
            l |= d,
            i.lanes = l,
            Yc(r, l)
        }
    }
    var Wl = {
        readContext: bn,
        useCallback: Vt,
        useContext: Vt,
        useEffect: Vt,
        useImperativeHandle: Vt,
        useInsertionEffect: Vt,
        useLayoutEffect: Vt,
        useMemo: Vt,
        useReducer: Vt,
        useRef: Vt,
        useState: Vt,
        useDebugValue: Vt,
        useDeferredValue: Vt,
        useTransition: Vt,
        useMutableSource: Vt,
        useSyncExternalStore: Vt,
        useId: Vt,
        unstable_isNewReconciler: !1
    }
      , HC = {
        readContext: bn,
        useCallback: function(r, i) {
            return Xn().memoizedState = [r, i === void 0 ? null : i],
            r
        },
        useContext: bn,
        useEffect: ly,
        useImperativeHandle: function(r, i, l) {
            return l = l != null ? l.concat([r]) : null,
            Ul(4194308, 4, dy.bind(null, i, r), l)
        },
        useLayoutEffect: function(r, i) {
            return Ul(4194308, 4, r, i)
        },
        useInsertionEffect: function(r, i) {
            return Ul(4, 2, r, i)
        },
        useMemo: function(r, i) {
            var l = Xn();
            return i = i === void 0 ? null : i,
            r = r(),
            l.memoizedState = [r, i],
            r
        },
        useReducer: function(r, i, l) {
            var d = Xn();
            return i = l !== void 0 ? l(i) : i,
            d.memoizedState = d.baseState = i,
            r = {
                pending: null,
                interleaved: null,
                lanes: 0,
                dispatch: null,
                lastRenderedReducer: r,
                lastRenderedState: i
            },
            d.queue = r,
            r = r.dispatch = $C.bind(null, lt, r),
            [d.memoizedState, r]
        },
        useRef: function(r) {
            var i = Xn();
            return r = {
                current: r
            },
            i.memoizedState = r
        },
        useState: oy,
        useDebugValue: Gd,
        useDeferredValue: function(r) {
            return Xn().memoizedState = r
        },
        useTransition: function() {
            var r = oy(!1)
              , i = r[0];
            return r = UC.bind(null, r[1]),
            Xn().memoizedState = r,
            [i, r]
        },
        useMutableSource: function() {},
        useSyncExternalStore: function(r, i, l) {
            var d = lt
              , p = Xn();
            if (ot) {
                if (l === void 0)
                    throw Error(n(407));
                l = l()
            } else {
                if (l = i(),
                At === null)
                    throw Error(n(349));
                (Rs & 30) !== 0 || ty(d, i, l)
            }
            p.memoizedState = l;
            var g = {
                value: l,
                getSnapshot: i
            };
            return p.queue = g,
            ly(ry.bind(null, d, g, r), [r]),
            d.flags |= 2048,
            Ko(9, ny.bind(null, d, g, l, i), void 0, null),
            l
        },
        useId: function() {
            var r = Xn()
              , i = At.identifierPrefix;
            if (ot) {
                var l = xr
                  , d = vr;
                l = (d & ~(1 << 32 - Nn(d) - 1)).toString(32) + l,
                i = ":" + i + "R" + l,
                l = qo++,
                0 < l && (i += "H" + l.toString(32)),
                i += ":"
            } else
                l = zC++,
                i = ":" + i + "r" + l.toString(32) + ":";
            return r.memoizedState = i
        },
        unstable_isNewReconciler: !1
    }
      , qC = {
        readContext: bn,
        useCallback: hy,
        useContext: bn,
        useEffect: Kd,
        useImperativeHandle: fy,
        useInsertionEffect: uy,
        useLayoutEffect: cy,
        useMemo: py,
        useReducer: qd,
        useRef: ay,
        useState: function() {
            return qd(Qo)
        },
        useDebugValue: Gd,
        useDeferredValue: function(r) {
            var i = Sn();
            return my(i, Pt.memoizedState, r)
        },
        useTransition: function() {
            var r = qd(Qo)[0]
              , i = Sn().memoizedState;
            return [r, i]
        },
        useMutableSource: Jg,
        useSyncExternalStore: ey,
        useId: gy,
        unstable_isNewReconciler: !1
    }
      , QC = {
        readContext: bn,
        useCallback: hy,
        useContext: bn,
        useEffect: Kd,
        useImperativeHandle: fy,
        useInsertionEffect: uy,
        useLayoutEffect: cy,
        useMemo: py,
        useReducer: Qd,
        useRef: ay,
        useState: function() {
            return Qd(Qo)
        },
        useDebugValue: Gd,
        useDeferredValue: function(r) {
            var i = Sn();
            return Pt === null ? i.memoizedState = r : my(i, Pt.memoizedState, r)
        },
        useTransition: function() {
            var r = Qd(Qo)[0]
              , i = Sn().memoizedState;
            return [r, i]
        },
        useMutableSource: Jg,
        useSyncExternalStore: ey,
        useId: gy,
        unstable_isNewReconciler: !1
    };
    function jn(r, i) {
        if (r && r.defaultProps) {
            i = J({}, i),
            r = r.defaultProps;
            for (var l in r)
                i[l] === void 0 && (i[l] = r[l]);
            return i
        }
        return i
    }
    function Zd(r, i, l, d) {
        i = r.memoizedState,
        l = l(d, i),
        l = l == null ? i : J({}, i, l),
        r.memoizedState = l,
        r.lanes === 0 && (r.updateQueue.baseState = l)
    }
    var Hl = {
        isMounted: function(r) {
            return (r = r._reactInternals) ? Ps(r) === r : !1
        },
        enqueueSetState: function(r, i, l) {
            r = r._reactInternals;
            var d = Gt()
              , p = Jr(r)
              , g = br(d, p);
            g.payload = i,
            l != null && (g.callback = l),
            i = Gr(r, g, p),
            i !== null && (Mn(i, r, p, d),
            Fl(i, r, p))
        },
        enqueueReplaceState: function(r, i, l) {
            r = r._reactInternals;
            var d = Gt()
              , p = Jr(r)
              , g = br(d, p);
            g.tag = 1,
            g.payload = i,
            l != null && (g.callback = l),
            i = Gr(r, g, p),
            i !== null && (Mn(i, r, p, d),
            Fl(i, r, p))
        },
        enqueueForceUpdate: function(r, i) {
            r = r._reactInternals;
            var l = Gt()
              , d = Jr(r)
              , p = br(l, d);
            p.tag = 2,
            i != null && (p.callback = i),
            i = Gr(r, p, d),
            i !== null && (Mn(i, r, d, l),
            Fl(i, r, d))
        }
    };
    function wy(r, i, l, d, p, g, b) {
        return r = r.stateNode,
        typeof r.shouldComponentUpdate == "function" ? r.shouldComponentUpdate(d, g, b) : i.prototype && i.prototype.isPureReactComponent ? !Oo(l, d) || !Oo(p, g) : !0
    }
    function by(r, i, l) {
        var d = !1
          , p = qr
          , g = i.contextType;
        return typeof g == "object" && g !== null ? g = bn(g) : (p = en(i) ? Es : Lt.current,
        d = i.contextTypes,
        g = (d = d != null) ? bi(r, p) : qr),
        i = new i(l,g),
        r.memoizedState = i.state !== null && i.state !== void 0 ? i.state : null,
        i.updater = Hl,
        r.stateNode = i,
        i._reactInternals = r,
        d && (r = r.stateNode,
        r.__reactInternalMemoizedUnmaskedChildContext = p,
        r.__reactInternalMemoizedMaskedChildContext = g),
        i
    }
    function Sy(r, i, l, d) {
        r = i.state,
        typeof i.componentWillReceiveProps == "function" && i.componentWillReceiveProps(l, d),
        typeof i.UNSAFE_componentWillReceiveProps == "function" && i.UNSAFE_componentWillReceiveProps(l, d),
        i.state !== r && Hl.enqueueReplaceState(i, i.state, null)
    }
    function Yd(r, i, l, d) {
        var p = r.stateNode;
        p.props = l,
        p.state = r.memoizedState,
        p.refs = {},
        Fd(r);
        var g = i.contextType;
        typeof g == "object" && g !== null ? p.context = bn(g) : (g = en(i) ? Es : Lt.current,
        p.context = bi(r, g)),
        p.state = r.memoizedState,
        g = i.getDerivedStateFromProps,
        typeof g == "function" && (Zd(r, i, g, l),
        p.state = r.memoizedState),
        typeof i.getDerivedStateFromProps == "function" || typeof p.getSnapshotBeforeUpdate == "function" || typeof p.UNSAFE_componentWillMount != "function" && typeof p.componentWillMount != "function" || (i = p.state,
        typeof p.componentWillMount == "function" && p.componentWillMount(),
        typeof p.UNSAFE_componentWillMount == "function" && p.UNSAFE_componentWillMount(),
        i !== p.state && Hl.enqueueReplaceState(p, p.state, null),
        Ll(r, l, p, d),
        p.state = r.memoizedState),
        typeof p.componentDidMount == "function" && (r.flags |= 4194308)
    }
    function Ni(r, i) {
        try {
            var l = ""
              , d = i;
            do
                l += Fe(d),
                d = d.return;
            while (d);
            var p = l
        } catch (g) {
            p = `
Error generating stack: ` + g.message + `
` + g.stack
        }
        return {
            value: r,
            source: i,
            stack: p,
            digest: null
        }
    }
    function Xd(r, i, l) {
        return {
            value: r,
            source: null,
            stack: l ?? null,
            digest: i ?? null
        }
    }
    function Jd(r, i) {
        try {
            console.error(i.value)
        } catch (l) {
            setTimeout(function() {
                throw l
            })
        }
    }
    var KC = typeof WeakMap == "function" ? WeakMap : Map;
    function Ty(r, i, l) {
        l = br(-1, l),
        l.tag = 3,
        l.payload = {
            element: null
        };
        var d = i.value;
        return l.callback = function() {
            Xl || (Xl = !0,
            mf = d),
            Jd(r, i)
        }
        ,
        l
    }
    function Py(r, i, l) {
        l = br(-1, l),
        l.tag = 3;
        var d = r.type.getDerivedStateFromError;
        if (typeof d == "function") {
            var p = i.value;
            l.payload = function() {
                return d(p)
            }
            ,
            l.callback = function() {
                Jd(r, i)
            }
        }
        var g = r.stateNode;
        return g !== null && typeof g.componentDidCatch == "function" && (l.callback = function() {
            Jd(r, i),
            typeof d != "function" && (Yr === null ? Yr = new Set([this]) : Yr.add(this));
            var b = i.stack;
            this.componentDidCatch(i.value, {
                componentStack: b !== null ? b : ""
            })
        }
        ),
        l
    }
    function Cy(r, i, l) {
        var d = r.pingCache;
        if (d === null) {
            d = r.pingCache = new KC;
            var p = new Set;
            d.set(i, p)
        } else
            p = d.get(i),
            p === void 0 && (p = new Set,
            d.set(i, p));
        p.has(l) || (p.add(l),
        r = lE.bind(null, r, i, l),
        i.then(r, r))
    }
    function Ey(r) {
        do {
            var i;
            if ((i = r.tag === 13) && (i = r.memoizedState,
            i = i !== null ? i.dehydrated !== null : !0),
            i)
                return r;
            r = r.return
        } while (r !== null);
        return null
    }
    function _y(r, i, l, d, p) {
        return (r.mode & 1) === 0 ? (r === i ? r.flags |= 65536 : (r.flags |= 128,
        l.flags |= 131072,
        l.flags &= -52805,
        l.tag === 1 && (l.alternate === null ? l.tag = 17 : (i = br(-1, 1),
        i.tag = 2,
        Gr(l, i, 1))),
        l.lanes |= 1),
        r) : (r.flags |= 65536,
        r.lanes = p,
        r)
    }
    var GC = M.ReactCurrentOwner
      , tn = !1;
    function Kt(r, i, l, d) {
        i.child = r === null ? Qg(i, null, l, d) : Ci(i, r.child, l, d)
    }
    function ky(r, i, l, d, p) {
        l = l.render;
        var g = i.ref;
        return _i(i, p),
        d = Wd(r, i, l, d, g, p),
        l = Hd(),
        r !== null && !tn ? (i.updateQueue = r.updateQueue,
        i.flags &= -2053,
        r.lanes &= ~p,
        Sr(r, i, p)) : (ot && l && _d(i),
        i.flags |= 1,
        Kt(r, i, d, p),
        i.child)
    }
    function Ny(r, i, l, d, p) {
        if (r === null) {
            var g = l.type;
            return typeof g == "function" && !Sf(g) && g.defaultProps === void 0 && l.compare === null && l.defaultProps === void 0 ? (i.tag = 15,
            i.type = g,
            Ay(r, i, g, d, p)) : (r = su(l.type, null, d, i, i.mode, p),
            r.ref = i.ref,
            r.return = i,
            i.child = r)
        }
        if (g = r.child,
        (r.lanes & p) === 0) {
            var b = g.memoizedProps;
            if (l = l.compare,
            l = l !== null ? l : Oo,
            l(b, d) && r.ref === i.ref)
                return Sr(r, i, p)
        }
        return i.flags |= 1,
        r = ts(g, d),
        r.ref = i.ref,
        r.return = i,
        i.child = r
    }
    function Ay(r, i, l, d, p) {
        if (r !== null) {
            var g = r.memoizedProps;
            if (Oo(g, d) && r.ref === i.ref)
                if (tn = !1,
                i.pendingProps = d = g,
                (r.lanes & p) !== 0)
                    (r.flags & 131072) !== 0 && (tn = !0);
                else
                    return i.lanes = r.lanes,
                    Sr(r, i, p)
        }
        return ef(r, i, l, d, p)
    }
    function Ry(r, i, l) {
        var d = i.pendingProps
          , p = d.children
          , g = r !== null ? r.memoizedState : null;
        if (d.mode === "hidden")
            if ((i.mode & 1) === 0)
                i.memoizedState = {
                    baseLanes: 0,
                    cachePool: null,
                    transitions: null
                },
                et(Ri, un),
                un |= l;
            else {
                if ((l & 1073741824) === 0)
                    return r = g !== null ? g.baseLanes | l : l,
                    i.lanes = i.childLanes = 1073741824,
                    i.memoizedState = {
                        baseLanes: r,
                        cachePool: null,
                        transitions: null
                    },
                    i.updateQueue = null,
                    et(Ri, un),
                    un |= r,
                    null;
                i.memoizedState = {
                    baseLanes: 0,
                    cachePool: null,
                    transitions: null
                },
                d = g !== null ? g.baseLanes : l,
                et(Ri, un),
                un |= d
            }
        else
            g !== null ? (d = g.baseLanes | l,
            i.memoizedState = null) : d = l,
            et(Ri, un),
            un |= d;
        return Kt(r, i, p, l),
        i.child
    }
    function jy(r, i) {
        var l = i.ref;
        (r === null && l !== null || r !== null && r.ref !== l) && (i.flags |= 512,
        i.flags |= 2097152)
    }
    function ef(r, i, l, d, p) {
        var g = en(l) ? Es : Lt.current;
        return g = bi(i, g),
        _i(i, p),
        l = Wd(r, i, l, d, g, p),
        d = Hd(),
        r !== null && !tn ? (i.updateQueue = r.updateQueue,
        i.flags &= -2053,
        r.lanes &= ~p,
        Sr(r, i, p)) : (ot && d && _d(i),
        i.flags |= 1,
        Kt(r, i, l, p),
        i.child)
    }
    function Dy(r, i, l, d, p) {
        if (en(l)) {
            var g = !0;
            Nl(i)
        } else
            g = !1;
        if (_i(i, p),
        i.stateNode === null)
            Ql(r, i),
            by(i, l, d),
            Yd(i, l, d, p),
            d = !0;
        else if (r === null) {
            var b = i.stateNode
              , E = i.memoizedProps;
            b.props = E;
            var A = b.context
              , V = l.contextType;
            typeof V == "object" && V !== null ? V = bn(V) : (V = en(l) ? Es : Lt.current,
            V = bi(i, V));
            var K = l.getDerivedStateFromProps
              , Z = typeof K == "function" || typeof b.getSnapshotBeforeUpdate == "function";
            Z || typeof b.UNSAFE_componentWillReceiveProps != "function" && typeof b.componentWillReceiveProps != "function" || (E !== d || A !== V) && Sy(i, b, d, V),
            Kr = !1;
            var Q = i.memoizedState;
            b.state = Q,
            Ll(i, d, b, p),
            A = i.memoizedState,
            E !== d || Q !== A || Jt.current || Kr ? (typeof K == "function" && (Zd(i, l, K, d),
            A = i.memoizedState),
            (E = Kr || wy(i, l, E, d, Q, A, V)) ? (Z || typeof b.UNSAFE_componentWillMount != "function" && typeof b.componentWillMount != "function" || (typeof b.componentWillMount == "function" && b.componentWillMount(),
            typeof b.UNSAFE_componentWillMount == "function" && b.UNSAFE_componentWillMount()),
            typeof b.componentDidMount == "function" && (i.flags |= 4194308)) : (typeof b.componentDidMount == "function" && (i.flags |= 4194308),
            i.memoizedProps = d,
            i.memoizedState = A),
            b.props = d,
            b.state = A,
            b.context = V,
            d = E) : (typeof b.componentDidMount == "function" && (i.flags |= 4194308),
            d = !1)
        } else {
            b = i.stateNode,
            Gg(r, i),
            E = i.memoizedProps,
            V = i.type === i.elementType ? E : jn(i.type, E),
            b.props = V,
            Z = i.pendingProps,
            Q = b.context,
            A = l.contextType,
            typeof A == "object" && A !== null ? A = bn(A) : (A = en(l) ? Es : Lt.current,
            A = bi(i, A));
            var de = l.getDerivedStateFromProps;
            (K = typeof de == "function" || typeof b.getSnapshotBeforeUpdate == "function") || typeof b.UNSAFE_componentWillReceiveProps != "function" && typeof b.componentWillReceiveProps != "function" || (E !== Z || Q !== A) && Sy(i, b, d, A),
            Kr = !1,
            Q = i.memoizedState,
            b.state = Q,
            Ll(i, d, b, p);
            var ge = i.memoizedState;
            E !== Z || Q !== ge || Jt.current || Kr ? (typeof de == "function" && (Zd(i, l, de, d),
            ge = i.memoizedState),
            (V = Kr || wy(i, l, V, d, Q, ge, A) || !1) ? (K || typeof b.UNSAFE_componentWillUpdate != "function" && typeof b.componentWillUpdate != "function" || (typeof b.componentWillUpdate == "function" && b.componentWillUpdate(d, ge, A),
            typeof b.UNSAFE_componentWillUpdate == "function" && b.UNSAFE_componentWillUpdate(d, ge, A)),
            typeof b.componentDidUpdate == "function" && (i.flags |= 4),
            typeof b.getSnapshotBeforeUpdate == "function" && (i.flags |= 1024)) : (typeof b.componentDidUpdate != "function" || E === r.memoizedProps && Q === r.memoizedState || (i.flags |= 4),
            typeof b.getSnapshotBeforeUpdate != "function" || E === r.memoizedProps && Q === r.memoizedState || (i.flags |= 1024),
            i.memoizedProps = d,
            i.memoizedState = ge),
            b.props = d,
            b.state = ge,
            b.context = A,
            d = V) : (typeof b.componentDidUpdate != "function" || E === r.memoizedProps && Q === r.memoizedState || (i.flags |= 4),
            typeof b.getSnapshotBeforeUpdate != "function" || E === r.memoizedProps && Q === r.memoizedState || (i.flags |= 1024),
            d = !1)
        }
        return tf(r, i, l, d, g, p)
    }
    function tf(r, i, l, d, p, g) {
        jy(r, i);
        var b = (i.flags & 128) !== 0;
        if (!d && !b)
            return p && Lg(i, l, !1),
            Sr(r, i, g);
        d = i.stateNode,
        GC.current = i;
        var E = b && typeof l.getDerivedStateFromError != "function" ? null : d.render();
        return i.flags |= 1,
        r !== null && b ? (i.child = Ci(i, r.child, null, g),
        i.child = Ci(i, null, E, g)) : Kt(r, i, E, g),
        i.memoizedState = d.state,
        p && Lg(i, l, !0),
        i.child
    }
    function Oy(r) {
        var i = r.stateNode;
        i.pendingContext ? Ig(r, i.pendingContext, i.pendingContext !== i.context) : i.context && Ig(r, i.context, !1),
        Ld(r, i.containerInfo)
    }
    function My(r, i, l, d, p) {
        return Pi(),
        Rd(p),
        i.flags |= 256,
        Kt(r, i, l, d),
        i.child
    }
    var nf = {
        dehydrated: null,
        treeContext: null,
        retryLane: 0
    };
    function rf(r) {
        return {
            baseLanes: r,
            cachePool: null,
            transitions: null
        }
    }
    function Iy(r, i, l) {
        var d = i.pendingProps, p = at.current, g = !1, b = (i.flags & 128) !== 0, E;
        if ((E = b) || (E = r !== null && r.memoizedState === null ? !1 : (p & 2) !== 0),
        E ? (g = !0,
        i.flags &= -129) : (r === null || r.memoizedState !== null) && (p |= 1),
        et(at, p & 1),
        r === null)
            return Ad(i),
            r = i.memoizedState,
            r !== null && (r = r.dehydrated,
            r !== null) ? ((i.mode & 1) === 0 ? i.lanes = 1 : r.data === "$!" ? i.lanes = 8 : i.lanes = 1073741824,
            null) : (b = d.children,
            r = d.fallback,
            g ? (d = i.mode,
            g = i.child,
            b = {
                mode: "hidden",
                children: b
            },
            (d & 1) === 0 && g !== null ? (g.childLanes = 0,
            g.pendingProps = b) : g = iu(b, d, 0, null),
            r = Is(r, d, l, null),
            g.return = i,
            r.return = i,
            g.sibling = r,
            i.child = g,
            i.child.memoizedState = rf(l),
            i.memoizedState = nf,
            r) : sf(i, b));
        if (p = r.memoizedState,
        p !== null && (E = p.dehydrated,
        E !== null))
            return ZC(r, i, b, d, E, p, l);
        if (g) {
            g = d.fallback,
            b = i.mode,
            p = r.child,
            E = p.sibling;
            var A = {
                mode: "hidden",
                children: d.children
            };
            return (b & 1) === 0 && i.child !== p ? (d = i.child,
            d.childLanes = 0,
            d.pendingProps = A,
            i.deletions = null) : (d = ts(p, A),
            d.subtreeFlags = p.subtreeFlags & 14680064),
            E !== null ? g = ts(E, g) : (g = Is(g, b, l, null),
            g.flags |= 2),
            g.return = i,
            d.return = i,
            d.sibling = g,
            i.child = d,
            d = g,
            g = i.child,
            b = r.child.memoizedState,
            b = b === null ? rf(l) : {
                baseLanes: b.baseLanes | l,
                cachePool: null,
                transitions: b.transitions
            },
            g.memoizedState = b,
            g.childLanes = r.childLanes & ~l,
            i.memoizedState = nf,
            d
        }
        return g = r.child,
        r = g.sibling,
        d = ts(g, {
            mode: "visible",
            children: d.children
        }),
        (i.mode & 1) === 0 && (d.lanes = l),
        d.return = i,
        d.sibling = null,
        r !== null && (l = i.deletions,
        l === null ? (i.deletions = [r],
        i.flags |= 16) : l.push(r)),
        i.child = d,
        i.memoizedState = null,
        d
    }
    function sf(r, i) {
        return i = iu({
            mode: "visible",
            children: i
        }, r.mode, 0, null),
        i.return = r,
        r.child = i
    }
    function ql(r, i, l, d) {
        return d !== null && Rd(d),
        Ci(i, r.child, null, l),
        r = sf(i, i.pendingProps.children),
        r.flags |= 2,
        i.memoizedState = null,
        r
    }
    function ZC(r, i, l, d, p, g, b) {
        if (l)
            return i.flags & 256 ? (i.flags &= -257,
            d = Xd(Error(n(422))),
            ql(r, i, b, d)) : i.memoizedState !== null ? (i.child = r.child,
            i.flags |= 128,
            null) : (g = d.fallback,
            p = i.mode,
            d = iu({
                mode: "visible",
                children: d.children
            }, p, 0, null),
            g = Is(g, p, b, null),
            g.flags |= 2,
            d.return = i,
            g.return = i,
            d.sibling = g,
            i.child = d,
            (i.mode & 1) !== 0 && Ci(i, r.child, null, b),
            i.child.memoizedState = rf(b),
            i.memoizedState = nf,
            g);
        if ((i.mode & 1) === 0)
            return ql(r, i, b, null);
        if (p.data === "$!") {
            if (d = p.nextSibling && p.nextSibling.dataset,
            d)
                var E = d.dgst;
            return d = E,
            g = Error(n(419)),
            d = Xd(g, d, void 0),
            ql(r, i, b, d)
        }
        if (E = (b & r.childLanes) !== 0,
        tn || E) {
            if (d = At,
            d !== null) {
                switch (b & -b) {
                case 4:
                    p = 2;
                    break;
                case 16:
                    p = 8;
                    break;
                case 64:
                case 128:
                case 256:
                case 512:
                case 1024:
                case 2048:
                case 4096:
                case 8192:
                case 16384:
                case 32768:
                case 65536:
                case 131072:
                case 262144:
                case 524288:
                case 1048576:
                case 2097152:
                case 4194304:
                case 8388608:
                case 16777216:
                case 33554432:
                case 67108864:
                    p = 32;
                    break;
                case 536870912:
                    p = 268435456;
                    break;
                default:
                    p = 0
                }
                p = (p & (d.suspendedLanes | b)) !== 0 ? 0 : p,
                p !== 0 && p !== g.retryLane && (g.retryLane = p,
                wr(r, p),
                Mn(d, r, p, -1))
            }
            return bf(),
            d = Xd(Error(n(421))),
            ql(r, i, b, d)
        }
        return p.data === "$?" ? (i.flags |= 128,
        i.child = r.child,
        i = uE.bind(null, r),
        p._reactRetry = i,
        null) : (r = g.treeContext,
        ln = Wr(p.nextSibling),
        an = i,
        ot = !0,
        Rn = null,
        r !== null && (xn[wn++] = vr,
        xn[wn++] = xr,
        xn[wn++] = _s,
        vr = r.id,
        xr = r.overflow,
        _s = i),
        i = sf(i, d.children),
        i.flags |= 4096,
        i)
    }
    function Fy(r, i, l) {
        r.lanes |= i;
        var d = r.alternate;
        d !== null && (d.lanes |= i),
        Md(r.return, i, l)
    }
    function of(r, i, l, d, p) {
        var g = r.memoizedState;
        g === null ? r.memoizedState = {
            isBackwards: i,
            rendering: null,
            renderingStartTime: 0,
            last: d,
            tail: l,
            tailMode: p
        } : (g.isBackwards = i,
        g.rendering = null,
        g.renderingStartTime = 0,
        g.last = d,
        g.tail = l,
        g.tailMode = p)
    }
    function Ly(r, i, l) {
        var d = i.pendingProps
          , p = d.revealOrder
          , g = d.tail;
        if (Kt(r, i, d.children, l),
        d = at.current,
        (d & 2) !== 0)
            d = d & 1 | 2,
            i.flags |= 128;
        else {
            if (r !== null && (r.flags & 128) !== 0)
                e: for (r = i.child; r !== null; ) {
                    if (r.tag === 13)
                        r.memoizedState !== null && Fy(r, l, i);
                    else if (r.tag === 19)
                        Fy(r, l, i);
                    else if (r.child !== null) {
                        r.child.return = r,
                        r = r.child;
                        continue
                    }
                    if (r === i)
                        break e;
                    for (; r.sibling === null; ) {
                        if (r.return === null || r.return === i)
                            break e;
                        r = r.return
                    }
                    r.sibling.return = r.return,
                    r = r.sibling
                }
            d &= 1
        }
        if (et(at, d),
        (i.mode & 1) === 0)
            i.memoizedState = null;
        else
            switch (p) {
            case "forwards":
                for (l = i.child,
                p = null; l !== null; )
                    r = l.alternate,
                    r !== null && Vl(r) === null && (p = l),
                    l = l.sibling;
                l = p,
                l === null ? (p = i.child,
                i.child = null) : (p = l.sibling,
                l.sibling = null),
                of(i, !1, p, l, g);
                break;
            case "backwards":
                for (l = null,
                p = i.child,
                i.child = null; p !== null; ) {
                    if (r = p.alternate,
                    r !== null && Vl(r) === null) {
                        i.child = p;
                        break
                    }
                    r = p.sibling,
                    p.sibling = l,
                    l = p,
                    p = r
                }
                of(i, !0, l, null, g);
                break;
            case "together":
                of(i, !1, null, null, void 0);
                break;
            default:
                i.memoizedState = null
            }
        return i.child
    }
    function Ql(r, i) {
        (i.mode & 1) === 0 && r !== null && (r.alternate = null,
        i.alternate = null,
        i.flags |= 2)
    }
    function Sr(r, i, l) {
        if (r !== null && (i.dependencies = r.dependencies),
        js |= i.lanes,
        (l & i.childLanes) === 0)
            return null;
        if (r !== null && i.child !== r.child)
            throw Error(n(153));
        if (i.child !== null) {
            for (r = i.child,
            l = ts(r, r.pendingProps),
            i.child = l,
            l.return = i; r.sibling !== null; )
                r = r.sibling,
                l = l.sibling = ts(r, r.pendingProps),
                l.return = i;
            l.sibling = null
        }
        return i.child
    }
    function YC(r, i, l) {
        switch (i.tag) {
        case 3:
            Oy(i),
            Pi();
            break;
        case 5:
            Xg(i);
            break;
        case 1:
            en(i.type) && Nl(i);
            break;
        case 4:
            Ld(i, i.stateNode.containerInfo);
            break;
        case 10:
            var d = i.type._context
              , p = i.memoizedProps.value;
            et(Ml, d._currentValue),
            d._currentValue = p;
            break;
        case 13:
            if (d = i.memoizedState,
            d !== null)
                return d.dehydrated !== null ? (et(at, at.current & 1),
                i.flags |= 128,
                null) : (l & i.child.childLanes) !== 0 ? Iy(r, i, l) : (et(at, at.current & 1),
                r = Sr(r, i, l),
                r !== null ? r.sibling : null);
            et(at, at.current & 1);
            break;
        case 19:
            if (d = (l & i.childLanes) !== 0,
            (r.flags & 128) !== 0) {
                if (d)
                    return Ly(r, i, l);
                i.flags |= 128
            }
            if (p = i.memoizedState,
            p !== null && (p.rendering = null,
            p.tail = null,
            p.lastEffect = null),
            et(at, at.current),
            d)
                break;
            return null;
        case 22:
        case 23:
            return i.lanes = 0,
            Ry(r, i, l)
        }
        return Sr(r, i, l)
    }
    var Vy, af, By, zy;
    Vy = function(r, i) {
        for (var l = i.child; l !== null; ) {
            if (l.tag === 5 || l.tag === 6)
                r.appendChild(l.stateNode);
            else if (l.tag !== 4 && l.child !== null) {
                l.child.return = l,
                l = l.child;
                continue
            }
            if (l === i)
                break;
            for (; l.sibling === null; ) {
                if (l.return === null || l.return === i)
                    return;
                l = l.return
            }
            l.sibling.return = l.return,
            l = l.sibling
        }
    }
    ,
    af = function() {}
    ,
    By = function(r, i, l, d) {
        var p = r.memoizedProps;
        if (p !== d) {
            r = i.stateNode,
            As(Yn.current);
            var g = null;
            switch (l) {
            case "input":
                p = ri(r, p),
                d = ri(r, d),
                g = [];
                break;
            case "select":
                p = J({}, p, {
                    value: void 0
                }),
                d = J({}, d, {
                    value: void 0
                }),
                g = [];
                break;
            case "textarea":
                p = N(r, p),
                d = N(r, d),
                g = [];
                break;
            default:
                typeof p.onClick != "function" && typeof d.onClick == "function" && (r.onclick = El)
            }
            li(l, d);
            var b;
            l = null;
            for (V in p)
                if (!d.hasOwnProperty(V) && p.hasOwnProperty(V) && p[V] != null)
                    if (V === "style") {
                        var E = p[V];
                        for (b in E)
                            E.hasOwnProperty(b) && (l || (l = {}),
                            l[b] = "")
                    } else
                        V !== "dangerouslySetInnerHTML" && V !== "children" && V !== "suppressContentEditableWarning" && V !== "suppressHydrationWarning" && V !== "autoFocus" && (o.hasOwnProperty(V) ? g || (g = []) : (g = g || []).push(V, null));
            for (V in d) {
                var A = d[V];
                if (E = p?.[V],
                d.hasOwnProperty(V) && A !== E && (A != null || E != null))
                    if (V === "style")
                        if (E) {
                            for (b in E)
                                !E.hasOwnProperty(b) || A && A.hasOwnProperty(b) || (l || (l = {}),
                                l[b] = "");
                            for (b in A)
                                A.hasOwnProperty(b) && E[b] !== A[b] && (l || (l = {}),
                                l[b] = A[b])
                        } else
                            l || (g || (g = []),
                            g.push(V, l)),
                            l = A;
                    else
                        V === "dangerouslySetInnerHTML" ? (A = A ? A.__html : void 0,
                        E = E ? E.__html : void 0,
                        A != null && E !== A && (g = g || []).push(V, A)) : V === "children" ? typeof A != "string" && typeof A != "number" || (g = g || []).push(V, "" + A) : V !== "suppressContentEditableWarning" && V !== "suppressHydrationWarning" && (o.hasOwnProperty(V) ? (A != null && V === "onScroll" && tt("scroll", r),
                        g || E === A || (g = [])) : (g = g || []).push(V, A))
            }
            l && (g = g || []).push("style", l);
            var V = g;
            (i.updateQueue = V) && (i.flags |= 4)
        }
    }
    ,
    zy = function(r, i, l, d) {
        l !== d && (i.flags |= 4)
    }
    ;
    function Go(r, i) {
        if (!ot)
            switch (r.tailMode) {
            case "hidden":
                i = r.tail;
                for (var l = null; i !== null; )
                    i.alternate !== null && (l = i),
                    i = i.sibling;
                l === null ? r.tail = null : l.sibling = null;
                break;
            case "collapsed":
                l = r.tail;
                for (var d = null; l !== null; )
                    l.alternate !== null && (d = l),
                    l = l.sibling;
                d === null ? i || r.tail === null ? r.tail = null : r.tail.sibling = null : d.sibling = null
            }
    }
    function Bt(r) {
        var i = r.alternate !== null && r.alternate.child === r.child
          , l = 0
          , d = 0;
        if (i)
            for (var p = r.child; p !== null; )
                l |= p.lanes | p.childLanes,
                d |= p.subtreeFlags & 14680064,
                d |= p.flags & 14680064,
                p.return = r,
                p = p.sibling;
        else
            for (p = r.child; p !== null; )
                l |= p.lanes | p.childLanes,
                d |= p.subtreeFlags,
                d |= p.flags,
                p.return = r,
                p = p.sibling;
        return r.subtreeFlags |= d,
        r.childLanes = l,
        i
    }
    function XC(r, i, l) {
        var d = i.pendingProps;
        switch (kd(i),
        i.tag) {
        case 2:
        case 16:
        case 15:
        case 0:
        case 11:
        case 7:
        case 8:
        case 12:
        case 9:
        case 14:
            return Bt(i),
            null;
        case 1:
            return en(i.type) && kl(),
            Bt(i),
            null;
        case 3:
            return d = i.stateNode,
            ki(),
            nt(Jt),
            nt(Lt),
            zd(),
            d.pendingContext && (d.context = d.pendingContext,
            d.pendingContext = null),
            (r === null || r.child === null) && (Dl(i) ? i.flags |= 4 : r === null || r.memoizedState.isDehydrated && (i.flags & 256) === 0 || (i.flags |= 1024,
            Rn !== null && (vf(Rn),
            Rn = null))),
            af(r, i),
            Bt(i),
            null;
        case 5:
            Vd(i);
            var p = As(Wo.current);
            if (l = i.type,
            r !== null && i.stateNode != null)
                By(r, i, l, d, p),
                r.ref !== i.ref && (i.flags |= 512,
                i.flags |= 2097152);
            else {
                if (!d) {
                    if (i.stateNode === null)
                        throw Error(n(166));
                    return Bt(i),
                    null
                }
                if (r = As(Yn.current),
                Dl(i)) {
                    d = i.stateNode,
                    l = i.type;
                    var g = i.memoizedProps;
                    switch (d[Zn] = i,
                    d[Vo] = g,
                    r = (i.mode & 1) !== 0,
                    l) {
                    case "dialog":
                        tt("cancel", d),
                        tt("close", d);
                        break;
                    case "iframe":
                    case "object":
                    case "embed":
                        tt("load", d);
                        break;
                    case "video":
                    case "audio":
                        for (p = 0; p < Io.length; p++)
                            tt(Io[p], d);
                        break;
                    case "source":
                        tt("error", d);
                        break;
                    case "img":
                    case "image":
                    case "link":
                        tt("error", d),
                        tt("load", d);
                        break;
                    case "details":
                        tt("toggle", d);
                        break;
                    case "input":
                        rl(d, g),
                        tt("invalid", d);
                        break;
                    case "select":
                        d._wrapperState = {
                            wasMultiple: !!g.multiple
                        },
                        tt("invalid", d);
                        break;
                    case "textarea":
                        L(d, g),
                        tt("invalid", d)
                    }
                    li(l, g),
                    p = null;
                    for (var b in g)
                        if (g.hasOwnProperty(b)) {
                            var E = g[b];
                            b === "children" ? typeof E == "string" ? d.textContent !== E && (g.suppressHydrationWarning !== !0 && Cl(d.textContent, E, r),
                            p = ["children", E]) : typeof E == "number" && d.textContent !== "" + E && (g.suppressHydrationWarning !== !0 && Cl(d.textContent, E, r),
                            p = ["children", "" + E]) : o.hasOwnProperty(b) && E != null && b === "onScroll" && tt("scroll", d)
                        }
                    switch (l) {
                    case "input":
                        Kn(d),
                        sl(d, g, !0);
                        break;
                    case "textarea":
                        Kn(d),
                        ue(d);
                        break;
                    case "select":
                    case "option":
                        break;
                    default:
                        typeof g.onClick == "function" && (d.onclick = El)
                    }
                    d = p,
                    i.updateQueue = d,
                    d !== null && (i.flags |= 4)
                } else {
                    b = p.nodeType === 9 ? p : p.ownerDocument,
                    r === "http://www.w3.org/1999/xhtml" && (r = re(l)),
                    r === "http://www.w3.org/1999/xhtml" ? l === "script" ? (r = b.createElement("div"),
                    r.innerHTML = "<script><\/script>",
                    r = r.removeChild(r.firstChild)) : typeof d.is == "string" ? r = b.createElement(l, {
                        is: d.is
                    }) : (r = b.createElement(l),
                    l === "select" && (b = r,
                    d.multiple ? b.multiple = !0 : d.size && (b.size = d.size))) : r = b.createElementNS(r, l),
                    r[Zn] = i,
                    r[Vo] = d,
                    Vy(r, i, !1, !1),
                    i.stateNode = r;
                    e: {
                        switch (b = vo(l, d),
                        l) {
                        case "dialog":
                            tt("cancel", r),
                            tt("close", r),
                            p = d;
                            break;
                        case "iframe":
                        case "object":
                        case "embed":
                            tt("load", r),
                            p = d;
                            break;
                        case "video":
                        case "audio":
                            for (p = 0; p < Io.length; p++)
                                tt(Io[p], r);
                            p = d;
                            break;
                        case "source":
                            tt("error", r),
                            p = d;
                            break;
                        case "img":
                        case "image":
                        case "link":
                            tt("error", r),
                            tt("load", r),
                            p = d;
                            break;
                        case "details":
                            tt("toggle", r),
                            p = d;
                            break;
                        case "input":
                            rl(r, d),
                            p = ri(r, d),
                            tt("invalid", r);
                            break;
                        case "option":
                            p = d;
                            break;
                        case "select":
                            r._wrapperState = {
                                wasMultiple: !!d.multiple
                            },
                            p = J({}, d, {
                                value: void 0
                            }),
                            tt("invalid", r);
                            break;
                        case "textarea":
                            L(r, d),
                            p = N(r, d),
                            tt("invalid", r);
                            break;
                        default:
                            p = d
                        }
                        li(l, p),
                        E = p;
                        for (g in E)
                            if (E.hasOwnProperty(g)) {
                                var A = E[g];
                                g === "style" ? ai(r, A) : g === "dangerouslySetInnerHTML" ? (A = A ? A.__html : void 0,
                                A != null && Be(r, A)) : g === "children" ? typeof A == "string" ? (l !== "textarea" || A !== "") && Je(r, A) : typeof A == "number" && Je(r, "" + A) : g !== "suppressContentEditableWarning" && g !== "suppressHydrationWarning" && g !== "autoFocus" && (o.hasOwnProperty(g) ? A != null && g === "onScroll" && tt("scroll", r) : A != null && j(r, g, A, b))
                            }
                        switch (l) {
                        case "input":
                            Kn(r),
                            sl(r, d, !1);
                            break;
                        case "textarea":
                            Kn(r),
                            ue(r);
                            break;
                        case "option":
                            d.value != null && r.setAttribute("value", "" + ze(d.value));
                            break;
                        case "select":
                            r.multiple = !!d.multiple,
                            g = d.value,
                            g != null ? mr(r, !!d.multiple, g, !1) : d.defaultValue != null && mr(r, !!d.multiple, d.defaultValue, !0);
                            break;
                        default:
                            typeof p.onClick == "function" && (r.onclick = El)
                        }
                        switch (l) {
                        case "button":
                        case "input":
                        case "select":
                        case "textarea":
                            d = !!d.autoFocus;
                            break e;
                        case "img":
                            d = !0;
                            break e;
                        default:
                            d = !1
                        }
                    }
                    d && (i.flags |= 4)
                }
                i.ref !== null && (i.flags |= 512,
                i.flags |= 2097152)
            }
            return Bt(i),
            null;
        case 6:
            if (r && i.stateNode != null)
                zy(r, i, r.memoizedProps, d);
            else {
                if (typeof d != "string" && i.stateNode === null)
                    throw Error(n(166));
                if (l = As(Wo.current),
                As(Yn.current),
                Dl(i)) {
                    if (d = i.stateNode,
                    l = i.memoizedProps,
                    d[Zn] = i,
                    (g = d.nodeValue !== l) && (r = an,
                    r !== null))
                        switch (r.tag) {
                        case 3:
                            Cl(d.nodeValue, l, (r.mode & 1) !== 0);
                            break;
                        case 5:
                            r.memoizedProps.suppressHydrationWarning !== !0 && Cl(d.nodeValue, l, (r.mode & 1) !== 0)
                        }
                    g && (i.flags |= 4)
                } else
                    d = (l.nodeType === 9 ? l : l.ownerDocument).createTextNode(d),
                    d[Zn] = i,
                    i.stateNode = d
            }
            return Bt(i),
            null;
        case 13:
            if (nt(at),
            d = i.memoizedState,
            r === null || r.memoizedState !== null && r.memoizedState.dehydrated !== null) {
                if (ot && ln !== null && (i.mode & 1) !== 0 && (i.flags & 128) === 0)
                    Wg(),
                    Pi(),
                    i.flags |= 98560,
                    g = !1;
                else if (g = Dl(i),
                d !== null && d.dehydrated !== null) {
                    if (r === null) {
                        if (!g)
                            throw Error(n(318));
                        if (g = i.memoizedState,
                        g = g !== null ? g.dehydrated : null,
                        !g)
                            throw Error(n(317));
                        g[Zn] = i
                    } else
                        Pi(),
                        (i.flags & 128) === 0 && (i.memoizedState = null),
                        i.flags |= 4;
                    Bt(i),
                    g = !1
                } else
                    Rn !== null && (vf(Rn),
                    Rn = null),
                    g = !0;
                if (!g)
                    return i.flags & 65536 ? i : null
            }
            return (i.flags & 128) !== 0 ? (i.lanes = l,
            i) : (d = d !== null,
            d !== (r !== null && r.memoizedState !== null) && d && (i.child.flags |= 8192,
            (i.mode & 1) !== 0 && (r === null || (at.current & 1) !== 0 ? Ct === 0 && (Ct = 3) : bf())),
            i.updateQueue !== null && (i.flags |= 4),
            Bt(i),
            null);
        case 4:
            return ki(),
            af(r, i),
            r === null && Fo(i.stateNode.containerInfo),
            Bt(i),
            null;
        case 10:
            return Od(i.type._context),
            Bt(i),
            null;
        case 17:
            return en(i.type) && kl(),
            Bt(i),
            null;
        case 19:
            if (nt(at),
            g = i.memoizedState,
            g === null)
                return Bt(i),
                null;
            if (d = (i.flags & 128) !== 0,
            b = g.rendering,
            b === null)
                if (d)
                    Go(g, !1);
                else {
                    if (Ct !== 0 || r !== null && (r.flags & 128) !== 0)
                        for (r = i.child; r !== null; ) {
                            if (b = Vl(r),
                            b !== null) {
                                for (i.flags |= 128,
                                Go(g, !1),
                                d = b.updateQueue,
                                d !== null && (i.updateQueue = d,
                                i.flags |= 4),
                                i.subtreeFlags = 0,
                                d = l,
                                l = i.child; l !== null; )
                                    g = l,
                                    r = d,
                                    g.flags &= 14680066,
                                    b = g.alternate,
                                    b === null ? (g.childLanes = 0,
                                    g.lanes = r,
                                    g.child = null,
                                    g.subtreeFlags = 0,
                                    g.memoizedProps = null,
                                    g.memoizedState = null,
                                    g.updateQueue = null,
                                    g.dependencies = null,
                                    g.stateNode = null) : (g.childLanes = b.childLanes,
                                    g.lanes = b.lanes,
                                    g.child = b.child,
                                    g.subtreeFlags = 0,
                                    g.deletions = null,
                                    g.memoizedProps = b.memoizedProps,
                                    g.memoizedState = b.memoizedState,
                                    g.updateQueue = b.updateQueue,
                                    g.type = b.type,
                                    r = b.dependencies,
                                    g.dependencies = r === null ? null : {
                                        lanes: r.lanes,
                                        firstContext: r.firstContext
                                    }),
                                    l = l.sibling;
                                return et(at, at.current & 1 | 2),
                                i.child
                            }
                            r = r.sibling
                        }
                    g.tail !== null && mt() > ji && (i.flags |= 128,
                    d = !0,
                    Go(g, !1),
                    i.lanes = 4194304)
                }
            else {
                if (!d)
                    if (r = Vl(b),
                    r !== null) {
                        if (i.flags |= 128,
                        d = !0,
                        l = r.updateQueue,
                        l !== null && (i.updateQueue = l,
                        i.flags |= 4),
                        Go(g, !0),
                        g.tail === null && g.tailMode === "hidden" && !b.alternate && !ot)
                            return Bt(i),
                            null
                    } else
                        2 * mt() - g.renderingStartTime > ji && l !== 1073741824 && (i.flags |= 128,
                        d = !0,
                        Go(g, !1),
                        i.lanes = 4194304);
                g.isBackwards ? (b.sibling = i.child,
                i.child = b) : (l = g.last,
                l !== null ? l.sibling = b : i.child = b,
                g.last = b)
            }
            return g.tail !== null ? (i = g.tail,
            g.rendering = i,
            g.tail = i.sibling,
            g.renderingStartTime = mt(),
            i.sibling = null,
            l = at.current,
            et(at, d ? l & 1 | 2 : l & 1),
            i) : (Bt(i),
            null);
        case 22:
        case 23:
            return wf(),
            d = i.memoizedState !== null,
            r !== null && r.memoizedState !== null !== d && (i.flags |= 8192),
            d && (i.mode & 1) !== 0 ? (un & 1073741824) !== 0 && (Bt(i),
            i.subtreeFlags & 6 && (i.flags |= 8192)) : Bt(i),
            null;
        case 24:
            return null;
        case 25:
            return null
        }
        throw Error(n(156, i.tag))
    }
    function JC(r, i) {
        switch (kd(i),
        i.tag) {
        case 1:
            return en(i.type) && kl(),
            r = i.flags,
            r & 65536 ? (i.flags = r & -65537 | 128,
            i) : null;
        case 3:
            return ki(),
            nt(Jt),
            nt(Lt),
            zd(),
            r = i.flags,
            (r & 65536) !== 0 && (r & 128) === 0 ? (i.flags = r & -65537 | 128,
            i) : null;
        case 5:
            return Vd(i),
            null;
        case 13:
            if (nt(at),
            r = i.memoizedState,
            r !== null && r.dehydrated !== null) {
                if (i.alternate === null)
                    throw Error(n(340));
                Pi()
            }
            return r = i.flags,
            r & 65536 ? (i.flags = r & -65537 | 128,
            i) : null;
        case 19:
            return nt(at),
            null;
        case 4:
            return ki(),
            null;
        case 10:
            return Od(i.type._context),
            null;
        case 22:
        case 23:
            return wf(),
            null;
        case 24:
            return null;
        default:
            return null
        }
    }
    var Kl = !1
      , zt = !1
      , eE = typeof WeakSet == "function" ? WeakSet : Set
      , me = null;
    function Ai(r, i) {
        var l = r.ref;
        if (l !== null)
            if (typeof l == "function")
                try {
                    l(null)
                } catch (d) {
                    ht(r, i, d)
                }
            else
                l.current = null
    }
    function lf(r, i, l) {
        try {
            l()
        } catch (d) {
            ht(r, i, d)
        }
    }
    var Uy = !1;
    function tE(r, i) {
        if (xd = pl,
        r = wg(),
        dd(r)) {
            if ("selectionStart"in r)
                var l = {
                    start: r.selectionStart,
                    end: r.selectionEnd
                };
            else
                e: {
                    l = (l = r.ownerDocument) && l.defaultView || window;
                    var d = l.getSelection && l.getSelection();
                    if (d && d.rangeCount !== 0) {
                        l = d.anchorNode;
                        var p = d.anchorOffset
                          , g = d.focusNode;
                        d = d.focusOffset;
                        try {
                            l.nodeType,
                            g.nodeType
                        } catch {
                            l = null;
                            break e
                        }
                        var b = 0
                          , E = -1
                          , A = -1
                          , V = 0
                          , K = 0
                          , Z = r
                          , Q = null;
                        t: for (; ; ) {
                            for (var de; Z !== l || p !== 0 && Z.nodeType !== 3 || (E = b + p),
                            Z !== g || d !== 0 && Z.nodeType !== 3 || (A = b + d),
                            Z.nodeType === 3 && (b += Z.nodeValue.length),
                            (de = Z.firstChild) !== null; )
                                Q = Z,
                                Z = de;
                            for (; ; ) {
                                if (Z === r)
                                    break t;
                                if (Q === l && ++V === p && (E = b),
                                Q === g && ++K === d && (A = b),
                                (de = Z.nextSibling) !== null)
                                    break;
                                Z = Q,
                                Q = Z.parentNode
                            }
                            Z = de
                        }
                        l = E === -1 || A === -1 ? null : {
                            start: E,
                            end: A
                        }
                    } else
                        l = null
                }
            l = l || {
                start: 0,
                end: 0
            }
        } else
            l = null;
        for (wd = {
            focusedElem: r,
            selectionRange: l
        },
        pl = !1,
        me = i; me !== null; )
            if (i = me,
            r = i.child,
            (i.subtreeFlags & 1028) !== 0 && r !== null)
                r.return = i,
                me = r;
            else
                for (; me !== null; ) {
                    i = me;
                    try {
                        var ge = i.alternate;
                        if ((i.flags & 1024) !== 0)
                            switch (i.tag) {
                            case 0:
                            case 11:
                            case 15:
                                break;
                            case 1:
                                if (ge !== null) {
                                    var ye = ge.memoizedProps
                                      , gt = ge.memoizedState
                                      , I = i.stateNode
                                      , R = I.getSnapshotBeforeUpdate(i.elementType === i.type ? ye : jn(i.type, ye), gt);
                                    I.__reactInternalSnapshotBeforeUpdate = R
                                }
                                break;
                            case 3:
                                var F = i.stateNode.containerInfo;
                                F.nodeType === 1 ? F.textContent = "" : F.nodeType === 9 && F.documentElement && F.removeChild(F.documentElement);
                                break;
                            case 5:
                            case 6:
                            case 4:
                            case 17:
                                break;
                            default:
                                throw Error(n(163))
                            }
                    } catch (te) {
                        ht(i, i.return, te)
                    }
                    if (r = i.sibling,
                    r !== null) {
                        r.return = i.return,
                        me = r;
                        break
                    }
                    me = i.return
                }
        return ge = Uy,
        Uy = !1,
        ge
    }
    function Zo(r, i, l) {
        var d = i.updateQueue;
        if (d = d !== null ? d.lastEffect : null,
        d !== null) {
            var p = d = d.next;
            do {
                if ((p.tag & r) === r) {
                    var g = p.destroy;
                    p.destroy = void 0,
                    g !== void 0 && lf(i, l, g)
                }
                p = p.next
            } while (p !== d)
        }
    }
    function Gl(r, i) {
        if (i = i.updateQueue,
        i = i !== null ? i.lastEffect : null,
        i !== null) {
            var l = i = i.next;
            do {
                if ((l.tag & r) === r) {
                    var d = l.create;
                    l.destroy = d()
                }
                l = l.next
            } while (l !== i)
        }
    }
    function uf(r) {
        var i = r.ref;
        if (i !== null) {
            var l = r.stateNode;
            r.tag,
            r = l,
            typeof i == "function" ? i(r) : i.current = r
        }
    }
    function $y(r) {
        var i = r.alternate;
        i !== null && (r.alternate = null,
        $y(i)),
        r.child = null,
        r.deletions = null,
        r.sibling = null,
        r.tag === 5 && (i = r.stateNode,
        i !== null && (delete i[Zn],
        delete i[Vo],
        delete i[Pd],
        delete i[FC],
        delete i[LC])),
        r.stateNode = null,
        r.return = null,
        r.dependencies = null,
        r.memoizedProps = null,
        r.memoizedState = null,
        r.pendingProps = null,
        r.stateNode = null,
        r.updateQueue = null
    }
    function Wy(r) {
        return r.tag === 5 || r.tag === 3 || r.tag === 4
    }
    function Hy(r) {
        e: for (; ; ) {
            for (; r.sibling === null; ) {
                if (r.return === null || Wy(r.return))
                    return null;
                r = r.return
            }
            for (r.sibling.return = r.return,
            r = r.sibling; r.tag !== 5 && r.tag !== 6 && r.tag !== 18; ) {
                if (r.flags & 2 || r.child === null || r.tag === 4)
                    continue e;
                r.child.return = r,
                r = r.child
            }
            if (!(r.flags & 2))
                return r.stateNode
        }
    }
    function cf(r, i, l) {
        var d = r.tag;
        if (d === 5 || d === 6)
            r = r.stateNode,
            i ? l.nodeType === 8 ? l.parentNode.insertBefore(r, i) : l.insertBefore(r, i) : (l.nodeType === 8 ? (i = l.parentNode,
            i.insertBefore(r, l)) : (i = l,
            i.appendChild(r)),
            l = l._reactRootContainer,
            l != null || i.onclick !== null || (i.onclick = El));
        else if (d !== 4 && (r = r.child,
        r !== null))
            for (cf(r, i, l),
            r = r.sibling; r !== null; )
                cf(r, i, l),
                r = r.sibling
    }
    function df(r, i, l) {
        var d = r.tag;
        if (d === 5 || d === 6)
            r = r.stateNode,
            i ? l.insertBefore(r, i) : l.appendChild(r);
        else if (d !== 4 && (r = r.child,
        r !== null))
            for (df(r, i, l),
            r = r.sibling; r !== null; )
                df(r, i, l),
                r = r.sibling
    }
    var Ot = null
      , Dn = !1;
    function Zr(r, i, l) {
        for (l = l.child; l !== null; )
            qy(r, i, l),
            l = l.sibling
    }
    function qy(r, i, l) {
        if (Gn && typeof Gn.onCommitFiberUnmount == "function")
            try {
                Gn.onCommitFiberUnmount(ll, l)
            } catch {}
        switch (l.tag) {
        case 5:
            zt || Ai(l, i);
        case 6:
            var d = Ot
              , p = Dn;
            Ot = null,
            Zr(r, i, l),
            Ot = d,
            Dn = p,
            Ot !== null && (Dn ? (r = Ot,
            l = l.stateNode,
            r.nodeType === 8 ? r.parentNode.removeChild(l) : r.removeChild(l)) : Ot.removeChild(l.stateNode));
            break;
        case 18:
            Ot !== null && (Dn ? (r = Ot,
            l = l.stateNode,
            r.nodeType === 8 ? Td(r.parentNode, l) : r.nodeType === 1 && Td(r, l),
            ko(r)) : Td(Ot, l.stateNode));
            break;
        case 4:
            d = Ot,
            p = Dn,
            Ot = l.stateNode.containerInfo,
            Dn = !0,
            Zr(r, i, l),
            Ot = d,
            Dn = p;
            break;
        case 0:
        case 11:
        case 14:
        case 15:
            if (!zt && (d = l.updateQueue,
            d !== null && (d = d.lastEffect,
            d !== null))) {
                p = d = d.next;
                do {
                    var g = p
                      , b = g.destroy;
                    g = g.tag,
                    b !== void 0 && ((g & 2) !== 0 || (g & 4) !== 0) && lf(l, i, b),
                    p = p.next
                } while (p !== d)
            }
            Zr(r, i, l);
            break;
        case 1:
            if (!zt && (Ai(l, i),
            d = l.stateNode,
            typeof d.componentWillUnmount == "function"))
                try {
                    d.props = l.memoizedProps,
                    d.state = l.memoizedState,
                    d.componentWillUnmount()
                } catch (E) {
                    ht(l, i, E)
                }
            Zr(r, i, l);
            break;
        case 21:
            Zr(r, i, l);
            break;
        case 22:
            l.mode & 1 ? (zt = (d = zt) || l.memoizedState !== null,
            Zr(r, i, l),
            zt = d) : Zr(r, i, l);
            break;
        default:
            Zr(r, i, l)
        }
    }
    function Qy(r) {
        var i = r.updateQueue;
        if (i !== null) {
            r.updateQueue = null;
            var l = r.stateNode;
            l === null && (l = r.stateNode = new eE),
            i.forEach(function(d) {
                var p = cE.bind(null, r, d);
                l.has(d) || (l.add(d),
                d.then(p, p))
            })
        }
    }
    function On(r, i) {
        var l = i.deletions;
        if (l !== null)
            for (var d = 0; d < l.length; d++) {
                var p = l[d];
                try {
                    var g = r
                      , b = i
                      , E = b;
                    e: for (; E !== null; ) {
                        switch (E.tag) {
                        case 5:
                            Ot = E.stateNode,
                            Dn = !1;
                            break e;
                        case 3:
                            Ot = E.stateNode.containerInfo,
                            Dn = !0;
                            break e;
                        case 4:
                            Ot = E.stateNode.containerInfo,
                            Dn = !0;
                            break e
                        }
                        E = E.return
                    }
                    if (Ot === null)
                        throw Error(n(160));
                    qy(g, b, p),
                    Ot = null,
                    Dn = !1;
                    var A = p.alternate;
                    A !== null && (A.return = null),
                    p.return = null
                } catch (V) {
                    ht(p, i, V)
                }
            }
        if (i.subtreeFlags & 12854)
            for (i = i.child; i !== null; )
                Ky(i, r),
                i = i.sibling
    }
    function Ky(r, i) {
        var l = r.alternate
          , d = r.flags;
        switch (r.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
            if (On(i, r),
            Jn(r),
            d & 4) {
                try {
                    Zo(3, r, r.return),
                    Gl(3, r)
                } catch (ye) {
                    ht(r, r.return, ye)
                }
                try {
                    Zo(5, r, r.return)
                } catch (ye) {
                    ht(r, r.return, ye)
                }
            }
            break;
        case 1:
            On(i, r),
            Jn(r),
            d & 512 && l !== null && Ai(l, l.return);
            break;
        case 5:
            if (On(i, r),
            Jn(r),
            d & 512 && l !== null && Ai(l, l.return),
            r.flags & 32) {
                var p = r.stateNode;
                try {
                    Je(p, "")
                } catch (ye) {
                    ht(r, r.return, ye)
                }
            }
            if (d & 4 && (p = r.stateNode,
            p != null)) {
                var g = r.memoizedProps
                  , b = l !== null ? l.memoizedProps : g
                  , E = r.type
                  , A = r.updateQueue;
                if (r.updateQueue = null,
                A !== null)
                    try {
                        E === "input" && g.type === "radio" && g.name != null && go(p, g),
                        vo(E, b);
                        var V = vo(E, g);
                        for (b = 0; b < A.length; b += 2) {
                            var K = A[b]
                              , Z = A[b + 1];
                            K === "style" ? ai(p, Z) : K === "dangerouslySetInnerHTML" ? Be(p, Z) : K === "children" ? Je(p, Z) : j(p, K, Z, V)
                        }
                        switch (E) {
                        case "input":
                            si(p, g);
                            break;
                        case "textarea":
                            $(p, g);
                            break;
                        case "select":
                            var Q = p._wrapperState.wasMultiple;
                            p._wrapperState.wasMultiple = !!g.multiple;
                            var de = g.value;
                            de != null ? mr(p, !!g.multiple, de, !1) : Q !== !!g.multiple && (g.defaultValue != null ? mr(p, !!g.multiple, g.defaultValue, !0) : mr(p, !!g.multiple, g.multiple ? [] : "", !1))
                        }
                        p[Vo] = g
                    } catch (ye) {
                        ht(r, r.return, ye)
                    }
            }
            break;
        case 6:
            if (On(i, r),
            Jn(r),
            d & 4) {
                if (r.stateNode === null)
                    throw Error(n(162));
                p = r.stateNode,
                g = r.memoizedProps;
                try {
                    p.nodeValue = g
                } catch (ye) {
                    ht(r, r.return, ye)
                }
            }
            break;
        case 3:
            if (On(i, r),
            Jn(r),
            d & 4 && l !== null && l.memoizedState.isDehydrated)
                try {
                    ko(i.containerInfo)
                } catch (ye) {
                    ht(r, r.return, ye)
                }
            break;
        case 4:
            On(i, r),
            Jn(r);
            break;
        case 13:
            On(i, r),
            Jn(r),
            p = r.child,
            p.flags & 8192 && (g = p.memoizedState !== null,
            p.stateNode.isHidden = g,
            !g || p.alternate !== null && p.alternate.memoizedState !== null || (pf = mt())),
            d & 4 && Qy(r);
            break;
        case 22:
            if (K = l !== null && l.memoizedState !== null,
            r.mode & 1 ? (zt = (V = zt) || K,
            On(i, r),
            zt = V) : On(i, r),
            Jn(r),
            d & 8192) {
                if (V = r.memoizedState !== null,
                (r.stateNode.isHidden = V) && !K && (r.mode & 1) !== 0)
                    for (me = r,
                    K = r.child; K !== null; ) {
                        for (Z = me = K; me !== null; ) {
                            switch (Q = me,
                            de = Q.child,
                            Q.tag) {
                            case 0:
                            case 11:
                            case 14:
                            case 15:
                                Zo(4, Q, Q.return);
                                break;
                            case 1:
                                Ai(Q, Q.return);
                                var ge = Q.stateNode;
                                if (typeof ge.componentWillUnmount == "function") {
                                    d = Q,
                                    l = Q.return;
                                    try {
                                        i = d,
                                        ge.props = i.memoizedProps,
                                        ge.state = i.memoizedState,
                                        ge.componentWillUnmount()
                                    } catch (ye) {
                                        ht(d, l, ye)
                                    }
                                }
                                break;
                            case 5:
                                Ai(Q, Q.return);
                                break;
                            case 22:
                                if (Q.memoizedState !== null) {
                                    Yy(Z);
                                    continue
                                }
                            }
                            de !== null ? (de.return = Q,
                            me = de) : Yy(Z)
                        }
                        K = K.sibling
                    }
                e: for (K = null,
                Z = r; ; ) {
                    if (Z.tag === 5) {
                        if (K === null) {
                            K = Z;
                            try {
                                p = Z.stateNode,
                                V ? (g = p.style,
                                typeof g.setProperty == "function" ? g.setProperty("display", "none", "important") : g.display = "none") : (E = Z.stateNode,
                                A = Z.memoizedProps.style,
                                b = A != null && A.hasOwnProperty("display") ? A.display : null,
                                E.style.display = oi("display", b))
                            } catch (ye) {
                                ht(r, r.return, ye)
                            }
                        }
                    } else if (Z.tag === 6) {
                        if (K === null)
                            try {
                                Z.stateNode.nodeValue = V ? "" : Z.memoizedProps
                            } catch (ye) {
                                ht(r, r.return, ye)
                            }
                    } else if ((Z.tag !== 22 && Z.tag !== 23 || Z.memoizedState === null || Z === r) && Z.child !== null) {
                        Z.child.return = Z,
                        Z = Z.child;
                        continue
                    }
                    if (Z === r)
                        break e;
                    for (; Z.sibling === null; ) {
                        if (Z.return === null || Z.return === r)
                            break e;
                        K === Z && (K = null),
                        Z = Z.return
                    }
                    K === Z && (K = null),
                    Z.sibling.return = Z.return,
                    Z = Z.sibling
                }
            }
            break;
        case 19:
            On(i, r),
            Jn(r),
            d & 4 && Qy(r);
            break;
        case 21:
            break;
        default:
            On(i, r),
            Jn(r)
        }
    }
    function Jn(r) {
        var i = r.flags;
        if (i & 2) {
            try {
                e: {
                    for (var l = r.return; l !== null; ) {
                        if (Wy(l)) {
                            var d = l;
                            break e
                        }
                        l = l.return
                    }
                    throw Error(n(160))
                }
                switch (d.tag) {
                case 5:
                    var p = d.stateNode;
                    d.flags & 32 && (Je(p, ""),
                    d.flags &= -33);
                    var g = Hy(r);
                    df(r, g, p);
                    break;
                case 3:
                case 4:
                    var b = d.stateNode.containerInfo
                      , E = Hy(r);
                    cf(r, E, b);
                    break;
                default:
                    throw Error(n(161))
                }
            } catch (A) {
                ht(r, r.return, A)
            }
            r.flags &= -3
        }
        i & 4096 && (r.flags &= -4097)
    }
    function nE(r, i, l) {
        me = r,
        Gy(r)
    }
    function Gy(r, i, l) {
        for (var d = (r.mode & 1) !== 0; me !== null; ) {
            var p = me
              , g = p.child;
            if (p.tag === 22 && d) {
                var b = p.memoizedState !== null || Kl;
                if (!b) {
                    var E = p.alternate
                      , A = E !== null && E.memoizedState !== null || zt;
                    E = Kl;
                    var V = zt;
                    if (Kl = b,
                    (zt = A) && !V)
                        for (me = p; me !== null; )
                            b = me,
                            A = b.child,
                            b.tag === 22 && b.memoizedState !== null ? Xy(p) : A !== null ? (A.return = b,
                            me = A) : Xy(p);
                    for (; g !== null; )
                        me = g,
                        Gy(g),
                        g = g.sibling;
                    me = p,
                    Kl = E,
                    zt = V
                }
                Zy(r)
            } else
                (p.subtreeFlags & 8772) !== 0 && g !== null ? (g.return = p,
                me = g) : Zy(r)
        }
    }
    function Zy(r) {
        for (; me !== null; ) {
            var i = me;
            if ((i.flags & 8772) !== 0) {
                var l = i.alternate;
                try {
                    if ((i.flags & 8772) !== 0)
                        switch (i.tag) {
                        case 0:
                        case 11:
                        case 15:
                            zt || Gl(5, i);
                            break;
                        case 1:
                            var d = i.stateNode;
                            if (i.flags & 4 && !zt)
                                if (l === null)
                                    d.componentDidMount();
                                else {
                                    var p = i.elementType === i.type ? l.memoizedProps : jn(i.type, l.memoizedProps);
                                    d.componentDidUpdate(p, l.memoizedState, d.__reactInternalSnapshotBeforeUpdate)
                                }
                            var g = i.updateQueue;
                            g !== null && Yg(i, g, d);
                            break;
                        case 3:
                            var b = i.updateQueue;
                            if (b !== null) {
                                if (l = null,
                                i.child !== null)
                                    switch (i.child.tag) {
                                    case 5:
                                        l = i.child.stateNode;
                                        break;
                                    case 1:
                                        l = i.child.stateNode
                                    }
                                Yg(i, b, l)
                            }
                            break;
                        case 5:
                            var E = i.stateNode;
                            if (l === null && i.flags & 4) {
                                l = E;
                                var A = i.memoizedProps;
                                switch (i.type) {
                                case "button":
                                case "input":
                                case "select":
                                case "textarea":
                                    A.autoFocus && l.focus();
                                    break;
                                case "img":
                                    A.src && (l.src = A.src)
                                }
                            }
                            break;
                        case 6:
                            break;
                        case 4:
                            break;
                        case 12:
                            break;
                        case 13:
                            if (i.memoizedState === null) {
                                var V = i.alternate;
                                if (V !== null) {
                                    var K = V.memoizedState;
                                    if (K !== null) {
                                        var Z = K.dehydrated;
                                        Z !== null && ko(Z)
                                    }
                                }
                            }
                            break;
                        case 19:
                        case 17:
                        case 21:
                        case 22:
                        case 23:
                        case 25:
                            break;
                        default:
                            throw Error(n(163))
                        }
                    zt || i.flags & 512 && uf(i)
                } catch (Q) {
                    ht(i, i.return, Q)
                }
            }
            if (i === r) {
                me = null;
                break
            }
            if (l = i.sibling,
            l !== null) {
                l.return = i.return,
                me = l;
                break
            }
            me = i.return
        }
    }
    function Yy(r) {
        for (; me !== null; ) {
            var i = me;
            if (i === r) {
                me = null;
                break
            }
            var l = i.sibling;
            if (l !== null) {
                l.return = i.return,
                me = l;
                break
            }
            me = i.return
        }
    }
    function Xy(r) {
        for (; me !== null; ) {
            var i = me;
            try {
                switch (i.tag) {
                case 0:
                case 11:
                case 15:
                    var l = i.return;
                    try {
                        Gl(4, i)
                    } catch (A) {
                        ht(i, l, A)
                    }
                    break;
                case 1:
                    var d = i.stateNode;
                    if (typeof d.componentDidMount == "function") {
                        var p = i.return;
                        try {
                            d.componentDidMount()
                        } catch (A) {
                            ht(i, p, A)
                        }
                    }
                    var g = i.return;
                    try {
                        uf(i)
                    } catch (A) {
                        ht(i, g, A)
                    }
                    break;
                case 5:
                    var b = i.return;
                    try {
                        uf(i)
                    } catch (A) {
                        ht(i, b, A)
                    }
                }
            } catch (A) {
                ht(i, i.return, A)
            }
            if (i === r) {
                me = null;
                break
            }
            var E = i.sibling;
            if (E !== null) {
                E.return = i.return,
                me = E;
                break
            }
            me = i.return
        }
    }
    var rE = Math.ceil
      , Zl = M.ReactCurrentDispatcher
      , ff = M.ReactCurrentOwner
      , Tn = M.ReactCurrentBatchConfig
      , $e = 0
      , At = null
      , bt = null
      , Mt = 0
      , un = 0
      , Ri = Hr(0)
      , Ct = 0
      , Yo = null
      , js = 0
      , Yl = 0
      , hf = 0
      , Xo = null
      , nn = null
      , pf = 0
      , ji = 1 / 0
      , Tr = null
      , Xl = !1
      , mf = null
      , Yr = null
      , Jl = !1
      , Xr = null
      , eu = 0
      , Jo = 0
      , gf = null
      , tu = -1
      , nu = 0;
    function Gt() {
        return ($e & 6) !== 0 ? mt() : tu !== -1 ? tu : tu = mt()
    }
    function Jr(r) {
        return (r.mode & 1) === 0 ? 1 : ($e & 2) !== 0 && Mt !== 0 ? Mt & -Mt : BC.transition !== null ? (nu === 0 && (nu = Hm()),
        nu) : (r = Ze,
        r !== 0 || (r = window.event,
        r = r === void 0 ? 16 : eg(r.type)),
        r)
    }
    function Mn(r, i, l, d) {
        if (50 < Jo)
            throw Jo = 0,
            gf = null,
            Error(n(185));
        To(r, l, d),
        (($e & 2) === 0 || r !== At) && (r === At && (($e & 2) === 0 && (Yl |= l),
        Ct === 4 && es(r, Mt)),
        rn(r, d),
        l === 1 && $e === 0 && (i.mode & 1) === 0 && (ji = mt() + 500,
        Al && Qr()))
    }
    function rn(r, i) {
        var l = r.callbackNode;
        BP(r, i);
        var d = dl(r, r === At ? Mt : 0);
        if (d === 0)
            l !== null && Um(l),
            r.callbackNode = null,
            r.callbackPriority = 0;
        else if (i = d & -d,
        r.callbackPriority !== i) {
            if (l != null && Um(l),
            i === 1)
                r.tag === 0 ? VC(ev.bind(null, r)) : Vg(ev.bind(null, r)),
                MC(function() {
                    ($e & 6) === 0 && Qr()
                }),
                l = null;
            else {
                switch (qm(d)) {
                case 1:
                    l = Kc;
                    break;
                case 4:
                    l = $m;
                    break;
                case 16:
                    l = al;
                    break;
                case 536870912:
                    l = Wm;
                    break;
                default:
                    l = al
                }
                l = lv(l, Jy.bind(null, r))
            }
            r.callbackPriority = i,
            r.callbackNode = l
        }
    }
    function Jy(r, i) {
        if (tu = -1,
        nu = 0,
        ($e & 6) !== 0)
            throw Error(n(327));
        var l = r.callbackNode;
        if (Di() && r.callbackNode !== l)
            return null;
        var d = dl(r, r === At ? Mt : 0);
        if (d === 0)
            return null;
        if ((d & 30) !== 0 || (d & r.expiredLanes) !== 0 || i)
            i = ru(r, d);
        else {
            i = d;
            var p = $e;
            $e |= 2;
            var g = nv();
            (At !== r || Mt !== i) && (Tr = null,
            ji = mt() + 500,
            Os(r, i));
            do
                try {
                    oE();
                    break
                } catch (E) {
                    tv(r, E)
                }
            while (!0);
            Dd(),
            Zl.current = g,
            $e = p,
            bt !== null ? i = 0 : (At = null,
            Mt = 0,
            i = Ct)
        }
        if (i !== 0) {
            if (i === 2 && (p = Gc(r),
            p !== 0 && (d = p,
            i = yf(r, p))),
            i === 1)
                throw l = Yo,
                Os(r, 0),
                es(r, d),
                rn(r, mt()),
                l;
            if (i === 6)
                es(r, d);
            else {
                if (p = r.current.alternate,
                (d & 30) === 0 && !sE(p) && (i = ru(r, d),
                i === 2 && (g = Gc(r),
                g !== 0 && (d = g,
                i = yf(r, g))),
                i === 1))
                    throw l = Yo,
                    Os(r, 0),
                    es(r, d),
                    rn(r, mt()),
                    l;
                switch (r.finishedWork = p,
                r.finishedLanes = d,
                i) {
                case 0:
                case 1:
                    throw Error(n(345));
                case 2:
                    Ms(r, nn, Tr);
                    break;
                case 3:
                    if (es(r, d),
                    (d & 130023424) === d && (i = pf + 500 - mt(),
                    10 < i)) {
                        if (dl(r, 0) !== 0)
                            break;
                        if (p = r.suspendedLanes,
                        (p & d) !== d) {
                            Gt(),
                            r.pingedLanes |= r.suspendedLanes & p;
                            break
                        }
                        r.timeoutHandle = Sd(Ms.bind(null, r, nn, Tr), i);
                        break
                    }
                    Ms(r, nn, Tr);
                    break;
                case 4:
                    if (es(r, d),
                    (d & 4194240) === d)
                        break;
                    for (i = r.eventTimes,
                    p = -1; 0 < d; ) {
                        var b = 31 - Nn(d);
                        g = 1 << b,
                        b = i[b],
                        b > p && (p = b),
                        d &= ~g
                    }
                    if (d = p,
                    d = mt() - d,
                    d = (120 > d ? 120 : 480 > d ? 480 : 1080 > d ? 1080 : 1920 > d ? 1920 : 3e3 > d ? 3e3 : 4320 > d ? 4320 : 1960 * rE(d / 1960)) - d,
                    10 < d) {
                        r.timeoutHandle = Sd(Ms.bind(null, r, nn, Tr), d);
                        break
                    }
                    Ms(r, nn, Tr);
                    break;
                case 5:
                    Ms(r, nn, Tr);
                    break;
                default:
                    throw Error(n(329))
                }
            }
        }
        return rn(r, mt()),
        r.callbackNode === l ? Jy.bind(null, r) : null
    }
    function yf(r, i) {
        var l = Xo;
        return r.current.memoizedState.isDehydrated && (Os(r, i).flags |= 256),
        r = ru(r, i),
        r !== 2 && (i = nn,
        nn = l,
        i !== null && vf(i)),
        r
    }
    function vf(r) {
        nn === null ? nn = r : nn.push.apply(nn, r)
    }
    function sE(r) {
        for (var i = r; ; ) {
            if (i.flags & 16384) {
                var l = i.updateQueue;
                if (l !== null && (l = l.stores,
                l !== null))
                    for (var d = 0; d < l.length; d++) {
                        var p = l[d]
                          , g = p.getSnapshot;
                        p = p.value;
                        try {
                            if (!An(g(), p))
                                return !1
                        } catch {
                            return !1
                        }
                    }
            }
            if (l = i.child,
            i.subtreeFlags & 16384 && l !== null)
                l.return = i,
                i = l;
            else {
                if (i === r)
                    break;
                for (; i.sibling === null; ) {
                    if (i.return === null || i.return === r)
                        return !0;
                    i = i.return
                }
                i.sibling.return = i.return,
                i = i.sibling
            }
        }
        return !0
    }
    function es(r, i) {
        for (i &= ~hf,
        i &= ~Yl,
        r.suspendedLanes |= i,
        r.pingedLanes &= ~i,
        r = r.expirationTimes; 0 < i; ) {
            var l = 31 - Nn(i)
              , d = 1 << l;
            r[l] = -1,
            i &= ~d
        }
    }
    function ev(r) {
        if (($e & 6) !== 0)
            throw Error(n(327));
        Di();
        var i = dl(r, 0);
        if ((i & 1) === 0)
            return rn(r, mt()),
            null;
        var l = ru(r, i);
        if (r.tag !== 0 && l === 2) {
            var d = Gc(r);
            d !== 0 && (i = d,
            l = yf(r, d))
        }
        if (l === 1)
            throw l = Yo,
            Os(r, 0),
            es(r, i),
            rn(r, mt()),
            l;
        if (l === 6)
            throw Error(n(345));
        return r.finishedWork = r.current.alternate,
        r.finishedLanes = i,
        Ms(r, nn, Tr),
        rn(r, mt()),
        null
    }
    function xf(r, i) {
        var l = $e;
        $e |= 1;
        try {
            return r(i)
        } finally {
            $e = l,
            $e === 0 && (ji = mt() + 500,
            Al && Qr())
        }
    }
    function Ds(r) {
        Xr !== null && Xr.tag === 0 && ($e & 6) === 0 && Di();
        var i = $e;
        $e |= 1;
        var l = Tn.transition
          , d = Ze;
        try {
            if (Tn.transition = null,
            Ze = 1,
            r)
                return r()
        } finally {
            Ze = d,
            Tn.transition = l,
            $e = i,
            ($e & 6) === 0 && Qr()
        }
    }
    function wf() {
        un = Ri.current,
        nt(Ri)
    }
    function Os(r, i) {
        r.finishedWork = null,
        r.finishedLanes = 0;
        var l = r.timeoutHandle;
        if (l !== -1 && (r.timeoutHandle = -1,
        OC(l)),
        bt !== null)
            for (l = bt.return; l !== null; ) {
                var d = l;
                switch (kd(d),
                d.tag) {
                case 1:
                    d = d.type.childContextTypes,
                    d != null && kl();
                    break;
                case 3:
                    ki(),
                    nt(Jt),
                    nt(Lt),
                    zd();
                    break;
                case 5:
                    Vd(d);
                    break;
                case 4:
                    ki();
                    break;
                case 13:
                    nt(at);
                    break;
                case 19:
                    nt(at);
                    break;
                case 10:
                    Od(d.type._context);
                    break;
                case 22:
                case 23:
                    wf()
                }
                l = l.return
            }
        if (At = r,
        bt = r = ts(r.current, null),
        Mt = un = i,
        Ct = 0,
        Yo = null,
        hf = Yl = js = 0,
        nn = Xo = null,
        Ns !== null) {
            for (i = 0; i < Ns.length; i++)
                if (l = Ns[i],
                d = l.interleaved,
                d !== null) {
                    l.interleaved = null;
                    var p = d.next
                      , g = l.pending;
                    if (g !== null) {
                        var b = g.next;
                        g.next = p,
                        d.next = b
                    }
                    l.pending = d
                }
            Ns = null
        }
        return r
    }
    function tv(r, i) {
        do {
            var l = bt;
            try {
                if (Dd(),
                Bl.current = Wl,
                zl) {
                    for (var d = lt.memoizedState; d !== null; ) {
                        var p = d.queue;
                        p !== null && (p.pending = null),
                        d = d.next
                    }
                    zl = !1
                }
                if (Rs = 0,
                Nt = Pt = lt = null,
                Ho = !1,
                qo = 0,
                ff.current = null,
                l === null || l.return === null) {
                    Ct = 1,
                    Yo = i,
                    bt = null;
                    break
                }
                e: {
                    var g = r
                      , b = l.return
                      , E = l
                      , A = i;
                    if (i = Mt,
                    E.flags |= 32768,
                    A !== null && typeof A == "object" && typeof A.then == "function") {
                        var V = A
                          , K = E
                          , Z = K.tag;
                        if ((K.mode & 1) === 0 && (Z === 0 || Z === 11 || Z === 15)) {
                            var Q = K.alternate;
                            Q ? (K.updateQueue = Q.updateQueue,
                            K.memoizedState = Q.memoizedState,
                            K.lanes = Q.lanes) : (K.updateQueue = null,
                            K.memoizedState = null)
                        }
                        var de = Ey(b);
                        if (de !== null) {
                            de.flags &= -257,
                            _y(de, b, E, g, i),
                            de.mode & 1 && Cy(g, V, i),
                            i = de,
                            A = V;
                            var ge = i.updateQueue;
                            if (ge === null) {
                                var ye = new Set;
                                ye.add(A),
                                i.updateQueue = ye
                            } else
                                ge.add(A);
                            break e
                        } else {
                            if ((i & 1) === 0) {
                                Cy(g, V, i),
                                bf();
                                break e
                            }
                            A = Error(n(426))
                        }
                    } else if (ot && E.mode & 1) {
                        var gt = Ey(b);
                        if (gt !== null) {
                            (gt.flags & 65536) === 0 && (gt.flags |= 256),
                            _y(gt, b, E, g, i),
                            Rd(Ni(A, E));
                            break e
                        }
                    }
                    g = A = Ni(A, E),
                    Ct !== 4 && (Ct = 2),
                    Xo === null ? Xo = [g] : Xo.push(g),
                    g = b;
                    do {
                        switch (g.tag) {
                        case 3:
                            g.flags |= 65536,
                            i &= -i,
                            g.lanes |= i;
                            var I = Ty(g, A, i);
                            Zg(g, I);
                            break e;
                        case 1:
                            E = A;
                            var R = g.type
                              , F = g.stateNode;
                            if ((g.flags & 128) === 0 && (typeof R.getDerivedStateFromError == "function" || F !== null && typeof F.componentDidCatch == "function" && (Yr === null || !Yr.has(F)))) {
                                g.flags |= 65536,
                                i &= -i,
                                g.lanes |= i;
                                var te = Py(g, E, i);
                                Zg(g, te);
                                break e
                            }
                        }
                        g = g.return
                    } while (g !== null)
                }
                sv(l)
            } catch (ve) {
                i = ve,
                bt === l && l !== null && (bt = l = l.return);
                continue
            }
            break
        } while (!0)
    }
    function nv() {
        var r = Zl.current;
        return Zl.current = Wl,
        r === null ? Wl : r
    }
    function bf() {
        (Ct === 0 || Ct === 3 || Ct === 2) && (Ct = 4),
        At === null || (js & 268435455) === 0 && (Yl & 268435455) === 0 || es(At, Mt)
    }
    function ru(r, i) {
        var l = $e;
        $e |= 2;
        var d = nv();
        (At !== r || Mt !== i) && (Tr = null,
        Os(r, i));
        do
            try {
                iE();
                break
            } catch (p) {
                tv(r, p)
            }
        while (!0);
        if (Dd(),
        $e = l,
        Zl.current = d,
        bt !== null)
            throw Error(n(261));
        return At = null,
        Mt = 0,
        Ct
    }
    function iE() {
        for (; bt !== null; )
            rv(bt)
    }
    function oE() {
        for (; bt !== null && !RP(); )
            rv(bt)
    }
    function rv(r) {
        var i = av(r.alternate, r, un);
        r.memoizedProps = r.pendingProps,
        i === null ? sv(r) : bt = i,
        ff.current = null
    }
    function sv(r) {
        var i = r;
        do {
            var l = i.alternate;
            if (r = i.return,
            (i.flags & 32768) === 0) {
                if (l = XC(l, i, un),
                l !== null) {
                    bt = l;
                    return
                }
            } else {
                if (l = JC(l, i),
                l !== null) {
                    l.flags &= 32767,
                    bt = l;
                    return
                }
                if (r !== null)
                    r.flags |= 32768,
                    r.subtreeFlags = 0,
                    r.deletions = null;
                else {
                    Ct = 6,
                    bt = null;
                    return
                }
            }
            if (i = i.sibling,
            i !== null) {
                bt = i;
                return
            }
            bt = i = r
        } while (i !== null);
        Ct === 0 && (Ct = 5)
    }
    function Ms(r, i, l) {
        var d = Ze
          , p = Tn.transition;
        try {
            Tn.transition = null,
            Ze = 1,
            aE(r, i, l, d)
        } finally {
            Tn.transition = p,
            Ze = d
        }
        return null
    }
    function aE(r, i, l, d) {
        do
            Di();
        while (Xr !== null);
        if (($e & 6) !== 0)
            throw Error(n(327));
        l = r.finishedWork;
        var p = r.finishedLanes;
        if (l === null)
            return null;
        if (r.finishedWork = null,
        r.finishedLanes = 0,
        l === r.current)
            throw Error(n(177));
        r.callbackNode = null,
        r.callbackPriority = 0;
        var g = l.lanes | l.childLanes;
        if (zP(r, g),
        r === At && (bt = At = null,
        Mt = 0),
        (l.subtreeFlags & 2064) === 0 && (l.flags & 2064) === 0 || Jl || (Jl = !0,
        lv(al, function() {
            return Di(),
            null
        })),
        g = (l.flags & 15990) !== 0,
        (l.subtreeFlags & 15990) !== 0 || g) {
            g = Tn.transition,
            Tn.transition = null;
            var b = Ze;
            Ze = 1;
            var E = $e;
            $e |= 4,
            ff.current = null,
            tE(r, l),
            Ky(l, r),
            _C(wd),
            pl = !!xd,
            wd = xd = null,
            r.current = l,
            nE(l),
            jP(),
            $e = E,
            Ze = b,
            Tn.transition = g
        } else
            r.current = l;
        if (Jl && (Jl = !1,
        Xr = r,
        eu = p),
        g = r.pendingLanes,
        g === 0 && (Yr = null),
        MP(l.stateNode),
        rn(r, mt()),
        i !== null)
            for (d = r.onRecoverableError,
            l = 0; l < i.length; l++)
                p = i[l],
                d(p.value, {
                    componentStack: p.stack,
                    digest: p.digest
                });
        if (Xl)
            throw Xl = !1,
            r = mf,
            mf = null,
            r;
        return (eu & 1) !== 0 && r.tag !== 0 && Di(),
        g = r.pendingLanes,
        (g & 1) !== 0 ? r === gf ? Jo++ : (Jo = 0,
        gf = r) : Jo = 0,
        Qr(),
        null
    }
    function Di() {
        if (Xr !== null) {
            var r = qm(eu)
              , i = Tn.transition
              , l = Ze;
            try {
                if (Tn.transition = null,
                Ze = 16 > r ? 16 : r,
                Xr === null)
                    var d = !1;
                else {
                    if (r = Xr,
                    Xr = null,
                    eu = 0,
                    ($e & 6) !== 0)
                        throw Error(n(331));
                    var p = $e;
                    for ($e |= 4,
                    me = r.current; me !== null; ) {
                        var g = me
                          , b = g.child;
                        if ((me.flags & 16) !== 0) {
                            var E = g.deletions;
                            if (E !== null) {
                                for (var A = 0; A < E.length; A++) {
                                    var V = E[A];
                                    for (me = V; me !== null; ) {
                                        var K = me;
                                        switch (K.tag) {
                                        case 0:
                                        case 11:
                                        case 15:
                                            Zo(8, K, g)
                                        }
                                        var Z = K.child;
                                        if (Z !== null)
                                            Z.return = K,
                                            me = Z;
                                        else
                                            for (; me !== null; ) {
                                                K = me;
                                                var Q = K.sibling
                                                  , de = K.return;
                                                if ($y(K),
                                                K === V) {
                                                    me = null;
                                                    break
                                                }
                                                if (Q !== null) {
                                                    Q.return = de,
                                                    me = Q;
                                                    break
                                                }
                                                me = de
                                            }
                                    }
                                }
                                var ge = g.alternate;
                                if (ge !== null) {
                                    var ye = ge.child;
                                    if (ye !== null) {
                                        ge.child = null;
                                        do {
                                            var gt = ye.sibling;
                                            ye.sibling = null,
                                            ye = gt
                                        } while (ye !== null)
                                    }
                                }
                                me = g
                            }
                        }
                        if ((g.subtreeFlags & 2064) !== 0 && b !== null)
                            b.return = g,
                            me = b;
                        else
                            e: for (; me !== null; ) {
                                if (g = me,
                                (g.flags & 2048) !== 0)
                                    switch (g.tag) {
                                    case 0:
                                    case 11:
                                    case 15:
                                        Zo(9, g, g.return)
                                    }
                                var I = g.sibling;
                                if (I !== null) {
                                    I.return = g.return,
                                    me = I;
                                    break e
                                }
                                me = g.return
                            }
                    }
                    var R = r.current;
                    for (me = R; me !== null; ) {
                        b = me;
                        var F = b.child;
                        if ((b.subtreeFlags & 2064) !== 0 && F !== null)
                            F.return = b,
                            me = F;
                        else
                            e: for (b = R; me !== null; ) {
                                if (E = me,
                                (E.flags & 2048) !== 0)
                                    try {
                                        switch (E.tag) {
                                        case 0:
                                        case 11:
                                        case 15:
                                            Gl(9, E)
                                        }
                                    } catch (ve) {
                                        ht(E, E.return, ve)
                                    }
                                if (E === b) {
                                    me = null;
                                    break e
                                }
                                var te = E.sibling;
                                if (te !== null) {
                                    te.return = E.return,
                                    me = te;
                                    break e
                                }
                                me = E.return
                            }
                    }
                    if ($e = p,
                    Qr(),
                    Gn && typeof Gn.onPostCommitFiberRoot == "function")
                        try {
                            Gn.onPostCommitFiberRoot(ll, r)
                        } catch {}
                    d = !0
                }
                return d
            } finally {
                Ze = l,
                Tn.transition = i
            }
        }
        return !1
    }
    function iv(r, i, l) {
        i = Ni(l, i),
        i = Ty(r, i, 1),
        r = Gr(r, i, 1),
        i = Gt(),
        r !== null && (To(r, 1, i),
        rn(r, i))
    }
    function ht(r, i, l) {
        if (r.tag === 3)
            iv(r, r, l);
        else
            for (; i !== null; ) {
                if (i.tag === 3) {
                    iv(i, r, l);
                    break
                } else if (i.tag === 1) {
                    var d = i.stateNode;
                    if (typeof i.type.getDerivedStateFromError == "function" || typeof d.componentDidCatch == "function" && (Yr === null || !Yr.has(d))) {
                        r = Ni(l, r),
                        r = Py(i, r, 1),
                        i = Gr(i, r, 1),
                        r = Gt(),
                        i !== null && (To(i, 1, r),
                        rn(i, r));
                        break
                    }
                }
                i = i.return
            }
    }
    function lE(r, i, l) {
        var d = r.pingCache;
        d !== null && d.delete(i),
        i = Gt(),
        r.pingedLanes |= r.suspendedLanes & l,
        At === r && (Mt & l) === l && (Ct === 4 || Ct === 3 && (Mt & 130023424) === Mt && 500 > mt() - pf ? Os(r, 0) : hf |= l),
        rn(r, i)
    }
    function ov(r, i) {
        i === 0 && ((r.mode & 1) === 0 ? i = 1 : (i = cl,
        cl <<= 1,
        (cl & 130023424) === 0 && (cl = 4194304)));
        var l = Gt();
        r = wr(r, i),
        r !== null && (To(r, i, l),
        rn(r, l))
    }
    function uE(r) {
        var i = r.memoizedState
          , l = 0;
        i !== null && (l = i.retryLane),
        ov(r, l)
    }
    function cE(r, i) {
        var l = 0;
        switch (r.tag) {
        case 13:
            var d = r.stateNode
              , p = r.memoizedState;
            p !== null && (l = p.retryLane);
            break;
        case 19:
            d = r.stateNode;
            break;
        default:
            throw Error(n(314))
        }
        d !== null && d.delete(i),
        ov(r, l)
    }
    var av;
    av = function(r, i, l) {
        if (r !== null)
            if (r.memoizedProps !== i.pendingProps || Jt.current)
                tn = !0;
            else {
                if ((r.lanes & l) === 0 && (i.flags & 128) === 0)
                    return tn = !1,
                    YC(r, i, l);
                tn = (r.flags & 131072) !== 0
            }
        else
            tn = !1,
            ot && (i.flags & 1048576) !== 0 && Bg(i, jl, i.index);
        switch (i.lanes = 0,
        i.tag) {
        case 2:
            var d = i.type;
            Ql(r, i),
            r = i.pendingProps;
            var p = bi(i, Lt.current);
            _i(i, l),
            p = Wd(null, i, d, r, p, l);
            var g = Hd();
            return i.flags |= 1,
            typeof p == "object" && p !== null && typeof p.render == "function" && p.$$typeof === void 0 ? (i.tag = 1,
            i.memoizedState = null,
            i.updateQueue = null,
            en(d) ? (g = !0,
            Nl(i)) : g = !1,
            i.memoizedState = p.state !== null && p.state !== void 0 ? p.state : null,
            Fd(i),
            p.updater = Hl,
            i.stateNode = p,
            p._reactInternals = i,
            Yd(i, d, r, l),
            i = tf(null, i, d, !0, g, l)) : (i.tag = 0,
            ot && g && _d(i),
            Kt(null, i, p, l),
            i = i.child),
            i;
        case 16:
            d = i.elementType;
            e: {
                switch (Ql(r, i),
                r = i.pendingProps,
                p = d._init,
                d = p(d._payload),
                i.type = d,
                p = i.tag = fE(d),
                r = jn(d, r),
                p) {
                case 0:
                    i = ef(null, i, d, r, l);
                    break e;
                case 1:
                    i = Dy(null, i, d, r, l);
                    break e;
                case 11:
                    i = ky(null, i, d, r, l);
                    break e;
                case 14:
                    i = Ny(null, i, d, jn(d.type, r), l);
                    break e
                }
                throw Error(n(306, d, ""))
            }
            return i;
        case 0:
            return d = i.type,
            p = i.pendingProps,
            p = i.elementType === d ? p : jn(d, p),
            ef(r, i, d, p, l);
        case 1:
            return d = i.type,
            p = i.pendingProps,
            p = i.elementType === d ? p : jn(d, p),
            Dy(r, i, d, p, l);
        case 3:
            e: {
                if (Oy(i),
                r === null)
                    throw Error(n(387));
                d = i.pendingProps,
                g = i.memoizedState,
                p = g.element,
                Gg(r, i),
                Ll(i, d, null, l);
                var b = i.memoizedState;
                if (d = b.element,
                g.isDehydrated)
                    if (g = {
                        element: d,
                        isDehydrated: !1,
                        cache: b.cache,
                        pendingSuspenseBoundaries: b.pendingSuspenseBoundaries,
                        transitions: b.transitions
                    },
                    i.updateQueue.baseState = g,
                    i.memoizedState = g,
                    i.flags & 256) {
                        p = Ni(Error(n(423)), i),
                        i = My(r, i, d, l, p);
                        break e
                    } else if (d !== p) {
                        p = Ni(Error(n(424)), i),
                        i = My(r, i, d, l, p);
                        break e
                    } else
                        for (ln = Wr(i.stateNode.containerInfo.firstChild),
                        an = i,
                        ot = !0,
                        Rn = null,
                        l = Qg(i, null, d, l),
                        i.child = l; l; )
                            l.flags = l.flags & -3 | 4096,
                            l = l.sibling;
                else {
                    if (Pi(),
                    d === p) {
                        i = Sr(r, i, l);
                        break e
                    }
                    Kt(r, i, d, l)
                }
                i = i.child
            }
            return i;
        case 5:
            return Xg(i),
            r === null && Ad(i),
            d = i.type,
            p = i.pendingProps,
            g = r !== null ? r.memoizedProps : null,
            b = p.children,
            bd(d, p) ? b = null : g !== null && bd(d, g) && (i.flags |= 32),
            jy(r, i),
            Kt(r, i, b, l),
            i.child;
        case 6:
            return r === null && Ad(i),
            null;
        case 13:
            return Iy(r, i, l);
        case 4:
            return Ld(i, i.stateNode.containerInfo),
            d = i.pendingProps,
            r === null ? i.child = Ci(i, null, d, l) : Kt(r, i, d, l),
            i.child;
        case 11:
            return d = i.type,
            p = i.pendingProps,
            p = i.elementType === d ? p : jn(d, p),
            ky(r, i, d, p, l);
        case 7:
            return Kt(r, i, i.pendingProps, l),
            i.child;
        case 8:
            return Kt(r, i, i.pendingProps.children, l),
            i.child;
        case 12:
            return Kt(r, i, i.pendingProps.children, l),
            i.child;
        case 10:
            e: {
                if (d = i.type._context,
                p = i.pendingProps,
                g = i.memoizedProps,
                b = p.value,
                et(Ml, d._currentValue),
                d._currentValue = b,
                g !== null)
                    if (An(g.value, b)) {
                        if (g.children === p.children && !Jt.current) {
                            i = Sr(r, i, l);
                            break e
                        }
                    } else
                        for (g = i.child,
                        g !== null && (g.return = i); g !== null; ) {
                            var E = g.dependencies;
                            if (E !== null) {
                                b = g.child;
                                for (var A = E.firstContext; A !== null; ) {
                                    if (A.context === d) {
                                        if (g.tag === 1) {
                                            A = br(-1, l & -l),
                                            A.tag = 2;
                                            var V = g.updateQueue;
                                            if (V !== null) {
                                                V = V.shared;
                                                var K = V.pending;
                                                K === null ? A.next = A : (A.next = K.next,
                                                K.next = A),
                                                V.pending = A
                                            }
                                        }
                                        g.lanes |= l,
                                        A = g.alternate,
                                        A !== null && (A.lanes |= l),
                                        Md(g.return, l, i),
                                        E.lanes |= l;
                                        break
                                    }
                                    A = A.next
                                }
                            } else if (g.tag === 10)
                                b = g.type === i.type ? null : g.child;
                            else if (g.tag === 18) {
                                if (b = g.return,
                                b === null)
                                    throw Error(n(341));
                                b.lanes |= l,
                                E = b.alternate,
                                E !== null && (E.lanes |= l),
                                Md(b, l, i),
                                b = g.sibling
                            } else
                                b = g.child;
                            if (b !== null)
                                b.return = g;
                            else
                                for (b = g; b !== null; ) {
                                    if (b === i) {
                                        b = null;
                                        break
                                    }
                                    if (g = b.sibling,
                                    g !== null) {
                                        g.return = b.return,
                                        b = g;
                                        break
                                    }
                                    b = b.return
                                }
                            g = b
                        }
                Kt(r, i, p.children, l),
                i = i.child
            }
            return i;
        case 9:
            return p = i.type,
            d = i.pendingProps.children,
            _i(i, l),
            p = bn(p),
            d = d(p),
            i.flags |= 1,
            Kt(r, i, d, l),
            i.child;
        case 14:
            return d = i.type,
            p = jn(d, i.pendingProps),
            p = jn(d.type, p),
            Ny(r, i, d, p, l);
        case 15:
            return Ay(r, i, i.type, i.pendingProps, l);
        case 17:
            return d = i.type,
            p = i.pendingProps,
            p = i.elementType === d ? p : jn(d, p),
            Ql(r, i),
            i.tag = 1,
            en(d) ? (r = !0,
            Nl(i)) : r = !1,
            _i(i, l),
            by(i, d, p),
            Yd(i, d, p, l),
            tf(null, i, d, !0, r, l);
        case 19:
            return Ly(r, i, l);
        case 22:
            return Ry(r, i, l)
        }
        throw Error(n(156, i.tag))
    }
    ;
    function lv(r, i) {
        return zm(r, i)
    }
    function dE(r, i, l, d) {
        this.tag = r,
        this.key = l,
        this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null,
        this.index = 0,
        this.ref = null,
        this.pendingProps = i,
        this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null,
        this.mode = d,
        this.subtreeFlags = this.flags = 0,
        this.deletions = null,
        this.childLanes = this.lanes = 0,
        this.alternate = null
    }
    function Pn(r, i, l, d) {
        return new dE(r,i,l,d)
    }
    function Sf(r) {
        return r = r.prototype,
        !(!r || !r.isReactComponent)
    }
    function fE(r) {
        if (typeof r == "function")
            return Sf(r) ? 1 : 0;
        if (r != null) {
            if (r = r.$$typeof,
            r === X)
                return 11;
            if (r === be)
                return 14
        }
        return 2
    }
    function ts(r, i) {
        var l = r.alternate;
        return l === null ? (l = Pn(r.tag, i, r.key, r.mode),
        l.elementType = r.elementType,
        l.type = r.type,
        l.stateNode = r.stateNode,
        l.alternate = r,
        r.alternate = l) : (l.pendingProps = i,
        l.type = r.type,
        l.flags = 0,
        l.subtreeFlags = 0,
        l.deletions = null),
        l.flags = r.flags & 14680064,
        l.childLanes = r.childLanes,
        l.lanes = r.lanes,
        l.child = r.child,
        l.memoizedProps = r.memoizedProps,
        l.memoizedState = r.memoizedState,
        l.updateQueue = r.updateQueue,
        i = r.dependencies,
        l.dependencies = i === null ? null : {
            lanes: i.lanes,
            firstContext: i.firstContext
        },
        l.sibling = r.sibling,
        l.index = r.index,
        l.ref = r.ref,
        l
    }
    function su(r, i, l, d, p, g) {
        var b = 2;
        if (d = r,
        typeof r == "function")
            Sf(r) && (b = 1);
        else if (typeof r == "string")
            b = 5;
        else
            e: switch (r) {
            case U:
                return Is(l.children, p, g, i);
            case W:
                b = 8,
                p |= 8;
                break;
            case oe:
                return r = Pn(12, l, i, p | 2),
                r.elementType = oe,
                r.lanes = g,
                r;
            case se:
                return r = Pn(13, l, i, p),
                r.elementType = se,
                r.lanes = g,
                r;
            case G:
                return r = Pn(19, l, i, p),
                r.elementType = G,
                r.lanes = g,
                r;
            case ie:
                return iu(l, p, g, i);
            default:
                if (typeof r == "object" && r !== null)
                    switch (r.$$typeof) {
                    case fe:
                        b = 10;
                        break e;
                    case we:
                        b = 9;
                        break e;
                    case X:
                        b = 11;
                        break e;
                    case be:
                        b = 14;
                        break e;
                    case ce:
                        b = 16,
                        d = null;
                        break e
                    }
                throw Error(n(130, r == null ? r : typeof r, ""))
            }
        return i = Pn(b, l, i, p),
        i.elementType = r,
        i.type = d,
        i.lanes = g,
        i
    }
    function Is(r, i, l, d) {
        return r = Pn(7, r, d, i),
        r.lanes = l,
        r
    }
    function iu(r, i, l, d) {
        return r = Pn(22, r, d, i),
        r.elementType = ie,
        r.lanes = l,
        r.stateNode = {
            isHidden: !1
        },
        r
    }
    function Tf(r, i, l) {
        return r = Pn(6, r, null, i),
        r.lanes = l,
        r
    }
    function Pf(r, i, l) {
        return i = Pn(4, r.children !== null ? r.children : [], r.key, i),
        i.lanes = l,
        i.stateNode = {
            containerInfo: r.containerInfo,
            pendingChildren: null,
            implementation: r.implementation
        },
        i
    }
    function hE(r, i, l, d, p) {
        this.tag = i,
        this.containerInfo = r,
        this.finishedWork = this.pingCache = this.current = this.pendingChildren = null,
        this.timeoutHandle = -1,
        this.callbackNode = this.pendingContext = this.context = null,
        this.callbackPriority = 0,
        this.eventTimes = Zc(0),
        this.expirationTimes = Zc(-1),
        this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0,
        this.entanglements = Zc(0),
        this.identifierPrefix = d,
        this.onRecoverableError = p,
        this.mutableSourceEagerHydrationData = null
    }
    function Cf(r, i, l, d, p, g, b, E, A) {
        return r = new hE(r,i,l,E,A),
        i === 1 ? (i = 1,
        g === !0 && (i |= 8)) : i = 0,
        g = Pn(3, null, null, i),
        r.current = g,
        g.stateNode = r,
        g.memoizedState = {
            element: d,
            isDehydrated: l,
            cache: null,
            transitions: null,
            pendingSuspenseBoundaries: null
        },
        Fd(g),
        r
    }
    function pE(r, i, l) {
        var d = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
        return {
            $$typeof: z,
            key: d == null ? null : "" + d,
            children: r,
            containerInfo: i,
            implementation: l
        }
    }
    function uv(r) {
        if (!r)
            return qr;
        r = r._reactInternals;
        e: {
            if (Ps(r) !== r || r.tag !== 1)
                throw Error(n(170));
            var i = r;
            do {
                switch (i.tag) {
                case 3:
                    i = i.stateNode.context;
                    break e;
                case 1:
                    if (en(i.type)) {
                        i = i.stateNode.__reactInternalMemoizedMergedChildContext;
                        break e
                    }
                }
                i = i.return
            } while (i !== null);
            throw Error(n(171))
        }
        if (r.tag === 1) {
            var l = r.type;
            if (en(l))
                return Fg(r, l, i)
        }
        return i
    }
    function cv(r, i, l, d, p, g, b, E, A) {
        return r = Cf(l, d, !0, r, p, g, b, E, A),
        r.context = uv(null),
        l = r.current,
        d = Gt(),
        p = Jr(l),
        g = br(d, p),
        g.callback = i ?? null,
        Gr(l, g, p),
        r.current.lanes = p,
        To(r, p, d),
        rn(r, d),
        r
    }
    function ou(r, i, l, d) {
        var p = i.current
          , g = Gt()
          , b = Jr(p);
        return l = uv(l),
        i.context === null ? i.context = l : i.pendingContext = l,
        i = br(g, b),
        i.payload = {
            element: r
        },
        d = d === void 0 ? null : d,
        d !== null && (i.callback = d),
        r = Gr(p, i, b),
        r !== null && (Mn(r, p, b, g),
        Fl(r, p, b)),
        b
    }
    function au(r) {
        return r = r.current,
        r.child ? (r.child.tag === 5,
        r.child.stateNode) : null
    }
    function dv(r, i) {
        if (r = r.memoizedState,
        r !== null && r.dehydrated !== null) {
            var l = r.retryLane;
            r.retryLane = l !== 0 && l < i ? l : i
        }
    }
    function Ef(r, i) {
        dv(r, i),
        (r = r.alternate) && dv(r, i)
    }
    function mE() {
        return null
    }
    var fv = typeof reportError == "function" ? reportError : function(r) {
        console.error(r)
    }
    ;
    function _f(r) {
        this._internalRoot = r
    }
    lu.prototype.render = _f.prototype.render = function(r) {
        var i = this._internalRoot;
        if (i === null)
            throw Error(n(409));
        ou(r, i, null, null)
    }
    ,
    lu.prototype.unmount = _f.prototype.unmount = function() {
        var r = this._internalRoot;
        if (r !== null) {
            this._internalRoot = null;
            var i = r.containerInfo;
            Ds(function() {
                ou(null, r, null, null)
            }),
            i[gr] = null
        }
    }
    ;
    function lu(r) {
        this._internalRoot = r
    }
    lu.prototype.unstable_scheduleHydration = function(r) {
        if (r) {
            var i = Gm();
            r = {
                blockedOn: null,
                target: r,
                priority: i
            };
            for (var l = 0; l < zr.length && i !== 0 && i < zr[l].priority; l++)
                ;
            zr.splice(l, 0, r),
            l === 0 && Xm(r)
        }
    }
    ;
    function kf(r) {
        return !(!r || r.nodeType !== 1 && r.nodeType !== 9 && r.nodeType !== 11)
    }
    function uu(r) {
        return !(!r || r.nodeType !== 1 && r.nodeType !== 9 && r.nodeType !== 11 && (r.nodeType !== 8 || r.nodeValue !== " react-mount-point-unstable "))
    }
    function hv() {}
    function gE(r, i, l, d, p) {
        if (p) {
            if (typeof d == "function") {
                var g = d;
                d = function() {
                    var V = au(b);
                    g.call(V)
                }
            }
            var b = cv(i, d, r, 0, null, !1, !1, "", hv);
            return r._reactRootContainer = b,
            r[gr] = b.current,
            Fo(r.nodeType === 8 ? r.parentNode : r),
            Ds(),
            b
        }
        for (; p = r.lastChild; )
            r.removeChild(p);
        if (typeof d == "function") {
            var E = d;
            d = function() {
                var V = au(A);
                E.call(V)
            }
        }
        var A = Cf(r, 0, !1, null, null, !1, !1, "", hv);
        return r._reactRootContainer = A,
        r[gr] = A.current,
        Fo(r.nodeType === 8 ? r.parentNode : r),
        Ds(function() {
            ou(i, A, l, d)
        }),
        A
    }
    function cu(r, i, l, d, p) {
        var g = l._reactRootContainer;
        if (g) {
            var b = g;
            if (typeof p == "function") {
                var E = p;
                p = function() {
                    var A = au(b);
                    E.call(A)
                }
            }
            ou(i, b, r, p)
        } else
            b = gE(l, i, r, p, d);
        return au(b)
    }
    Qm = function(r) {
        switch (r.tag) {
        case 3:
            var i = r.stateNode;
            if (i.current.memoizedState.isDehydrated) {
                var l = So(i.pendingLanes);
                l !== 0 && (Yc(i, l | 1),
                rn(i, mt()),
                ($e & 6) === 0 && (ji = mt() + 500,
                Qr()))
            }
            break;
        case 13:
            Ds(function() {
                var d = wr(r, 1);
                if (d !== null) {
                    var p = Gt();
                    Mn(d, r, 1, p)
                }
            }),
            Ef(r, 1)
        }
    }
    ,
    Xc = function(r) {
        if (r.tag === 13) {
            var i = wr(r, 134217728);
            if (i !== null) {
                var l = Gt();
                Mn(i, r, 134217728, l)
            }
            Ef(r, 134217728)
        }
    }
    ,
    Km = function(r) {
        if (r.tag === 13) {
            var i = Jr(r)
              , l = wr(r, i);
            if (l !== null) {
                var d = Gt();
                Mn(l, r, i, d)
            }
            Ef(r, i)
        }
    }
    ,
    Gm = function() {
        return Ze
    }
    ,
    Zm = function(r, i) {
        var l = Ze;
        try {
            return Ze = r,
            i()
        } finally {
            Ze = l
        }
    }
    ,
    Wc = function(r, i, l) {
        switch (i) {
        case "input":
            if (si(r, l),
            i = l.name,
            l.type === "radio" && i != null) {
                for (l = r; l.parentNode; )
                    l = l.parentNode;
                for (l = l.querySelectorAll("input[name=" + JSON.stringify("" + i) + '][type="radio"]'),
                i = 0; i < l.length; i++) {
                    var d = l[i];
                    if (d !== r && d.form === r.form) {
                        var p = _l(d);
                        if (!p)
                            throw Error(n(90));
                        Ts(d),
                        si(d, p)
                    }
                }
            }
            break;
        case "textarea":
            $(r, l);
            break;
        case "select":
            i = l.value,
            i != null && mr(r, !!l.multiple, i, !1)
        }
    }
    ,
    Om = xf,
    Mm = Ds;
    var yE = {
        usingClientEntryPoint: !1,
        Events: [Bo, xi, _l, jm, Dm, xf]
    }
      , ea = {
        findFiberByHostInstance: Cs,
        bundleType: 0,
        version: "18.3.1",
        rendererPackageName: "react-dom"
    }
      , vE = {
        bundleType: ea.bundleType,
        version: ea.version,
        rendererPackageName: ea.rendererPackageName,
        rendererConfig: ea.rendererConfig,
        overrideHookState: null,
        overrideHookStateDeletePath: null,
        overrideHookStateRenamePath: null,
        overrideProps: null,
        overridePropsDeletePath: null,
        overridePropsRenamePath: null,
        setErrorHandler: null,
        setSuspenseHandler: null,
        scheduleUpdate: null,
        currentDispatcherRef: M.ReactCurrentDispatcher,
        findHostInstanceByFiber: function(r) {
            return r = Vm(r),
            r === null ? null : r.stateNode
        },
        findFiberByHostInstance: ea.findFiberByHostInstance || mE,
        findHostInstancesForRefresh: null,
        scheduleRefresh: null,
        scheduleRoot: null,
        setRefreshHandler: null,
        getCurrentFiber: null,
        reconcilerVersion: "18.3.1-next-f1338f8080-20240426"
    };
    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
        var du = __REACT_DEVTOOLS_GLOBAL_HOOK__;
        if (!du.isDisabled && du.supportsFiber)
            try {
                ll = du.inject(vE),
                Gn = du
            } catch {}
    }
    return sn.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = yE,
    sn.createPortal = function(r, i) {
        var l = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
        if (!kf(i))
            throw Error(n(200));
        return pE(r, i, null, l)
    }
    ,
    sn.createRoot = function(r, i) {
        if (!kf(r))
            throw Error(n(299));
        var l = !1
          , d = ""
          , p = fv;
        return i != null && (i.unstable_strictMode === !0 && (l = !0),
        i.identifierPrefix !== void 0 && (d = i.identifierPrefix),
        i.onRecoverableError !== void 0 && (p = i.onRecoverableError)),
        i = Cf(r, 1, !1, null, null, l, !1, d, p),
        r[gr] = i.current,
        Fo(r.nodeType === 8 ? r.parentNode : r),
        new _f(i)
    }
    ,
    sn.findDOMNode = function(r) {
        if (r == null)
            return null;
        if (r.nodeType === 1)
            return r;
        var i = r._reactInternals;
        if (i === void 0)
            throw typeof r.render == "function" ? Error(n(188)) : (r = Object.keys(r).join(","),
            Error(n(268, r)));
        return r = Vm(i),
        r = r === null ? null : r.stateNode,
        r
    }
    ,
    sn.flushSync = function(r) {
        return Ds(r)
    }
    ,
    sn.hydrate = function(r, i, l) {
        if (!uu(i))
            throw Error(n(200));
        return cu(null, r, i, !0, l)
    }
    ,
    sn.hydrateRoot = function(r, i, l) {
        if (!kf(r))
            throw Error(n(405));
        var d = l != null && l.hydratedSources || null
          , p = !1
          , g = ""
          , b = fv;
        if (l != null && (l.unstable_strictMode === !0 && (p = !0),
        l.identifierPrefix !== void 0 && (g = l.identifierPrefix),
        l.onRecoverableError !== void 0 && (b = l.onRecoverableError)),
        i = cv(i, null, r, 1, l ?? null, p, !1, g, b),
        r[gr] = i.current,
        Fo(r),
        d)
            for (r = 0; r < d.length; r++)
                l = d[r],
                p = l._getVersion,
                p = p(l._source),
                i.mutableSourceEagerHydrationData == null ? i.mutableSourceEagerHydrationData = [l, p] : i.mutableSourceEagerHydrationData.push(l, p);
        return new lu(i)
    }
    ,
    sn.render = function(r, i, l) {
        if (!uu(i))
            throw Error(n(200));
        return cu(null, r, i, !1, l)
    }
    ,
    sn.unmountComponentAtNode = function(r) {
        if (!uu(r))
            throw Error(n(40));
        return r._reactRootContainer ? (Ds(function() {
            cu(null, null, r, !1, function() {
                r._reactRootContainer = null,
                r[gr] = null
            })
        }),
        !0) : !1
    }
    ,
    sn.unstable_batchedUpdates = xf,
    sn.unstable_renderSubtreeIntoContainer = function(r, i, l, d) {
        if (!uu(l))
            throw Error(n(200));
        if (r == null || r._reactInternals === void 0)
            throw Error(n(38));
        return cu(r, i, l, !1, d)
    }
    ,
    sn.version = "18.3.1-next-f1338f8080-20240426",
    sn
}
var bv;
function sw() {
    if (bv)
        return Rf.exports;
    bv = 1;
    function e() {
        if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"))
            try {
                __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e)
            } catch (t) {
                console.error(t)
            }
    }
    return e(),
    Rf.exports = EE(),
    Rf.exports
}
var Sv;
function _E() {
    if (Sv)
        return fu;
    Sv = 1;
    var e = sw();
    return fu.createRoot = e.createRoot,
    fu.hydrateRoot = e.hydrateRoot,
    fu
}
var kE = _E();
function NE(e, t) {
    if (e instanceof RegExp)
        return {
            keys: !1,
            pattern: e
        };
    var n, s, o, a, u = [], c = "", f = e.split("/");
    for (f[0] || f.shift(); o = f.shift(); )
        n = o[0],
        n === "*" ? (u.push(n),
        c += o[1] === "?" ? "(?:/(.*))?" : "/(.*)") : n === ":" ? (s = o.indexOf("?", 1),
        a = o.indexOf(".", 1),
        u.push(o.substring(1, ~s ? s : ~a ? a : o.length)),
        c += ~s && !~a ? "(?:/([^/]+?))?" : "/([^/]+?)",
        ~a && (c += (~s ? "?" : "") + "\\" + o.substring(a))) : c += "/" + o;
    return {
        keys: u,
        pattern: new RegExp("^" + c + (t ? "(?=$|/)" : "/?$"),"i")
    }
}
var w = lc();
const Re = rw(w)
  , iw = wE({
    __proto__: null,
    default: Re
}, [w]);
var Of = {
    exports: {}
}
  , Mf = {};
var Tv;
function AE() {
    if (Tv)
        return Mf;
    Tv = 1;
    var e = lc();
    function t(v, x) {
        return v === x && (v !== 0 || 1 / v === 1 / x) || v !== v && x !== x
    }
    var n = typeof Object.is == "function" ? Object.is : t
      , s = e.useState
      , o = e.useEffect
      , a = e.useLayoutEffect
      , u = e.useDebugValue;
    function c(v, x) {
        var T = x()
          , C = s({
            inst: {
                value: T,
                getSnapshot: x
            }
        })
          , S = C[0].inst
          , P = C[1];
        return a(function() {
            S.value = T,
            S.getSnapshot = x,
            f(S) && P({
                inst: S
            })
        }, [v, T, x]),
        o(function() {
            return f(S) && P({
                inst: S
            }),
            v(function() {
                f(S) && P({
                    inst: S
                })
            })
        }, [v]),
        u(T),
        T
    }
    function f(v) {
        var x = v.getSnapshot;
        v = v.value;
        try {
            var T = x();
            return !n(v, T)
        } catch {
            return !0
        }
    }
    function h(v, x) {
        return x()
    }
    var m = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? h : c;
    return Mf.useSyncExternalStore = e.useSyncExternalStore !== void 0 ? e.useSyncExternalStore : m,
    Mf
}
var Pv;
function RE() {
    return Pv || (Pv = 1,
    Of.exports = AE()),
    Of.exports
}
var jE = RE();
const DE = iw.useInsertionEffect
  , OE = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u"
  , ME = OE ? w.useLayoutEffect : w.useEffect
  , IE = DE || ME
  , ow = e => {
    const t = w.useRef([e, (...n) => t[0](...n)]).current;
    return IE( () => {
        t[0] = e
    }
    ),
    t[1]
}
  , FE = "popstate"
  , lp = "pushState"
  , up = "replaceState"
  , LE = "hashchange"
  , Cv = [FE, lp, up, LE]
  , VE = e => {
    for (const t of Cv)
        addEventListener(t, e);
    return () => {
        for (const t of Cv)
            removeEventListener(t, e)
    }
}
  , aw = (e, t) => jE.useSyncExternalStore(VE, e, t)
  , BE = () => location.search
  , zE = ({ssrSearch: e=""}={}) => aw(BE, () => e)
  , Ev = () => location.pathname
  , UE = ({ssrPath: e}={}) => aw(Ev, e ? () => e : Ev)
  , $E = (e, {replace: t=!1, state: n=null}={}) => history[t ? up : lp](n, "", e)
  , WE = (e={}) => [UE(e), $E]
  , _v = Symbol.for("wouter_v3");
if (typeof history < "u" && typeof window[_v] > "u") {
    for (const e of [lp, up]) {
        const t = history[e];
        history[e] = function() {
            const n = t.apply(this, arguments)
              , s = new Event(e);
            return s.arguments = arguments,
            dispatchEvent(s),
            n
        }
    }
    Object.defineProperty(window, _v, {
        value: !0
    })
}
const HE = (e, t) => t.toLowerCase().indexOf(e.toLowerCase()) ? "~" + t : t.slice(e.length) || "/"
  , lw = (e="") => e === "/" ? "" : e
  , qE = (e, t) => e[0] === "~" ? e.slice(1) : lw(t) + e
  , QE = (e="", t) => HE(kv(lw(e)), kv(t))
  , kv = e => {
    try {
        return decodeURI(e)
    } catch {
        return e
    }
}
  , uw = {
    hook: WE,
    searchHook: zE,
    parser: NE,
    base: "",
    ssrPath: void 0,
    ssrSearch: void 0,
    hrefs: e => e
}
  , cw = w.createContext(uw)
  , ao = () => w.useContext(cw)
  , dw = {}
  , fw = w.createContext(dw)
  , KE = () => w.useContext(fw)
  , uc = e => {
    const [t,n] = e.hook(e);
    return [QE(e.base, t), ow( (s, o) => n(qE(s, e.base), o))]
}
  , cp = () => uc(ao())
  , dp = (e, t, n, s) => {
    const {pattern: o, keys: a} = t instanceof RegExp ? {
        keys: !1,
        pattern: t
    } : e(t || "*", s)
      , u = o.exec(n) || []
      , [c,...f] = u;
    return c !== void 0 ? [!0, ( () => {
        const h = a !== !1 ? Object.fromEntries(a.map( (v, x) => [v, f[x]])) : u.groups;
        let m = {
            ...f
        };
        return h && Object.assign(m, h),
        m
    }
    )(), ...s ? [c] : []] : [!1, null]
}
  , GE = e => dp(ao().parser, e, cp()[0])
  , ZE = ({children: e, ...t}) => {
    const n = ao()
      , s = t.hook ? uw : n;
    let o = s;
    const [a,u] = t.ssrPath?.split("?") ?? [];
    u && (t.ssrSearch = u,
    t.ssrPath = a),
    t.hrefs = t.hrefs ?? t.hook?.hrefs;
    let c = w.useRef({})
      , f = c.current
      , h = f;
    for (let m in s) {
        const v = m === "base" ? s[m] + (t[m] || "") : t[m] || s[m];
        f === h && v !== h[m] && (c.current = h = {
            ...h
        }),
        h[m] = v,
        v !== s[m] && (o = h)
    }
    return w.createElement(cw.Provider, {
        value: o,
        children: e
    })
}
  , Nv = ({children: e, component: t}, n) => t ? w.createElement(t, {
    params: n
}) : typeof e == "function" ? e(n) : e
  , YE = e => {
    let t = w.useRef(dw)
      , n = t.current;
    for (const s in e)
        e[s] !== n[s] && (n = e);
    return Object.keys(e).length === 0 && (n = e),
    t.current = n
}
  , er = ({path: e, nest: t, match: n, ...s}) => {
    const o = ao()
      , [a] = uc(o)
      , [u,c,f] = n ?? dp(o.parser, e, a, t)
      , h = YE({
        ...KE(),
        ...c
    });
    if (!u)
        return null;
    const m = f ? w.createElement(ZE, {
        base: f
    }, Nv(s, h)) : Nv(s, h);
    return w.createElement(fw.Provider, {
        value: h,
        children: m
    })
}
  , dn = w.forwardRef( (e, t) => {
    const n = ao()
      , [s,o] = uc(n)
      , {to: a="", href: u=a, onClick: c, asChild: f, children: h, className: m, replace: v, state: x, ...T} = e
      , C = ow(P => {
        P.ctrlKey || P.metaKey || P.altKey || P.shiftKey || P.button !== 0 || (c?.(P),
        P.defaultPrevented || (P.preventDefault(),
        o(u, e)))
    }
    )
      , S = n.hrefs(u[0] === "~" ? u.slice(1) : n.base + u, n);
    return f && w.isValidElement(h) ? w.cloneElement(h, {
        onClick: C,
        href: S
    }) : w.createElement("a", {
        ...T,
        onClick: C,
        href: S,
        className: m?.call ? m(s === u) : m,
        children: h,
        ref: t
    })
}
)
  , hw = e => Array.isArray(e) ? e.flatMap(t => hw(t && t.type === w.Fragment ? t.props.children : t)) : [e]
  , XE = ({children: e, location: t}) => {
    const n = ao()
      , [s] = uc(n);
    for (const o of hw(e)) {
        let a = 0;
        if (w.isValidElement(o) && (a = dp(n.parser, o.props.path, t || s, o.props.nest))[0])
            return w.cloneElement(o, {
                match: a
            })
    }
    return null
}
;
var lo = class {
    constructor() {
        this.listeners = new Set,
        this.subscribe = this.subscribe.bind(this)
    }
    subscribe(e) {
        return this.listeners.add(e),
        this.onSubscribe(),
        () => {
            this.listeners.delete(e),
            this.onUnsubscribe()
        }
    }
    hasListeners() {
        return this.listeners.size > 0
    }
    onSubscribe() {}
    onUnsubscribe() {}
}
  , qs = typeof window > "u" || "Deno"in globalThis;
function _n() {}
function JE(e, t) {
    return typeof e == "function" ? e(t) : e
}
function xh(e) {
    return typeof e == "number" && e >= 0 && e !== 1 / 0
}
function pw(e, t) {
    return Math.max(e + (t || 0) - Date.now(), 0)
}
function qi(e, t) {
    return typeof e == "function" ? e(t) : e
}
function Ln(e, t) {
    return typeof e == "function" ? e(t) : e
}
function Av(e, t) {
    const {type: n="all", exact: s, fetchStatus: o, predicate: a, queryKey: u, stale: c} = e;
    if (u) {
        if (s) {
            if (t.queryHash !== fp(u, t.options))
                return !1
        } else if (!Ta(t.queryKey, u))
            return !1
    }
    if (n !== "all") {
        const f = t.isActive();
        if (n === "active" && !f || n === "inactive" && f)
            return !1
    }
    return !(typeof c == "boolean" && t.isStale() !== c || o && o !== t.state.fetchStatus || a && !a(t))
}
function Rv(e, t) {
    const {exact: n, status: s, predicate: o, mutationKey: a} = e;
    if (a) {
        if (!t.options.mutationKey)
            return !1;
        if (n) {
            if (Qs(t.options.mutationKey) !== Qs(a))
                return !1
        } else if (!Ta(t.options.mutationKey, a))
            return !1
    }
    return !(s && t.state.status !== s || o && !o(t))
}
function fp(e, t) {
    return (t?.queryKeyHashFn || Qs)(e)
}
function Qs(e) {
    return JSON.stringify(e, (t, n) => wh(n) ? Object.keys(n).sort().reduce( (s, o) => (s[o] = n[o],
    s), {}) : n)
}
function Ta(e, t) {
    return e === t ? !0 : typeof e != typeof t ? !1 : e && t && typeof e == "object" && typeof t == "object" ? !Object.keys(t).some(n => !Ta(e[n], t[n])) : !1
}
function mw(e, t) {
    if (e === t)
        return e;
    const n = jv(e) && jv(t);
    if (n || wh(e) && wh(t)) {
        const s = n ? e : Object.keys(e)
          , o = s.length
          , a = n ? t : Object.keys(t)
          , u = a.length
          , c = n ? [] : {};
        let f = 0;
        for (let h = 0; h < u; h++) {
            const m = n ? h : a[h];
            (!n && s.includes(m) || n) && e[m] === void 0 && t[m] === void 0 ? (c[m] = void 0,
            f++) : (c[m] = mw(e[m], t[m]),
            c[m] === e[m] && e[m] !== void 0 && f++)
        }
        return o === u && f === o ? e : c
    }
    return t
}
function Mu(e, t) {
    if (!t || Object.keys(e).length !== Object.keys(t).length)
        return !1;
    for (const n in e)
        if (e[n] !== t[n])
            return !1;
    return !0
}
function jv(e) {
    return Array.isArray(e) && e.length === Object.keys(e).length
}
function wh(e) {
    if (!Dv(e))
        return !1;
    const t = e.constructor;
    if (t === void 0)
        return !0;
    const n = t.prototype;
    return !(!Dv(n) || !n.hasOwnProperty("isPrototypeOf") || Object.getPrototypeOf(e) !== Object.prototype)
}
function Dv(e) {
    return Object.prototype.toString.call(e) === "[object Object]"
}
function e_(e) {
    return new Promise(t => {
        setTimeout(t, e)
    }
    )
}
function bh(e, t, n) {
    return typeof n.structuralSharing == "function" ? n.structuralSharing(e, t) : n.structuralSharing !== !1 ? mw(e, t) : t
}
function t_(e, t, n=0) {
    const s = [...e, t];
    return n && s.length > n ? s.slice(1) : s
}
function n_(e, t, n=0) {
    const s = [t, ...e];
    return n && s.length > n ? s.slice(0, -1) : s
}
var hp = Symbol();
function gw(e, t) {
    return !e.queryFn && t?.initialPromise ? () => t.initialPromise : !e.queryFn || e.queryFn === hp ? () => Promise.reject(new Error(`Missing queryFn: '${e.queryHash}'`)) : e.queryFn
}
var r_ = class extends lo {
    #e;
    #t;
    #r;
    constructor() {
        super(),
        this.#r = e => {
            if (!qs && window.addEventListener) {
                const t = () => e();
                return window.addEventListener("visibilitychange", t, !1),
                () => {
                    window.removeEventListener("visibilitychange", t)
                }
            }
        }
    }
    onSubscribe() {
        this.#t || this.setEventListener(this.#r)
    }
    onUnsubscribe() {
        this.hasListeners() || (this.#t?.(),
        this.#t = void 0)
    }
    setEventListener(e) {
        this.#r = e,
        this.#t?.(),
        this.#t = e(t => {
            typeof t == "boolean" ? this.setFocused(t) : this.onFocus()
        }
        )
    }
    setFocused(e) {
        this.#e !== e && (this.#e = e,
        this.onFocus())
    }
    onFocus() {
        const e = this.isFocused();
        this.listeners.forEach(t => {
            t(e)
        }
        )
    }
    isFocused() {
        return typeof this.#e == "boolean" ? this.#e : globalThis.document?.visibilityState !== "hidden"
    }
}
  , pp = new r_
  , s_ = class extends lo {
    #e = !0;
    #t;
    #r;
    constructor() {
        super(),
        this.#r = e => {
            if (!qs && window.addEventListener) {
                const t = () => e(!0)
                  , n = () => e(!1);
                return window.addEventListener("online", t, !1),
                window.addEventListener("offline", n, !1),
                () => {
                    window.removeEventListener("online", t),
                    window.removeEventListener("offline", n)
                }
            }
        }
    }
    onSubscribe() {
        this.#t || this.setEventListener(this.#r)
    }
    onUnsubscribe() {
        this.hasListeners() || (this.#t?.(),
        this.#t = void 0)
    }
    setEventListener(e) {
        this.#r = e,
        this.#t?.(),
        this.#t = e(this.setOnline.bind(this))
    }
    setOnline(e) {
        this.#e !== e && (this.#e = e,
        this.listeners.forEach(n => {
            n(e)
        }
        ))
    }
    isOnline() {
        return this.#e
    }
}
  , Iu = new s_;
function Sh() {
    let e, t;
    const n = new Promise( (o, a) => {
        e = o,
        t = a
    }
    );
    n.status = "pending",
    n.catch( () => {}
    );
    function s(o) {
        Object.assign(n, o),
        delete n.resolve,
        delete n.reject
    }
    return n.resolve = o => {
        s({
            status: "fulfilled",
            value: o
        }),
        e(o)
    }
    ,
    n.reject = o => {
        s({
            status: "rejected",
            reason: o
        }),
        t(o)
    }
    ,
    n
}
function i_(e) {
    return Math.min(1e3 * 2 ** e, 3e4)
}
function yw(e) {
    return (e ?? "online") === "online" ? Iu.isOnline() : !0
}
var vw = class extends Error {
    constructor(e) {
        super("CancelledError"),
        this.revert = e?.revert,
        this.silent = e?.silent
    }
}
;
function If(e) {
    return e instanceof vw
}
function xw(e) {
    let t = !1, n = 0, s = !1, o;
    const a = Sh()
      , u = S => {
        s || (x(new vw(S)),
        e.abort?.())
    }
      , c = () => {
        t = !0
    }
      , f = () => {
        t = !1
    }
      , h = () => pp.isFocused() && (e.networkMode === "always" || Iu.isOnline()) && e.canRun()
      , m = () => yw(e.networkMode) && e.canRun()
      , v = S => {
        s || (s = !0,
        e.onSuccess?.(S),
        o?.(),
        a.resolve(S))
    }
      , x = S => {
        s || (s = !0,
        e.onError?.(S),
        o?.(),
        a.reject(S))
    }
      , T = () => new Promise(S => {
        o = P => {
            (s || h()) && S(P)
        }
        ,
        e.onPause?.()
    }
    ).then( () => {
        o = void 0,
        s || e.onContinue?.()
    }
    )
      , C = () => {
        if (s)
            return;
        let S;
        const P = n === 0 ? e.initialPromise : void 0;
        try {
            S = P ?? e.fn()
        } catch (_) {
            S = Promise.reject(_)
        }
        Promise.resolve(S).then(v).catch(_ => {
            if (s)
                return;
            const k = e.retry ?? (qs ? 0 : 3)
              , j = e.retryDelay ?? i_
              , M = typeof j == "function" ? j(n, _) : j
              , O = k === !0 || typeof k == "number" && n < k || typeof k == "function" && k(n, _);
            if (t || !O) {
                x(_);
                return
            }
            n++,
            e.onFail?.(n, _),
            e_(M).then( () => h() ? void 0 : T()).then( () => {
                t ? x(_) : C()
            }
            )
        }
        )
    }
    ;
    return {
        promise: a,
        cancel: u,
        continue: () => (o?.(),
        a),
        cancelRetry: c,
        continueRetry: f,
        canStart: m,
        start: () => (m() ? C() : T().then(C),
        a)
    }
}
function o_() {
    let e = []
      , t = 0
      , n = c => {
        c()
    }
      , s = c => {
        c()
    }
      , o = c => setTimeout(c, 0);
    const a = c => {
        t ? e.push(c) : o( () => {
            n(c)
        }
        )
    }
      , u = () => {
        const c = e;
        e = [],
        c.length && o( () => {
            s( () => {
                c.forEach(f => {
                    n(f)
                }
                )
            }
            )
        }
        )
    }
    ;
    return {
        batch: c => {
            let f;
            t++;
            try {
                f = c()
            } finally {
                t--,
                t || u()
            }
            return f
        }
        ,
        batchCalls: c => (...f) => {
            a( () => {
                c(...f)
            }
            )
        }
        ,
        schedule: a,
        setNotifyFunction: c => {
            n = c
        }
        ,
        setBatchNotifyFunction: c => {
            s = c
        }
        ,
        setScheduler: c => {
            o = c
        }
    }
}
var _t = o_()
  , ww = class {
    #e;
    destroy() {
        this.clearGcTimeout()
    }
    scheduleGc() {
        this.clearGcTimeout(),
        xh(this.gcTime) && (this.#e = setTimeout( () => {
            this.optionalRemove()
        }
        , this.gcTime))
    }
    updateGcTime(e) {
        this.gcTime = Math.max(this.gcTime || 0, e ?? (qs ? 1 / 0 : 300 * 1e3))
    }
    clearGcTimeout() {
        this.#e && (clearTimeout(this.#e),
        this.#e = void 0)
    }
}
  , a_ = class extends ww {
    #e;
    #t;
    #r;
    #n;
    #o;
    #i;
    constructor(e) {
        super(),
        this.#i = !1,
        this.#o = e.defaultOptions,
        this.setOptions(e.options),
        this.observers = [],
        this.#r = e.cache,
        this.queryKey = e.queryKey,
        this.queryHash = e.queryHash,
        this.#e = l_(this.options),
        this.state = e.state ?? this.#e,
        this.scheduleGc()
    }
    get meta() {
        return this.options.meta
    }
    get promise() {
        return this.#n?.promise
    }
    setOptions(e) {
        this.options = {
            ...this.#o,
            ...e
        },
        this.updateGcTime(this.options.gcTime)
    }
    optionalRemove() {
        !this.observers.length && this.state.fetchStatus === "idle" && this.#r.remove(this)
    }
    setData(e, t) {
        const n = bh(this.state.data, e, this.options);
        return this.#s({
            data: n,
            type: "success",
            dataUpdatedAt: t?.updatedAt,
            manual: t?.manual
        }),
        n
    }
    setState(e, t) {
        this.#s({
            type: "setState",
            state: e,
            setStateOptions: t
        })
    }
    cancel(e) {
        const t = this.#n?.promise;
        return this.#n?.cancel(e),
        t ? t.then(_n).catch(_n) : Promise.resolve()
    }
    destroy() {
        super.destroy(),
        this.cancel({
            silent: !0
        })
    }
    reset() {
        this.destroy(),
        this.setState(this.#e)
    }
    isActive() {
        return this.observers.some(e => Ln(e.options.enabled, this) !== !1)
    }
    isDisabled() {
        return this.getObserversCount() > 0 ? !this.isActive() : this.options.queryFn === hp || this.state.dataUpdateCount + this.state.errorUpdateCount === 0
    }
    isStale() {
        return this.state.isInvalidated ? !0 : this.getObserversCount() > 0 ? this.observers.some(e => e.getCurrentResult().isStale) : this.state.data === void 0
    }
    isStaleByTime(e=0) {
        return this.state.isInvalidated || this.state.data === void 0 || !pw(this.state.dataUpdatedAt, e)
    }
    onFocus() {
        this.observers.find(t => t.shouldFetchOnWindowFocus())?.refetch({
            cancelRefetch: !1
        }),
        this.#n?.continue()
    }
    onOnline() {
        this.observers.find(t => t.shouldFetchOnReconnect())?.refetch({
            cancelRefetch: !1
        }),
        this.#n?.continue()
    }
    addObserver(e) {
        this.observers.includes(e) || (this.observers.push(e),
        this.clearGcTimeout(),
        this.#r.notify({
            type: "observerAdded",
            query: this,
            observer: e
        }))
    }
    removeObserver(e) {
        this.observers.includes(e) && (this.observers = this.observers.filter(t => t !== e),
        this.observers.length || (this.#n && (this.#i ? this.#n.cancel({
            revert: !0
        }) : this.#n.cancelRetry()),
        this.scheduleGc()),
        this.#r.notify({
            type: "observerRemoved",
            query: this,
            observer: e
        }))
    }
    getObserversCount() {
        return this.observers.length
    }
    invalidate() {
        this.state.isInvalidated || this.#s({
            type: "invalidate"
        })
    }
    fetch(e, t) {
        if (this.state.fetchStatus !== "idle") {
            if (this.state.data !== void 0 && t?.cancelRefetch)
                this.cancel({
                    silent: !0
                });
            else if (this.#n)
                return this.#n.continueRetry(),
                this.#n.promise
        }
        if (e && this.setOptions(e),
        !this.options.queryFn) {
            const c = this.observers.find(f => f.options.queryFn);
            c && this.setOptions(c.options)
        }
        const n = new AbortController
          , s = c => {
            Object.defineProperty(c, "signal", {
                enumerable: !0,
                get: () => (this.#i = !0,
                n.signal)
            })
        }
          , o = () => {
            const c = gw(this.options, t)
              , f = {
                queryKey: this.queryKey,
                meta: this.meta
            };
            return s(f),
            this.#i = !1,
            this.options.persister ? this.options.persister(c, f, this) : c(f)
        }
          , a = {
            fetchOptions: t,
            options: this.options,
            queryKey: this.queryKey,
            state: this.state,
            fetchFn: o
        };
        s(a),
        this.options.behavior?.onFetch(a, this),
        this.#t = this.state,
        (this.state.fetchStatus === "idle" || this.state.fetchMeta !== a.fetchOptions?.meta) && this.#s({
            type: "fetch",
            meta: a.fetchOptions?.meta
        });
        const u = c => {
            If(c) && c.silent || this.#s({
                type: "error",
                error: c
            }),
            If(c) || (this.#r.config.onError?.(c, this),
            this.#r.config.onSettled?.(this.state.data, c, this)),
            this.scheduleGc()
        }
        ;
        return this.#n = xw({
            initialPromise: t?.initialPromise,
            fn: a.fetchFn,
            abort: n.abort.bind(n),
            onSuccess: c => {
                if (c === void 0) {
                    u(new Error(`${this.queryHash} data is undefined`));
                    return
                }
                try {
                    this.setData(c)
                } catch (f) {
                    u(f);
                    return
                }
                this.#r.config.onSuccess?.(c, this),
                this.#r.config.onSettled?.(c, this.state.error, this),
                this.scheduleGc()
            }
            ,
            onError: u,
            onFail: (c, f) => {
                this.#s({
                    type: "failed",
                    failureCount: c,
                    error: f
                })
            }
            ,
            onPause: () => {
                this.#s({
                    type: "pause"
                })
            }
            ,
            onContinue: () => {
                this.#s({
                    type: "continue"
                })
            }
            ,
            retry: a.options.retry,
            retryDelay: a.options.retryDelay,
            networkMode: a.options.networkMode,
            canRun: () => !0
        }),
        this.#n.start()
    }
    #s(e) {
        const t = n => {
            switch (e.type) {
            case "failed":
                return {
                    ...n,
                    fetchFailureCount: e.failureCount,
                    fetchFailureReason: e.error
                };
            case "pause":
                return {
                    ...n,
                    fetchStatus: "paused"
                };
            case "continue":
                return {
                    ...n,
                    fetchStatus: "fetching"
                };
            case "fetch":
                return {
                    ...n,
                    ...bw(n.data, this.options),
                    fetchMeta: e.meta ?? null
                };
            case "success":
                return {
                    ...n,
                    data: e.data,
                    dataUpdateCount: n.dataUpdateCount + 1,
                    dataUpdatedAt: e.dataUpdatedAt ?? Date.now(),
                    error: null,
                    isInvalidated: !1,
                    status: "success",
                    ...!e.manual && {
                        fetchStatus: "idle",
                        fetchFailureCount: 0,
                        fetchFailureReason: null
                    }
                };
            case "error":
                const s = e.error;
                return If(s) && s.revert && this.#t ? {
                    ...this.#t,
                    fetchStatus: "idle"
                } : {
                    ...n,
                    error: s,
                    errorUpdateCount: n.errorUpdateCount + 1,
                    errorUpdatedAt: Date.now(),
                    fetchFailureCount: n.fetchFailureCount + 1,
                    fetchFailureReason: s,
                    fetchStatus: "idle",
                    status: "error"
                };
            case "invalidate":
                return {
                    ...n,
                    isInvalidated: !0
                };
            case "setState":
                return {
                    ...n,
                    ...e.state
                }
            }
        }
        ;
        this.state = t(this.state),
        _t.batch( () => {
            this.observers.forEach(n => {
                n.onQueryUpdate()
            }
            ),
            this.#r.notify({
                query: this,
                type: "updated",
                action: e
            })
        }
        )
    }
}
;
function bw(e, t) {
    return {
        fetchFailureCount: 0,
        fetchFailureReason: null,
        fetchStatus: yw(t.networkMode) ? "fetching" : "paused",
        ...e === void 0 && {
            error: null,
            status: "pending"
        }
    }
}
function l_(e) {
    const t = typeof e.initialData == "function" ? e.initialData() : e.initialData
      , n = t !== void 0
      , s = n ? typeof e.initialDataUpdatedAt == "function" ? e.initialDataUpdatedAt() : e.initialDataUpdatedAt : 0;
    return {
        data: t,
        dataUpdateCount: 0,
        dataUpdatedAt: n ? s ?? Date.now() : 0,
        error: null,
        errorUpdateCount: 0,
        errorUpdatedAt: 0,
        fetchFailureCount: 0,
        fetchFailureReason: null,
        fetchMeta: null,
        isInvalidated: !1,
        status: n ? "success" : "pending",
        fetchStatus: "idle"
    }
}
var u_ = class extends lo {
    constructor(e={}) {
        super(),
        this.config = e,
        this.#e = new Map
    }
    #e;
    build(e, t, n) {
        const s = t.queryKey
          , o = t.queryHash ?? fp(s, t);
        let a = this.get(o);
        return a || (a = new a_({
            cache: this,
            queryKey: s,
            queryHash: o,
            options: e.defaultQueryOptions(t),
            state: n,
            defaultOptions: e.getQueryDefaults(s)
        }),
        this.add(a)),
        a
    }
    add(e) {
        this.#e.has(e.queryHash) || (this.#e.set(e.queryHash, e),
        this.notify({
            type: "added",
            query: e
        }))
    }
    remove(e) {
        const t = this.#e.get(e.queryHash);
        t && (e.destroy(),
        t === e && this.#e.delete(e.queryHash),
        this.notify({
            type: "removed",
            query: e
        }))
    }
    clear() {
        _t.batch( () => {
            this.getAll().forEach(e => {
                this.remove(e)
            }
            )
        }
        )
    }
    get(e) {
        return this.#e.get(e)
    }
    getAll() {
        return [...this.#e.values()]
    }
    find(e) {
        const t = {
            exact: !0,
            ...e
        };
        return this.getAll().find(n => Av(t, n))
    }
    findAll(e={}) {
        const t = this.getAll();
        return Object.keys(e).length > 0 ? t.filter(n => Av(e, n)) : t
    }
    notify(e) {
        _t.batch( () => {
            this.listeners.forEach(t => {
                t(e)
            }
            )
        }
        )
    }
    onFocus() {
        _t.batch( () => {
            this.getAll().forEach(e => {
                e.onFocus()
            }
            )
        }
        )
    }
    onOnline() {
        _t.batch( () => {
            this.getAll().forEach(e => {
                e.onOnline()
            }
            )
        }
        )
    }
}
  , c_ = class extends ww {
    #e;
    #t;
    #r;
    constructor(e) {
        super(),
        this.mutationId = e.mutationId,
        this.#t = e.mutationCache,
        this.#e = [],
        this.state = e.state || Sw(),
        this.setOptions(e.options),
        this.scheduleGc()
    }
    setOptions(e) {
        this.options = e,
        this.updateGcTime(this.options.gcTime)
    }
    get meta() {
        return this.options.meta
    }
    addObserver(e) {
        this.#e.includes(e) || (this.#e.push(e),
        this.clearGcTimeout(),
        this.#t.notify({
            type: "observerAdded",
            mutation: this,
            observer: e
        }))
    }
    removeObserver(e) {
        this.#e = this.#e.filter(t => t !== e),
        this.scheduleGc(),
        this.#t.notify({
            type: "observerRemoved",
            mutation: this,
            observer: e
        })
    }
    optionalRemove() {
        this.#e.length || (this.state.status === "pending" ? this.scheduleGc() : this.#t.remove(this))
    }
    continue() {
        return this.#r?.continue() ?? this.execute(this.state.variables)
    }
    async execute(e) {
        this.#r = xw({
            fn: () => this.options.mutationFn ? this.options.mutationFn(e) : Promise.reject(new Error("No mutationFn found")),
            onFail: (s, o) => {
                this.#n({
                    type: "failed",
                    failureCount: s,
                    error: o
                })
            }
            ,
            onPause: () => {
                this.#n({
                    type: "pause"
                })
            }
            ,
            onContinue: () => {
                this.#n({
                    type: "continue"
                })
            }
            ,
            retry: this.options.retry ?? 0,
            retryDelay: this.options.retryDelay,
            networkMode: this.options.networkMode,
            canRun: () => this.#t.canRun(this)
        });
        const t = this.state.status === "pending"
          , n = !this.#r.canStart();
        try {
            if (!t) {
                this.#n({
                    type: "pending",
                    variables: e,
                    isPaused: n
                }),
                await this.#t.config.onMutate?.(e, this);
                const o = await this.options.onMutate?.(e);
                o !== this.state.context && this.#n({
                    type: "pending",
                    context: o,
                    variables: e,
                    isPaused: n
                })
            }
            const s = await this.#r.start();
            return await this.#t.config.onSuccess?.(s, e, this.state.context, this),
            await this.options.onSuccess?.(s, e, this.state.context),
            await this.#t.config.onSettled?.(s, null, this.state.variables, this.state.context, this),
            await this.options.onSettled?.(s, null, e, this.state.context),
            this.#n({
                type: "success",
                data: s
            }),
            s
        } catch (s) {
            try {
                throw await this.#t.config.onError?.(s, e, this.state.context, this),
                await this.options.onError?.(s, e, this.state.context),
                await this.#t.config.onSettled?.(void 0, s, this.state.variables, this.state.context, this),
                await this.options.onSettled?.(void 0, s, e, this.state.context),
                s
            } finally {
                this.#n({
                    type: "error",
                    error: s
                })
            }
        } finally {
            this.#t.runNext(this)
        }
    }
    #n(e) {
        const t = n => {
            switch (e.type) {
            case "failed":
                return {
                    ...n,
                    failureCount: e.failureCount,
                    failureReason: e.error
                };
            case "pause":
                return {
                    ...n,
                    isPaused: !0
                };
            case "continue":
                return {
                    ...n,
                    isPaused: !1
                };
            case "pending":
                return {
                    ...n,
                    context: e.context,
                    data: void 0,
                    failureCount: 0,
                    failureReason: null,
                    error: null,
                    isPaused: e.isPaused,
                    status: "pending",
                    variables: e.variables,
                    submittedAt: Date.now()
                };
            case "success":
                return {
                    ...n,
                    data: e.data,
                    failureCount: 0,
                    failureReason: null,
                    error: null,
                    status: "success",
                    isPaused: !1
                };
            case "error":
                return {
                    ...n,
                    data: void 0,
                    error: e.error,
                    failureCount: n.failureCount + 1,
                    failureReason: e.error,
                    isPaused: !1,
                    status: "error"
                }
            }
        }
        ;
        this.state = t(this.state),
        _t.batch( () => {
            this.#e.forEach(n => {
                n.onMutationUpdate(e)
            }
            ),
            this.#t.notify({
                mutation: this,
                type: "updated",
                action: e
            })
        }
        )
    }
}
;
function Sw() {
    return {
        context: void 0,
        data: void 0,
        error: null,
        failureCount: 0,
        failureReason: null,
        isPaused: !1,
        status: "idle",
        variables: void 0,
        submittedAt: 0
    }
}
var d_ = class extends lo {
    constructor(e={}) {
        super(),
        this.config = e,
        this.#e = new Map,
        this.#t = Date.now()
    }
    #e;
    #t;
    build(e, t, n) {
        const s = new c_({
            mutationCache: this,
            mutationId: ++this.#t,
            options: e.defaultMutationOptions(t),
            state: n
        });
        return this.add(s),
        s
    }
    add(e) {
        const t = hu(e)
          , n = this.#e.get(t) ?? [];
        n.push(e),
        this.#e.set(t, n),
        this.notify({
            type: "added",
            mutation: e
        })
    }
    remove(e) {
        const t = hu(e);
        if (this.#e.has(t)) {
            const n = this.#e.get(t)?.filter(s => s !== e);
            n && (n.length === 0 ? this.#e.delete(t) : this.#e.set(t, n))
        }
        this.notify({
            type: "removed",
            mutation: e
        })
    }
    canRun(e) {
        const t = this.#e.get(hu(e))?.find(n => n.state.status === "pending");
        return !t || t === e
    }
    runNext(e) {
        return this.#e.get(hu(e))?.find(n => n !== e && n.state.isPaused)?.continue() ?? Promise.resolve()
    }
    clear() {
        _t.batch( () => {
            this.getAll().forEach(e => {
                this.remove(e)
            }
            )
        }
        )
    }
    getAll() {
        return [...this.#e.values()].flat()
    }
    find(e) {
        const t = {
            exact: !0,
            ...e
        };
        return this.getAll().find(n => Rv(t, n))
    }
    findAll(e={}) {
        return this.getAll().filter(t => Rv(e, t))
    }
    notify(e) {
        _t.batch( () => {
            this.listeners.forEach(t => {
                t(e)
            }
            )
        }
        )
    }
    resumePausedMutations() {
        const e = this.getAll().filter(t => t.state.isPaused);
        return _t.batch( () => Promise.all(e.map(t => t.continue().catch(_n))))
    }
}
;
function hu(e) {
    return e.options.scope?.id ?? String(e.mutationId)
}
function Ov(e) {
    return {
        onFetch: (t, n) => {
            const s = t.options
              , o = t.fetchOptions?.meta?.fetchMore?.direction
              , a = t.state.data?.pages || []
              , u = t.state.data?.pageParams || [];
            let c = {
                pages: [],
                pageParams: []
            }
              , f = 0;
            const h = async () => {
                let m = !1;
                const v = C => {
                    Object.defineProperty(C, "signal", {
                        enumerable: !0,
                        get: () => (t.signal.aborted ? m = !0 : t.signal.addEventListener("abort", () => {
                            m = !0
                        }
                        ),
                        t.signal)
                    })
                }
                  , x = gw(t.options, t.fetchOptions)
                  , T = async (C, S, P) => {
                    if (m)
                        return Promise.reject();
                    if (S == null && C.pages.length)
                        return Promise.resolve(C);
                    const _ = {
                        queryKey: t.queryKey,
                        pageParam: S,
                        direction: P ? "backward" : "forward",
                        meta: t.options.meta
                    };
                    v(_);
                    const k = await x(_)
                      , {maxPages: j} = t.options
                      , M = P ? n_ : t_;
                    return {
                        pages: M(C.pages, k, j),
                        pageParams: M(C.pageParams, S, j)
                    }
                }
                ;
                if (o && a.length) {
                    const C = o === "backward"
                      , S = C ? f_ : Mv
                      , P = {
                        pages: a,
                        pageParams: u
                    }
                      , _ = S(s, P);
                    c = await T(P, _, C)
                } else {
                    const C = e ?? a.length;
                    do {
                        const S = f === 0 ? u[0] ?? s.initialPageParam : Mv(s, c);
                        if (f > 0 && S == null)
                            break;
                        c = await T(c, S),
                        f++
                    } while (f < C)
                }
                return c
            }
            ;
            t.options.persister ? t.fetchFn = () => t.options.persister?.(h, {
                queryKey: t.queryKey,
                meta: t.options.meta,
                signal: t.signal
            }, n) : t.fetchFn = h
        }
    }
}
function Mv(e, {pages: t, pageParams: n}) {
    const s = t.length - 1;
    return t.length > 0 ? e.getNextPageParam(t[s], t, n[s], n) : void 0
}
function f_(e, {pages: t, pageParams: n}) {
    return t.length > 0 ? e.getPreviousPageParam?.(t[0], t, n[0], n) : void 0
}
var h_ = class {
    #e;
    #t;
    #r;
    #n;
    #o;
    #i;
    #s;
    #a;
    constructor(e={}) {
        this.#e = e.queryCache || new u_,
        this.#t = e.mutationCache || new d_,
        this.#r = e.defaultOptions || {},
        this.#n = new Map,
        this.#o = new Map,
        this.#i = 0
    }
    mount() {
        this.#i++,
        this.#i === 1 && (this.#s = pp.subscribe(async e => {
            e && (await this.resumePausedMutations(),
            this.#e.onFocus())
        }
        ),
        this.#a = Iu.subscribe(async e => {
            e && (await this.resumePausedMutations(),
            this.#e.onOnline())
        }
        ))
    }
    unmount() {
        this.#i--,
        this.#i === 0 && (this.#s?.(),
        this.#s = void 0,
        this.#a?.(),
        this.#a = void 0)
    }
    isFetching(e) {
        return this.#e.findAll({
            ...e,
            fetchStatus: "fetching"
        }).length
    }
    isMutating(e) {
        return this.#t.findAll({
            ...e,
            status: "pending"
        }).length
    }
    getQueryData(e) {
        const t = this.defaultQueryOptions({
            queryKey: e
        });
        return this.#e.get(t.queryHash)?.state.data
    }
    ensureQueryData(e) {
        const t = this.getQueryData(e.queryKey);
        if (t === void 0)
            return this.fetchQuery(e);
        {
            const n = this.defaultQueryOptions(e)
              , s = this.#e.build(this, n);
            return e.revalidateIfStale && s.isStaleByTime(qi(n.staleTime, s)) && this.prefetchQuery(n),
            Promise.resolve(t)
        }
    }
    getQueriesData(e) {
        return this.#e.findAll(e).map( ({queryKey: t, state: n}) => {
            const s = n.data;
            return [t, s]
        }
        )
    }
    setQueryData(e, t, n) {
        const s = this.defaultQueryOptions({
            queryKey: e
        })
          , a = this.#e.get(s.queryHash)?.state.data
          , u = JE(t, a);
        if (u !== void 0)
            return this.#e.build(this, s).setData(u, {
                ...n,
                manual: !0
            })
    }
    setQueriesData(e, t, n) {
        return _t.batch( () => this.#e.findAll(e).map( ({queryKey: s}) => [s, this.setQueryData(s, t, n)]))
    }
    getQueryState(e) {
        const t = this.defaultQueryOptions({
            queryKey: e
        });
        return this.#e.get(t.queryHash)?.state
    }
    removeQueries(e) {
        const t = this.#e;
        _t.batch( () => {
            t.findAll(e).forEach(n => {
                t.remove(n)
            }
            )
        }
        )
    }
    resetQueries(e, t) {
        const n = this.#e
          , s = {
            type: "active",
            ...e
        };
        return _t.batch( () => (n.findAll(e).forEach(o => {
            o.reset()
        }
        ),
        this.refetchQueries(s, t)))
    }
    cancelQueries(e={}, t={}) {
        const n = {
            revert: !0,
            ...t
        }
          , s = _t.batch( () => this.#e.findAll(e).map(o => o.cancel(n)));
        return Promise.all(s).then(_n).catch(_n)
    }
    invalidateQueries(e={}, t={}) {
        return _t.batch( () => {
            if (this.#e.findAll(e).forEach(s => {
                s.invalidate()
            }
            ),
            e.refetchType === "none")
                return Promise.resolve();
            const n = {
                ...e,
                type: e.refetchType ?? e.type ?? "active"
            };
            return this.refetchQueries(n, t)
        }
        )
    }
    refetchQueries(e={}, t) {
        const n = {
            ...t,
            cancelRefetch: t?.cancelRefetch ?? !0
        }
          , s = _t.batch( () => this.#e.findAll(e).filter(o => !o.isDisabled()).map(o => {
            let a = o.fetch(void 0, n);
            return n.throwOnError || (a = a.catch(_n)),
            o.state.fetchStatus === "paused" ? Promise.resolve() : a
        }
        ));
        return Promise.all(s).then(_n)
    }
    fetchQuery(e) {
        const t = this.defaultQueryOptions(e);
        t.retry === void 0 && (t.retry = !1);
        const n = this.#e.build(this, t);
        return n.isStaleByTime(qi(t.staleTime, n)) ? n.fetch(t) : Promise.resolve(n.state.data)
    }
    prefetchQuery(e) {
        return this.fetchQuery(e).then(_n).catch(_n)
    }
    fetchInfiniteQuery(e) {
        return e.behavior = Ov(e.pages),
        this.fetchQuery(e)
    }
    prefetchInfiniteQuery(e) {
        return this.fetchInfiniteQuery(e).then(_n).catch(_n)
    }
    ensureInfiniteQueryData(e) {
        return e.behavior = Ov(e.pages),
        this.ensureQueryData(e)
    }
    resumePausedMutations() {
        return Iu.isOnline() ? this.#t.resumePausedMutations() : Promise.resolve()
    }
    getQueryCache() {
        return this.#e
    }
    getMutationCache() {
        return this.#t
    }
    getDefaultOptions() {
        return this.#r
    }
    setDefaultOptions(e) {
        this.#r = e
    }
    setQueryDefaults(e, t) {
        this.#n.set(Qs(e), {
            queryKey: e,
            defaultOptions: t
        })
    }
    getQueryDefaults(e) {
        const t = [...this.#n.values()];
        let n = {};
        return t.forEach(s => {
            Ta(e, s.queryKey) && (n = {
                ...n,
                ...s.defaultOptions
            })
        }
        ),
        n
    }
    setMutationDefaults(e, t) {
        this.#o.set(Qs(e), {
            mutationKey: e,
            defaultOptions: t
        })
    }
    getMutationDefaults(e) {
        const t = [...this.#o.values()];
        let n = {};
        return t.forEach(s => {
            Ta(e, s.mutationKey) && (n = {
                ...n,
                ...s.defaultOptions
            })
        }
        ),
        n
    }
    defaultQueryOptions(e) {
        if (e._defaulted)
            return e;
        const t = {
            ...this.#r.queries,
            ...this.getQueryDefaults(e.queryKey),
            ...e,
            _defaulted: !0
        };
        return t.queryHash || (t.queryHash = fp(t.queryKey, t)),
        t.refetchOnReconnect === void 0 && (t.refetchOnReconnect = t.networkMode !== "always"),
        t.throwOnError === void 0 && (t.throwOnError = !!t.suspense),
        !t.networkMode && t.persister && (t.networkMode = "offlineFirst"),
        t.enabled !== !0 && t.queryFn === hp && (t.enabled = !1),
        t
    }
    defaultMutationOptions(e) {
        return e?._defaulted ? e : {
            ...this.#r.mutations,
            ...e?.mutationKey && this.getMutationDefaults(e.mutationKey),
            ...e,
            _defaulted: !0
        }
    }
    clear() {
        this.#e.clear(),
        this.#t.clear()
    }
}
  , p_ = class extends lo {
    constructor(e, t) {
        super(),
        this.options = t,
        this.#e = e,
        this.#a = null,
        this.#s = Sh(),
        this.options.experimental_prefetchInRender || this.#s.reject(new Error("experimental_prefetchInRender feature flag is not enabled")),
        this.bindMethods(),
        this.setOptions(t)
    }
    #e;
    #t = void 0;
    #r = void 0;
    #n = void 0;
    #o;
    #i;
    #s;
    #a;
    #m;
    #f;
    #h;
    #u;
    #c;
    #l;
    #p = new Set;
    bindMethods() {
        this.refetch = this.refetch.bind(this)
    }
    onSubscribe() {
        this.listeners.size === 1 && (this.#t.addObserver(this),
        Iv(this.#t, this.options) ? this.#d() : this.updateResult(),
        this.#x())
    }
    onUnsubscribe() {
        this.hasListeners() || this.destroy()
    }
    shouldFetchOnReconnect() {
        return Th(this.#t, this.options, this.options.refetchOnReconnect)
    }
    shouldFetchOnWindowFocus() {
        return Th(this.#t, this.options, this.options.refetchOnWindowFocus)
    }
    destroy() {
        this.listeners = new Set,
        this.#w(),
        this.#b(),
        this.#t.removeObserver(this)
    }
    setOptions(e, t) {
        const n = this.options
          , s = this.#t;
        if (this.options = this.#e.defaultQueryOptions(e),
        this.options.enabled !== void 0 && typeof this.options.enabled != "boolean" && typeof this.options.enabled != "function" && typeof Ln(this.options.enabled, this.#t) != "boolean")
            throw new Error("Expected enabled to be a boolean or a callback that returns a boolean");
        this.#S(),
        this.#t.setOptions(this.options),
        n._defaulted && !Mu(this.options, n) && this.#e.getQueryCache().notify({
            type: "observerOptionsUpdated",
            query: this.#t,
            observer: this
        });
        const o = this.hasListeners();
        o && Fv(this.#t, s, this.options, n) && this.#d(),
        this.updateResult(t),
        o && (this.#t !== s || Ln(this.options.enabled, this.#t) !== Ln(n.enabled, this.#t) || qi(this.options.staleTime, this.#t) !== qi(n.staleTime, this.#t)) && this.#g();
        const a = this.#y();
        o && (this.#t !== s || Ln(this.options.enabled, this.#t) !== Ln(n.enabled, this.#t) || a !== this.#l) && this.#v(a)
    }
    getOptimisticResult(e) {
        const t = this.#e.getQueryCache().build(this.#e, e)
          , n = this.createResult(t, e);
        return g_(this, n) && (this.#n = n,
        this.#i = this.options,
        this.#o = this.#t.state),
        n
    }
    getCurrentResult() {
        return this.#n
    }
    trackResult(e, t) {
        const n = {};
        return Object.keys(e).forEach(s => {
            Object.defineProperty(n, s, {
                configurable: !1,
                enumerable: !0,
                get: () => (this.trackProp(s),
                t?.(s),
                e[s])
            })
        }
        ),
        n
    }
    trackProp(e) {
        this.#p.add(e)
    }
    getCurrentQuery() {
        return this.#t
    }
    refetch({...e}={}) {
        return this.fetch({
            ...e
        })
    }
    fetchOptimistic(e) {
        const t = this.#e.defaultQueryOptions(e)
          , n = this.#e.getQueryCache().build(this.#e, t);
        return n.fetch().then( () => this.createResult(n, t))
    }
    fetch(e) {
        return this.#d({
            ...e,
            cancelRefetch: e.cancelRefetch ?? !0
        }).then( () => (this.updateResult(),
        this.#n))
    }
    #d(e) {
        this.#S();
        let t = this.#t.fetch(this.options, e);
        return e?.throwOnError || (t = t.catch(_n)),
        t
    }
    #g() {
        this.#w();
        const e = qi(this.options.staleTime, this.#t);
        if (qs || this.#n.isStale || !xh(e))
            return;
        const n = pw(this.#n.dataUpdatedAt, e) + 1;
        this.#u = setTimeout( () => {
            this.#n.isStale || this.updateResult()
        }
        , n)
    }
    #y() {
        return (typeof this.options.refetchInterval == "function" ? this.options.refetchInterval(this.#t) : this.options.refetchInterval) ?? !1
    }
    #v(e) {
        this.#b(),
        this.#l = e,
        !(qs || Ln(this.options.enabled, this.#t) === !1 || !xh(this.#l) || this.#l === 0) && (this.#c = setInterval( () => {
            (this.options.refetchIntervalInBackground || pp.isFocused()) && this.#d()
        }
        , this.#l))
    }
    #x() {
        this.#g(),
        this.#v(this.#y())
    }
    #w() {
        this.#u && (clearTimeout(this.#u),
        this.#u = void 0)
    }
    #b() {
        this.#c && (clearInterval(this.#c),
        this.#c = void 0)
    }
    createResult(e, t) {
        const n = this.#t
          , s = this.options
          , o = this.#n
          , a = this.#o
          , u = this.#i
          , f = e !== n ? e.state : this.#r
          , {state: h} = e;
        let m = {
            ...h
        }, v = !1, x;
        if (t._optimisticResults) {
            const U = this.hasListeners()
              , W = !U && Iv(e, t)
              , oe = U && Fv(e, n, t, s);
            (W || oe) && (m = {
                ...m,
                ...bw(h.data, e.options)
            }),
            t._optimisticResults === "isRestoring" && (m.fetchStatus = "idle")
        }
        let {error: T, errorUpdatedAt: C, status: S} = m;
        if (t.select && m.data !== void 0)
            if (o && m.data === a?.data && t.select === this.#m)
                x = this.#f;
            else
                try {
                    this.#m = t.select,
                    x = t.select(m.data),
                    x = bh(o?.data, x, t),
                    this.#f = x,
                    this.#a = null
                } catch (U) {
                    this.#a = U
                }
        else
            x = m.data;
        if (t.placeholderData !== void 0 && x === void 0 && S === "pending") {
            let U;
            if (o?.isPlaceholderData && t.placeholderData === u?.placeholderData)
                U = o.data;
            else if (U = typeof t.placeholderData == "function" ? t.placeholderData(this.#h?.state.data, this.#h) : t.placeholderData,
            t.select && U !== void 0)
                try {
                    U = t.select(U),
                    this.#a = null
                } catch (W) {
                    this.#a = W
                }
            U !== void 0 && (S = "success",
            x = bh(o?.data, U, t),
            v = !0)
        }
        this.#a && (T = this.#a,
        x = this.#f,
        C = Date.now(),
        S = "error");
        const P = m.fetchStatus === "fetching"
          , _ = S === "pending"
          , k = S === "error"
          , j = _ && P
          , M = x !== void 0
          , z = {
            status: S,
            fetchStatus: m.fetchStatus,
            isPending: _,
            isSuccess: S === "success",
            isError: k,
            isInitialLoading: j,
            isLoading: j,
            data: x,
            dataUpdatedAt: m.dataUpdatedAt,
            error: T,
            errorUpdatedAt: C,
            failureCount: m.fetchFailureCount,
            failureReason: m.fetchFailureReason,
            errorUpdateCount: m.errorUpdateCount,
            isFetched: m.dataUpdateCount > 0 || m.errorUpdateCount > 0,
            isFetchedAfterMount: m.dataUpdateCount > f.dataUpdateCount || m.errorUpdateCount > f.errorUpdateCount,
            isFetching: P,
            isRefetching: P && !_,
            isLoadingError: k && !M,
            isPaused: m.fetchStatus === "paused",
            isPlaceholderData: v,
            isRefetchError: k && M,
            isStale: mp(e, t),
            refetch: this.refetch,
            promise: this.#s
        };
        if (this.options.experimental_prefetchInRender) {
            const U = fe => {
                z.status === "error" ? fe.reject(z.error) : z.data !== void 0 && fe.resolve(z.data)
            }
              , W = () => {
                const fe = this.#s = z.promise = Sh();
                U(fe)
            }
              , oe = this.#s;
            switch (oe.status) {
            case "pending":
                e.queryHash === n.queryHash && U(oe);
                break;
            case "fulfilled":
                (z.status === "error" || z.data !== oe.value) && W();
                break;
            case "rejected":
                (z.status !== "error" || z.error !== oe.reason) && W();
                break
            }
        }
        return z
    }
    updateResult(e) {
        const t = this.#n
          , n = this.createResult(this.#t, this.options);
        if (this.#o = this.#t.state,
        this.#i = this.options,
        this.#o.data !== void 0 && (this.#h = this.#t),
        Mu(n, t))
            return;
        this.#n = n;
        const s = {}
          , o = () => {
            if (!t)
                return !0;
            const {notifyOnChangeProps: a} = this.options
              , u = typeof a == "function" ? a() : a;
            if (u === "all" || !u && !this.#p.size)
                return !0;
            const c = new Set(u ?? this.#p);
            return this.options.throwOnError && c.add("error"),
            Object.keys(this.#n).some(f => {
                const h = f;
                return this.#n[h] !== t[h] && c.has(h)
            }
            )
        }
        ;
        e?.listeners !== !1 && o() && (s.listeners = !0),
        this.#T({
            ...s,
            ...e
        })
    }
    #S() {
        const e = this.#e.getQueryCache().build(this.#e, this.options);
        if (e === this.#t)
            return;
        const t = this.#t;
        this.#t = e,
        this.#r = e.state,
        this.hasListeners() && (t?.removeObserver(this),
        e.addObserver(this))
    }
    onQueryUpdate() {
        this.updateResult(),
        this.hasListeners() && this.#x()
    }
    #T(e) {
        _t.batch( () => {
            e.listeners && this.listeners.forEach(t => {
                t(this.#n)
            }
            ),
            this.#e.getQueryCache().notify({
                query: this.#t,
                type: "observerResultsUpdated"
            })
        }
        )
    }
}
;
function m_(e, t) {
    return Ln(t.enabled, e) !== !1 && e.state.data === void 0 && !(e.state.status === "error" && t.retryOnMount === !1)
}
function Iv(e, t) {
    return m_(e, t) || e.state.data !== void 0 && Th(e, t, t.refetchOnMount)
}
function Th(e, t, n) {
    if (Ln(t.enabled, e) !== !1) {
        const s = typeof n == "function" ? n(e) : n;
        return s === "always" || s !== !1 && mp(e, t)
    }
    return !1
}
function Fv(e, t, n, s) {
    return (e !== t || Ln(s.enabled, e) === !1) && (!n.suspense || e.state.status !== "error") && mp(e, n)
}
function mp(e, t) {
    return Ln(t.enabled, e) !== !1 && e.isStaleByTime(qi(t.staleTime, e))
}
function g_(e, t) {
    return !Mu(e.getCurrentResult(), t)
}
var y_ = class extends lo {
    #e;
    #t = void 0;
    #r;
    #n;
    constructor(t, n) {
        super(),
        this.#e = t,
        this.setOptions(n),
        this.bindMethods(),
        this.#o()
    }
    bindMethods() {
        this.mutate = this.mutate.bind(this),
        this.reset = this.reset.bind(this)
    }
    setOptions(t) {
        const n = this.options;
        this.options = this.#e.defaultMutationOptions(t),
        Mu(this.options, n) || this.#e.getMutationCache().notify({
            type: "observerOptionsUpdated",
            mutation: this.#r,
            observer: this
        }),
        n?.mutationKey && this.options.mutationKey && Qs(n.mutationKey) !== Qs(this.options.mutationKey) ? this.reset() : this.#r?.state.status === "pending" && this.#r.setOptions(this.options)
    }
    onUnsubscribe() {
        this.hasListeners() || this.#r?.removeObserver(this)
    }
    onMutationUpdate(t) {
        this.#o(),
        this.#i(t)
    }
    getCurrentResult() {
        return this.#t
    }
    reset() {
        this.#r?.removeObserver(this),
        this.#r = void 0,
        this.#o(),
        this.#i()
    }
    mutate(t, n) {
        return this.#n = n,
        this.#r?.removeObserver(this),
        this.#r = this.#e.getMutationCache().build(this.#e, this.options),
        this.#r.addObserver(this),
        this.#r.execute(t)
    }
    #o() {
        const t = this.#r?.state ?? Sw();
        this.#t = {
            ...t,
            isPending: t.status === "pending",
            isSuccess: t.status === "success",
            isError: t.status === "error",
            isIdle: t.status === "idle",
            mutate: this.mutate,
            reset: this.reset
        }
    }
    #i(t) {
        _t.batch( () => {
            if (this.#n && this.hasListeners()) {
                const n = this.#t.variables
                  , s = this.#t.context;
                t?.type === "success" ? (this.#n.onSuccess?.(t.data, n, s),
                this.#n.onSettled?.(t.data, null, n, s)) : t?.type === "error" && (this.#n.onError?.(t.error, n, s),
                this.#n.onSettled?.(void 0, t.error, n, s))
            }
            this.listeners.forEach(n => {
                n(this.#t)
            }
            )
        }
        )
    }
}
  , Tw = w.createContext(void 0)
  , uo = e => {
    const t = w.useContext(Tw);
    if (!t)
        throw new Error("No QueryClient set, use QueryClientProvider to set one");
    return t
}
  , v_ = ({client: e, children: t}) => (w.useEffect( () => (e.mount(),
() => {
    e.unmount()
}
), [e]),
y.jsx(Tw.Provider, {
    value: e,
    children: t
}))
  , Pw = w.createContext(!1)
  , x_ = () => w.useContext(Pw);
Pw.Provider;
function w_() {
    let e = !1;
    return {
        clearReset: () => {
            e = !1
        }
        ,
        reset: () => {
            e = !0
        }
        ,
        isReset: () => e
    }
}
var b_ = w.createContext(w_())
  , S_ = () => w.useContext(b_);
function Cw(e, t) {
    return typeof e == "function" ? e(...t) : !!e
}
function Ph() {}
var T_ = (e, t) => {
    (e.suspense || e.throwOnError || e.experimental_prefetchInRender) && (t.isReset() || (e.retryOnMount = !1))
}
  , P_ = e => {
    w.useEffect( () => {
        e.clearReset()
    }
    , [e])
}
  , C_ = ({result: e, errorResetBoundary: t, throwOnError: n, query: s}) => e.isError && !t.isReset() && !e.isFetching && s && Cw(n, [e.error, s])
  , E_ = e => {
    e.suspense && (e.staleTime === void 0 && (e.staleTime = 1e3),
    typeof e.gcTime == "number" && (e.gcTime = Math.max(e.gcTime, 1e3)))
}
  , __ = (e, t) => e.isLoading && e.isFetching && !t
  , k_ = (e, t) => e?.suspense && t.isPending
  , Lv = (e, t, n) => t.fetchOptimistic(e).catch( () => {
    n.clearReset()
}
);
function N_(e, t, n) {
    const s = uo()
      , o = x_()
      , a = S_()
      , u = s.defaultQueryOptions(e);
    s.getDefaultOptions().queries?._experimental_beforeQuery?.(u),
    u._optimisticResults = o ? "isRestoring" : "optimistic",
    E_(u),
    T_(u, a),
    P_(a);
    const c = !s.getQueryCache().get(u.queryHash)
      , [f] = w.useState( () => new t(s,u))
      , h = f.getOptimisticResult(u);
    if (w.useSyncExternalStore(w.useCallback(m => {
        const v = o ? Ph : f.subscribe(_t.batchCalls(m));
        return f.updateResult(),
        v
    }
    , [f, o]), () => f.getCurrentResult(), () => f.getCurrentResult()),
    w.useEffect( () => {
        f.setOptions(u, {
            listeners: !1
        })
    }
    , [u, f]),
    k_(u, h))
        throw Lv(u, f, a);
    if (C_({
        result: h,
        errorResetBoundary: a,
        throwOnError: u.throwOnError,
        query: s.getQueryCache().get(u.queryHash)
    }))
        throw h.error;
    return s.getDefaultOptions().queries?._experimental_afterQuery?.(u, h),
    u.experimental_prefetchInRender && !qs && __(h, o) && (c ? Lv(u, f, a) : s.getQueryCache().get(u.queryHash)?.promise)?.catch(Ph).finally( () => {
        f.updateResult()
    }
    ),
    u.notifyOnChangeProps ? h : f.trackResult(h)
}
function cc(e, t) {
    return N_(e, p_)
}
function dc(e, t) {
    const n = uo()
      , [s] = w.useState( () => new y_(n,e));
    w.useEffect( () => {
        s.setOptions(e)
    }
    , [s, e]);
    const o = w.useSyncExternalStore(w.useCallback(u => s.subscribe(_t.batchCalls(u)), [s]), () => s.getCurrentResult(), () => s.getCurrentResult())
      , a = w.useCallback( (u, c) => {
        s.mutate(u, c).catch(Ph)
    }
    , [s]);
    if (o.error && Cw(s.options.throwOnError, [o.error]))
        throw o.error;
    return {
        ...o,
        mutate: a,
        mutateAsync: o.mutate
    }
}
async function A_(e) {
    if (!e.ok) {
        const t = await e.text() || e.statusText;
        throw new Error(`${e.status}: ${t}`)
    }
}
const R_ = ({on401: e}) => async ({queryKey: t}) => {
    const n = await fetch(t.join("/"), {
        credentials: "include"
    });
    return await A_(n),
    await n.json()
}
  , j_ = new h_({
    defaultOptions: {
        queries: {
            queryFn: R_({
                on401: "throw"
            }),
            refetchInterval: !1,
            refetchOnWindowFocus: !1,
            staleTime: 1 / 0,
            retry: !1
        },
        mutations: {
            retry: !1
        }
    }
})
  , D_ = 1
  , O_ = 1e6;
let Ff = 0;
function M_() {
    return Ff = (Ff + 1) % Number.MAX_SAFE_INTEGER,
    Ff.toString()
}
const Lf = new Map
  , Vv = e => {
    if (Lf.has(e))
        return;
    const t = setTimeout( () => {
        Lf.delete(e),
        ma({
            type: "REMOVE_TOAST",
            toastId: e
        })
    }
    , O_);
    Lf.set(e, t)
}
  , I_ = (e, t) => {
    switch (t.type) {
    case "ADD_TOAST":
        return {
            ...e,
            toasts: [t.toast, ...e.toasts].slice(0, D_)
        };
    case "UPDATE_TOAST":
        return {
            ...e,
            toasts: e.toasts.map(n => n.id === t.toast.id ? {
                ...n,
                ...t.toast
            } : n)
        };
    case "DISMISS_TOAST":
        {
            const {toastId: n} = t;
            return n ? Vv(n) : e.toasts.forEach(s => {
                Vv(s.id)
            }
            ),
            {
                ...e,
                toasts: e.toasts.map(s => s.id === n || n === void 0 ? {
                    ...s,
                    open: !1
                } : s)
            }
        }
    case "REMOVE_TOAST":
        return t.toastId === void 0 ? {
            ...e,
            toasts: []
        } : {
            ...e,
            toasts: e.toasts.filter(n => n.id !== t.toastId)
        }
    }
}
  , Cu = [];
let Eu = {
    toasts: []
};
function ma(e) {
    Eu = I_(Eu, e),
    Cu.forEach(t => {
        t(Eu)
    }
    )
}
function F_({...e}) {
    const t = M_()
      , n = o => ma({
        type: "UPDATE_TOAST",
        toast: {
            ...o,
            id: t
        }
    })
      , s = () => ma({
        type: "DISMISS_TOAST",
        toastId: t
    });
    return ma({
        type: "ADD_TOAST",
        toast: {
            ...e,
            id: t,
            open: !0,
            onOpenChange: o => {
                o || s()
            }
        }
    }),
    {
        id: t,
        dismiss: s,
        update: n
    }
}
function gp() {
    const [e,t] = w.useState(Eu);
    return w.useEffect( () => (Cu.push(t),
    () => {
        const n = Cu.indexOf(t);
        n > -1 && Cu.splice(n, 1)
    }
    ), [e]),
    {
        ...e,
        toast: F_,
        dismiss: n => ma({
            type: "DISMISS_TOAST",
            toastId: n
        })
    }
}
var fc = sw();
const L_ = rw(fc);
function We(e, t, {checkForDefaultPrevented: n=!0}={}) {
    return function(o) {
        if (e?.(o),
        n === !1 || !o.defaultPrevented)
            return t?.(o)
    }
}
function Bv(e, t) {
    if (typeof e == "function")
        return e(t);
    e != null && (e.current = t)
}
function Ew(...e) {
    return t => {
        let n = !1;
        const s = e.map(o => {
            const a = Bv(o, t);
            return !n && typeof a == "function" && (n = !0),
            a
        }
        );
        if (n)
            return () => {
                for (let o = 0; o < s.length; o++) {
                    const a = s[o];
                    typeof a == "function" ? a() : Bv(e[o], null)
                }
            }
    }
}
function qt(...e) {
    return w.useCallback(Ew(...e), e)
}
function V_(e, t) {
    const n = w.createContext(t)
      , s = a => {
        const {children: u, ...c} = a
          , f = w.useMemo( () => c, Object.values(c));
        return y.jsx(n.Provider, {
            value: f,
            children: u
        })
    }
    ;
    s.displayName = e + "Provider";
    function o(a) {
        const u = w.useContext(n);
        if (u)
            return u;
        if (t !== void 0)
            return t;
        throw new Error(`\`${a}\` must be used within \`${e}\``)
    }
    return [s, o]
}
function ei(e, t=[]) {
    let n = [];
    function s(a, u) {
        const c = w.createContext(u)
          , f = n.length;
        n = [...n, u];
        const h = v => {
            const {scope: x, children: T, ...C} = v
              , S = x?.[e]?.[f] || c
              , P = w.useMemo( () => C, Object.values(C));
            return y.jsx(S.Provider, {
                value: P,
                children: T
            })
        }
        ;
        h.displayName = a + "Provider";
        function m(v, x) {
            const T = x?.[e]?.[f] || c
              , C = w.useContext(T);
            if (C)
                return C;
            if (u !== void 0)
                return u;
            throw new Error(`\`${v}\` must be used within \`${a}\``)
        }
        return [h, m]
    }
    const o = () => {
        const a = n.map(u => w.createContext(u));
        return function(c) {
            const f = c?.[e] || a;
            return w.useMemo( () => ({
                [`__scope${e}`]: {
                    ...c,
                    [e]: f
                }
            }), [c, f])
        }
    }
    ;
    return o.scopeName = e,
    [s, B_(o, ...t)]
}
function B_(...e) {
    const t = e[0];
    if (e.length === 1)
        return t;
    const n = () => {
        const s = e.map(o => ({
            useScope: o(),
            scopeName: o.scopeName
        }));
        return function(a) {
            const u = s.reduce( (c, {useScope: f, scopeName: h}) => {
                const v = f(a)[`__scope${h}`];
                return {
                    ...c,
                    ...v
                }
            }
            , {});
            return w.useMemo( () => ({
                [`__scope${t.scopeName}`]: u
            }), [u])
        }
    }
    ;
    return n.scopeName = t.scopeName,
    n
}
function Pa(e) {
    const t = z_(e)
      , n = w.forwardRef( (s, o) => {
        const {children: a, ...u} = s
          , c = w.Children.toArray(a)
          , f = c.find($_);
        if (f) {
            const h = f.props.children
              , m = c.map(v => v === f ? w.Children.count(h) > 1 ? w.Children.only(null) : w.isValidElement(h) ? h.props.children : null : v);
            return y.jsx(t, {
                ...u,
                ref: o,
                children: w.isValidElement(h) ? w.cloneElement(h, void 0, m) : null
            })
        }
        return y.jsx(t, {
            ...u,
            ref: o,
            children: a
        })
    }
    );
    return n.displayName = `${e}.Slot`,
    n
}
var _w = Pa("Slot");
function z_(e) {
    const t = w.forwardRef( (n, s) => {
        const {children: o, ...a} = n;
        if (w.isValidElement(o)) {
            const u = H_(o)
              , c = W_(a, o.props);
            return o.type !== w.Fragment && (c.ref = s ? Ew(s, u) : u),
            w.cloneElement(o, c)
        }
        return w.Children.count(o) > 1 ? w.Children.only(null) : null
    }
    );
    return t.displayName = `${e}.SlotClone`,
    t
}
var kw = Symbol("radix.slottable");
function U_(e) {
    const t = ({children: n}) => y.jsx(y.Fragment, {
        children: n
    });
    return t.displayName = `${e}.Slottable`,
    t.__radixId = kw,
    t
}
function $_(e) {
    return w.isValidElement(e) && typeof e.type == "function" && "__radixId"in e.type && e.type.__radixId === kw
}
function W_(e, t) {
    const n = {
        ...t
    };
    for (const s in t) {
        const o = e[s]
          , a = t[s];
        /^on[A-Z]/.test(s) ? o && a ? n[s] = (...c) => {
            a(...c),
            o(...c)
        }
        : o && (n[s] = o) : s === "style" ? n[s] = {
            ...o,
            ...a
        } : s === "className" && (n[s] = [o, a].filter(Boolean).join(" "))
    }
    return {
        ...e,
        ...n
    }
}
function H_(e) {
    let t = Object.getOwnPropertyDescriptor(e.props, "ref")?.get
      , n = t && "isReactWarning"in t && t.isReactWarning;
    return n ? e.ref : (t = Object.getOwnPropertyDescriptor(e, "ref")?.get,
    n = t && "isReactWarning"in t && t.isReactWarning,
    n ? e.props.ref : e.props.ref || e.ref)
}
function Nw(e) {
    const t = e + "CollectionProvider"
      , [n,s] = ei(t)
      , [o,a] = n(t, {
        collectionRef: {
            current: null
        },
        itemMap: new Map
    })
      , u = S => {
        const {scope: P, children: _} = S
          , k = Re.useRef(null)
          , j = Re.useRef(new Map).current;
        return y.jsx(o, {
            scope: P,
            itemMap: j,
            collectionRef: k,
            children: _
        })
    }
    ;
    u.displayName = t;
    const c = e + "CollectionSlot"
      , f = Pa(c)
      , h = Re.forwardRef( (S, P) => {
        const {scope: _, children: k} = S
          , j = a(c, _)
          , M = qt(P, j.collectionRef);
        return y.jsx(f, {
            ref: M,
            children: k
        })
    }
    );
    h.displayName = c;
    const m = e + "CollectionItemSlot"
      , v = "data-radix-collection-item"
      , x = Pa(m)
      , T = Re.forwardRef( (S, P) => {
        const {scope: _, children: k, ...j} = S
          , M = Re.useRef(null)
          , O = qt(P, M)
          , z = a(m, _);
        return Re.useEffect( () => (z.itemMap.set(M, {
            ref: M,
            ...j
        }),
        () => {
            z.itemMap.delete(M)
        }
        )),
        y.jsx(x, {
            [v]: "",
            ref: O,
            children: k
        })
    }
    );
    T.displayName = m;
    function C(S) {
        const P = a(e + "CollectionConsumer", S);
        return Re.useCallback( () => {
            const k = P.collectionRef.current;
            if (!k)
                return [];
            const j = Array.from(k.querySelectorAll(`[${v}]`));
            return Array.from(P.itemMap.values()).sort( (z, U) => j.indexOf(z.ref.current) - j.indexOf(U.ref.current))
        }
        , [P.collectionRef, P.itemMap])
    }
    return [{
        Provider: u,
        Slot: h,
        ItemSlot: T
    }, C, s]
}
var q_ = ["a", "button", "div", "form", "h2", "h3", "img", "input", "label", "li", "nav", "ol", "p", "span", "svg", "ul"]
  , Xe = q_.reduce( (e, t) => {
    const n = Pa(`Primitive.${t}`)
      , s = w.forwardRef( (o, a) => {
        const {asChild: u, ...c} = o
          , f = u ? n : t;
        return typeof window < "u" && (window[Symbol.for("radix-ui")] = !0),
        y.jsx(f, {
            ...c,
            ref: a
        })
    }
    );
    return s.displayName = `Primitive.${t}`,
    {
        ...e,
        [t]: s
    }
}
, {});
function Aw(e, t) {
    e && fc.flushSync( () => e.dispatchEvent(t))
}
function yn(e) {
    const t = w.useRef(e);
    return w.useEffect( () => {
        t.current = e
    }
    ),
    w.useMemo( () => (...n) => t.current?.(...n), [])
}
function Q_(e, t=globalThis?.document) {
    const n = yn(e);
    w.useEffect( () => {
        const s = o => {
            o.key === "Escape" && n(o)
        }
        ;
        return t.addEventListener("keydown", s, {
            capture: !0
        }),
        () => t.removeEventListener("keydown", s, {
            capture: !0
        })
    }
    , [n, t])
}
var K_ = "DismissableLayer", Ch = "dismissableLayer.update", G_ = "dismissableLayer.pointerDownOutside", Z_ = "dismissableLayer.focusOutside", zv, Rw = w.createContext({
    layers: new Set,
    layersWithOutsidePointerEventsDisabled: new Set,
    branches: new Set
}), hc = w.forwardRef( (e, t) => {
    const {disableOutsidePointerEvents: n=!1, onEscapeKeyDown: s, onPointerDownOutside: o, onFocusOutside: a, onInteractOutside: u, onDismiss: c, ...f} = e
      , h = w.useContext(Rw)
      , [m,v] = w.useState(null)
      , x = m?.ownerDocument ?? globalThis?.document
      , [,T] = w.useState({})
      , C = qt(t, U => v(U))
      , S = Array.from(h.layers)
      , [P] = [...h.layersWithOutsidePointerEventsDisabled].slice(-1)
      , _ = S.indexOf(P)
      , k = m ? S.indexOf(m) : -1
      , j = h.layersWithOutsidePointerEventsDisabled.size > 0
      , M = k >= _
      , O = X_(U => {
        const W = U.target
          , oe = [...h.branches].some(fe => fe.contains(W));
        !M || oe || (o?.(U),
        u?.(U),
        U.defaultPrevented || c?.())
    }
    , x)
      , z = J_(U => {
        const W = U.target;
        [...h.branches].some(fe => fe.contains(W)) || (a?.(U),
        u?.(U),
        U.defaultPrevented || c?.())
    }
    , x);
    return Q_(U => {
        k === h.layers.size - 1 && (s?.(U),
        !U.defaultPrevented && c && (U.preventDefault(),
        c()))
    }
    , x),
    w.useEffect( () => {
        if (m)
            return n && (h.layersWithOutsidePointerEventsDisabled.size === 0 && (zv = x.body.style.pointerEvents,
            x.body.style.pointerEvents = "none"),
            h.layersWithOutsidePointerEventsDisabled.add(m)),
            h.layers.add(m),
            Uv(),
            () => {
                n && h.layersWithOutsidePointerEventsDisabled.size === 1 && (x.body.style.pointerEvents = zv)
            }
    }
    , [m, x, n, h]),
    w.useEffect( () => () => {
        m && (h.layers.delete(m),
        h.layersWithOutsidePointerEventsDisabled.delete(m),
        Uv())
    }
    , [m, h]),
    w.useEffect( () => {
        const U = () => T({});
        return document.addEventListener(Ch, U),
        () => document.removeEventListener(Ch, U)
    }
    , []),
    y.jsx(Xe.div, {
        ...f,
        ref: C,
        style: {
            pointerEvents: j ? M ? "auto" : "none" : void 0,
            ...e.style
        },
        onFocusCapture: We(e.onFocusCapture, z.onFocusCapture),
        onBlurCapture: We(e.onBlurCapture, z.onBlurCapture),
        onPointerDownCapture: We(e.onPointerDownCapture, O.onPointerDownCapture)
    })
}
);
hc.displayName = K_;
var Y_ = "DismissableLayerBranch"
  , jw = w.forwardRef( (e, t) => {
    const n = w.useContext(Rw)
      , s = w.useRef(null)
      , o = qt(t, s);
    return w.useEffect( () => {
        const a = s.current;
        if (a)
            return n.branches.add(a),
            () => {
                n.branches.delete(a)
            }
    }
    , [n.branches]),
    y.jsx(Xe.div, {
        ...e,
        ref: o
    })
}
);
jw.displayName = Y_;
function X_(e, t=globalThis?.document) {
    const n = yn(e)
      , s = w.useRef(!1)
      , o = w.useRef( () => {}
    );
    return w.useEffect( () => {
        const a = c => {
            if (c.target && !s.current) {
                let f = function() {
                    Dw(G_, n, h, {
                        discrete: !0
                    })
                };
                const h = {
                    originalEvent: c
                };
                c.pointerType === "touch" ? (t.removeEventListener("click", o.current),
                o.current = f,
                t.addEventListener("click", o.current, {
                    once: !0
                })) : f()
            } else
                t.removeEventListener("click", o.current);
            s.current = !1
        }
          , u = window.setTimeout( () => {
            t.addEventListener("pointerdown", a)
        }
        , 0);
        return () => {
            window.clearTimeout(u),
            t.removeEventListener("pointerdown", a),
            t.removeEventListener("click", o.current)
        }
    }
    , [t, n]),
    {
        onPointerDownCapture: () => s.current = !0
    }
}
function J_(e, t=globalThis?.document) {
    const n = yn(e)
      , s = w.useRef(!1);
    return w.useEffect( () => {
        const o = a => {
            a.target && !s.current && Dw(Z_, n, {
                originalEvent: a
            }, {
                discrete: !1
            })
        }
        ;
        return t.addEventListener("focusin", o),
        () => t.removeEventListener("focusin", o)
    }
    , [t, n]),
    {
        onFocusCapture: () => s.current = !0,
        onBlurCapture: () => s.current = !1
    }
}
function Uv() {
    const e = new CustomEvent(Ch);
    document.dispatchEvent(e)
}
function Dw(e, t, n, {discrete: s}) {
    const o = n.originalEvent.target
      , a = new CustomEvent(e,{
        bubbles: !1,
        cancelable: !0,
        detail: n
    });
    t && o.addEventListener(e, t, {
        once: !0
    }),
    s ? Aw(o, a) : o.dispatchEvent(a)
}
var ek = hc
  , tk = jw
  , cs = globalThis?.document ? w.useLayoutEffect : () => {}
  , nk = "Portal"
  , yp = w.forwardRef( (e, t) => {
    const {container: n, ...s} = e
      , [o,a] = w.useState(!1);
    cs( () => a(!0), []);
    const u = n || o && globalThis?.document?.body;
    return u ? L_.createPortal(y.jsx(Xe.div, {
        ...s,
        ref: t
    }), u) : null
}
);
yp.displayName = nk;
function rk(e, t) {
    return w.useReducer( (n, s) => t[n][s] ?? n, e)
}
var ti = e => {
    const {present: t, children: n} = e
      , s = sk(t)
      , o = typeof n == "function" ? n({
        present: s.isPresent
    }) : w.Children.only(n)
      , a = qt(s.ref, ik(o));
    return typeof n == "function" || s.isPresent ? w.cloneElement(o, {
        ref: a
    }) : null
}
;
ti.displayName = "Presence";
function sk(e) {
    const [t,n] = w.useState()
      , s = w.useRef({})
      , o = w.useRef(e)
      , a = w.useRef("none")
      , u = e ? "mounted" : "unmounted"
      , [c,f] = rk(u, {
        mounted: {
            UNMOUNT: "unmounted",
            ANIMATION_OUT: "unmountSuspended"
        },
        unmountSuspended: {
            MOUNT: "mounted",
            ANIMATION_END: "unmounted"
        },
        unmounted: {
            MOUNT: "mounted"
        }
    });
    return w.useEffect( () => {
        const h = pu(s.current);
        a.current = c === "mounted" ? h : "none"
    }
    , [c]),
    cs( () => {
        const h = s.current
          , m = o.current;
        if (m !== e) {
            const x = a.current
              , T = pu(h);
            e ? f("MOUNT") : T === "none" || h?.display === "none" ? f("UNMOUNT") : f(m && x !== T ? "ANIMATION_OUT" : "UNMOUNT"),
            o.current = e
        }
    }
    , [e, f]),
    cs( () => {
        if (t) {
            let h;
            const m = t.ownerDocument.defaultView ?? window
              , v = T => {
                const S = pu(s.current).includes(T.animationName);
                if (T.target === t && S && (f("ANIMATION_END"),
                !o.current)) {
                    const P = t.style.animationFillMode;
                    t.style.animationFillMode = "forwards",
                    h = m.setTimeout( () => {
                        t.style.animationFillMode === "forwards" && (t.style.animationFillMode = P)
                    }
                    )
                }
            }
              , x = T => {
                T.target === t && (a.current = pu(s.current))
            }
            ;
            return t.addEventListener("animationstart", x),
            t.addEventListener("animationcancel", v),
            t.addEventListener("animationend", v),
            () => {
                m.clearTimeout(h),
                t.removeEventListener("animationstart", x),
                t.removeEventListener("animationcancel", v),
                t.removeEventListener("animationend", v)
            }
        } else
            f("ANIMATION_END")
    }
    , [t, f]),
    {
        isPresent: ["mounted", "unmountSuspended"].includes(c),
        ref: w.useCallback(h => {
            h && (s.current = getComputedStyle(h)),
            n(h)
        }
        , [])
    }
}
function pu(e) {
    return e?.animationName || "none"
}
function ik(e) {
    let t = Object.getOwnPropertyDescriptor(e.props, "ref")?.get
      , n = t && "isReactWarning"in t && t.isReactWarning;
    return n ? e.ref : (t = Object.getOwnPropertyDescriptor(e, "ref")?.get,
    n = t && "isReactWarning"in t && t.isReactWarning,
    n ? e.props.ref : e.props.ref || e.ref)
}
function pc({prop: e, defaultProp: t, onChange: n= () => {}
}) {
    const [s,o] = ok({
        defaultProp: t,
        onChange: n
    })
      , a = e !== void 0
      , u = a ? e : s
      , c = yn(n)
      , f = w.useCallback(h => {
        if (a) {
            const v = typeof h == "function" ? h(e) : h;
            v !== e && c(v)
        } else
            o(h)
    }
    , [a, e, o, c]);
    return [u, f]
}
function ok({defaultProp: e, onChange: t}) {
    const n = w.useState(e)
      , [s] = n
      , o = w.useRef(s)
      , a = yn(t);
    return w.useEffect( () => {
        o.current !== s && (a(s),
        o.current = s)
    }
    , [s, o, a]),
    n
}
var ak = "VisuallyHidden"
  , mc = w.forwardRef( (e, t) => y.jsx(Xe.span, {
    ...e,
    ref: t,
    style: {
        position: "absolute",
        border: 0,
        width: 1,
        height: 1,
        padding: 0,
        margin: -1,
        overflow: "hidden",
        clip: "rect(0, 0, 0, 0)",
        whiteSpace: "nowrap",
        wordWrap: "normal",
        ...e.style
    }
}));
mc.displayName = ak;
var lk = mc
  , vp = "ToastProvider"
  , [xp,uk,ck] = Nw("Toast")
  , [Ow] = ei("Toast", [ck])
  , [dk,gc] = Ow(vp)
  , Mw = e => {
    const {__scopeToast: t, label: n="Notification", duration: s=5e3, swipeDirection: o="right", swipeThreshold: a=50, children: u} = e
      , [c,f] = w.useState(null)
      , [h,m] = w.useState(0)
      , v = w.useRef(!1)
      , x = w.useRef(!1);
    return n.trim() || console.error(`Invalid prop \`label\` supplied to \`${vp}\`. Expected non-empty \`string\`.`),
    y.jsx(xp.Provider, {
        scope: t,
        children: y.jsx(dk, {
            scope: t,
            label: n,
            duration: s,
            swipeDirection: o,
            swipeThreshold: a,
            toastCount: h,
            viewport: c,
            onViewportChange: f,
            onToastAdd: w.useCallback( () => m(T => T + 1), []),
            onToastRemove: w.useCallback( () => m(T => T - 1), []),
            isFocusedToastEscapeKeyDownRef: v,
            isClosePausedRef: x,
            children: u
        })
    })
}
;
Mw.displayName = vp;
var Iw = "ToastViewport"
  , fk = ["F8"]
  , Eh = "toast.viewportPause"
  , _h = "toast.viewportResume"
  , Fw = w.forwardRef( (e, t) => {
    const {__scopeToast: n, hotkey: s=fk, label: o="Notifications ({hotkey})", ...a} = e
      , u = gc(Iw, n)
      , c = uk(n)
      , f = w.useRef(null)
      , h = w.useRef(null)
      , m = w.useRef(null)
      , v = w.useRef(null)
      , x = qt(t, v, u.onViewportChange)
      , T = s.join("+").replace(/Key/g, "").replace(/Digit/g, "")
      , C = u.toastCount > 0;
    w.useEffect( () => {
        const P = _ => {
            s.length !== 0 && s.every(j => _[j] || _.code === j) && v.current?.focus()
        }
        ;
        return document.addEventListener("keydown", P),
        () => document.removeEventListener("keydown", P)
    }
    , [s]),
    w.useEffect( () => {
        const P = f.current
          , _ = v.current;
        if (C && P && _) {
            const k = () => {
                if (!u.isClosePausedRef.current) {
                    const z = new CustomEvent(Eh);
                    _.dispatchEvent(z),
                    u.isClosePausedRef.current = !0
                }
            }
              , j = () => {
                if (u.isClosePausedRef.current) {
                    const z = new CustomEvent(_h);
                    _.dispatchEvent(z),
                    u.isClosePausedRef.current = !1
                }
            }
              , M = z => {
                !P.contains(z.relatedTarget) && j()
            }
              , O = () => {
                P.contains(document.activeElement) || j()
            }
            ;
            return P.addEventListener("focusin", k),
            P.addEventListener("focusout", M),
            P.addEventListener("pointermove", k),
            P.addEventListener("pointerleave", O),
            window.addEventListener("blur", k),
            window.addEventListener("focus", j),
            () => {
                P.removeEventListener("focusin", k),
                P.removeEventListener("focusout", M),
                P.removeEventListener("pointermove", k),
                P.removeEventListener("pointerleave", O),
                window.removeEventListener("blur", k),
                window.removeEventListener("focus", j)
            }
        }
    }
    , [C, u.isClosePausedRef]);
    const S = w.useCallback( ({tabbingDirection: P}) => {
        const k = c().map(j => {
            const M = j.ref.current
              , O = [M, ...Ck(M)];
            return P === "forwards" ? O : O.reverse()
        }
        );
        return (P === "forwards" ? k.reverse() : k).flat()
    }
    , [c]);
    return w.useEffect( () => {
        const P = v.current;
        if (P) {
            const _ = k => {
                const j = k.altKey || k.ctrlKey || k.metaKey;
                if (k.key === "Tab" && !j) {
                    const O = document.activeElement
                      , z = k.shiftKey;
                    if (k.target === P && z) {
                        h.current?.focus();
                        return
                    }
                    const oe = S({
                        tabbingDirection: z ? "backwards" : "forwards"
                    })
                      , fe = oe.findIndex(we => we === O);
                    Vf(oe.slice(fe + 1)) ? k.preventDefault() : z ? h.current?.focus() : m.current?.focus()
                }
            }
            ;
            return P.addEventListener("keydown", _),
            () => P.removeEventListener("keydown", _)
        }
    }
    , [c, S]),
    y.jsxs(tk, {
        ref: f,
        role: "region",
        "aria-label": o.replace("{hotkey}", T),
        tabIndex: -1,
        style: {
            pointerEvents: C ? void 0 : "none"
        },
        children: [C && y.jsx(kh, {
            ref: h,
            onFocusFromOutsideViewport: () => {
                const P = S({
                    tabbingDirection: "forwards"
                });
                Vf(P)
            }
        }), y.jsx(xp.Slot, {
            scope: n,
            children: y.jsx(Xe.ol, {
                tabIndex: -1,
                ...a,
                ref: x
            })
        }), C && y.jsx(kh, {
            ref: m,
            onFocusFromOutsideViewport: () => {
                const P = S({
                    tabbingDirection: "backwards"
                });
                Vf(P)
            }
        })]
    })
}
);
Fw.displayName = Iw;
var Lw = "ToastFocusProxy"
  , kh = w.forwardRef( (e, t) => {
    const {__scopeToast: n, onFocusFromOutsideViewport: s, ...o} = e
      , a = gc(Lw, n);
    return y.jsx(mc, {
        "aria-hidden": !0,
        tabIndex: 0,
        ...o,
        ref: t,
        style: {
            position: "fixed"
        },
        onFocus: u => {
            const c = u.relatedTarget;
            !a.viewport?.contains(c) && s()
        }
    })
}
);
kh.displayName = Lw;
var yc = "Toast"
  , hk = "toast.swipeStart"
  , pk = "toast.swipeMove"
  , mk = "toast.swipeCancel"
  , gk = "toast.swipeEnd"
  , Vw = w.forwardRef( (e, t) => {
    const {forceMount: n, open: s, defaultOpen: o, onOpenChange: a, ...u} = e
      , [c=!0,f] = pc({
        prop: s,
        defaultProp: o,
        onChange: a
    });
    return y.jsx(ti, {
        present: n || c,
        children: y.jsx(xk, {
            open: c,
            ...u,
            ref: t,
            onClose: () => f(!1),
            onPause: yn(e.onPause),
            onResume: yn(e.onResume),
            onSwipeStart: We(e.onSwipeStart, h => {
                h.currentTarget.setAttribute("data-swipe", "start")
            }
            ),
            onSwipeMove: We(e.onSwipeMove, h => {
                const {x: m, y: v} = h.detail.delta;
                h.currentTarget.setAttribute("data-swipe", "move"),
                h.currentTarget.style.setProperty("--radix-toast-swipe-move-x", `${m}px`),
                h.currentTarget.style.setProperty("--radix-toast-swipe-move-y", `${v}px`)
            }
            ),
            onSwipeCancel: We(e.onSwipeCancel, h => {
                h.currentTarget.setAttribute("data-swipe", "cancel"),
                h.currentTarget.style.removeProperty("--radix-toast-swipe-move-x"),
                h.currentTarget.style.removeProperty("--radix-toast-swipe-move-y"),
                h.currentTarget.style.removeProperty("--radix-toast-swipe-end-x"),
                h.currentTarget.style.removeProperty("--radix-toast-swipe-end-y")
            }
            ),
            onSwipeEnd: We(e.onSwipeEnd, h => {
                const {x: m, y: v} = h.detail.delta;
                h.currentTarget.setAttribute("data-swipe", "end"),
                h.currentTarget.style.removeProperty("--radix-toast-swipe-move-x"),
                h.currentTarget.style.removeProperty("--radix-toast-swipe-move-y"),
                h.currentTarget.style.setProperty("--radix-toast-swipe-end-x", `${m}px`),
                h.currentTarget.style.setProperty("--radix-toast-swipe-end-y", `${v}px`),
                f(!1)
            }
            )
        })
    })
}
);
Vw.displayName = yc;
var [yk,vk] = Ow(yc, {
    onClose() {}
})
  , xk = w.forwardRef( (e, t) => {
    const {__scopeToast: n, type: s="foreground", duration: o, open: a, onClose: u, onEscapeKeyDown: c, onPause: f, onResume: h, onSwipeStart: m, onSwipeMove: v, onSwipeCancel: x, onSwipeEnd: T, ...C} = e
      , S = gc(yc, n)
      , [P,_] = w.useState(null)
      , k = qt(t, G => _(G))
      , j = w.useRef(null)
      , M = w.useRef(null)
      , O = o || S.duration
      , z = w.useRef(0)
      , U = w.useRef(O)
      , W = w.useRef(0)
      , {onToastAdd: oe, onToastRemove: fe} = S
      , we = yn( () => {
        P?.contains(document.activeElement) && S.viewport?.focus(),
        u()
    }
    )
      , X = w.useCallback(G => {
        !G || G === 1 / 0 || (window.clearTimeout(W.current),
        z.current = new Date().getTime(),
        W.current = window.setTimeout(we, G))
    }
    , [we]);
    w.useEffect( () => {
        const G = S.viewport;
        if (G) {
            const be = () => {
                X(U.current),
                h?.()
            }
              , ce = () => {
                const ie = new Date().getTime() - z.current;
                U.current = U.current - ie,
                window.clearTimeout(W.current),
                f?.()
            }
            ;
            return G.addEventListener(Eh, ce),
            G.addEventListener(_h, be),
            () => {
                G.removeEventListener(Eh, ce),
                G.removeEventListener(_h, be)
            }
        }
    }
    , [S.viewport, O, f, h, X]),
    w.useEffect( () => {
        a && !S.isClosePausedRef.current && X(O)
    }
    , [a, O, S.isClosePausedRef, X]),
    w.useEffect( () => (oe(),
    () => fe()), [oe, fe]);
    const se = w.useMemo( () => P ? qw(P) : null, [P]);
    return S.viewport ? y.jsxs(y.Fragment, {
        children: [se && y.jsx(wk, {
            __scopeToast: n,
            role: "status",
            "aria-live": s === "foreground" ? "assertive" : "polite",
            "aria-atomic": !0,
            children: se
        }), y.jsx(yk, {
            scope: n,
            onClose: we,
            children: fc.createPortal(y.jsx(xp.ItemSlot, {
                scope: n,
                children: y.jsx(ek, {
                    asChild: !0,
                    onEscapeKeyDown: We(c, () => {
                        S.isFocusedToastEscapeKeyDownRef.current || we(),
                        S.isFocusedToastEscapeKeyDownRef.current = !1
                    }
                    ),
                    children: y.jsx(Xe.li, {
                        role: "status",
                        "aria-live": "off",
                        "aria-atomic": !0,
                        tabIndex: 0,
                        "data-state": a ? "open" : "closed",
                        "data-swipe-direction": S.swipeDirection,
                        ...C,
                        ref: k,
                        style: {
                            userSelect: "none",
                            touchAction: "none",
                            ...e.style
                        },
                        onKeyDown: We(e.onKeyDown, G => {
                            G.key === "Escape" && (c?.(G.nativeEvent),
                            G.nativeEvent.defaultPrevented || (S.isFocusedToastEscapeKeyDownRef.current = !0,
                            we()))
                        }
                        ),
                        onPointerDown: We(e.onPointerDown, G => {
                            G.button === 0 && (j.current = {
                                x: G.clientX,
                                y: G.clientY
                            })
                        }
                        ),
                        onPointerMove: We(e.onPointerMove, G => {
                            if (!j.current)
                                return;
                            const be = G.clientX - j.current.x
                              , ce = G.clientY - j.current.y
                              , ie = !!M.current
                              , B = ["left", "right"].includes(S.swipeDirection)
                              , ne = ["left", "up"].includes(S.swipeDirection) ? Math.min : Math.max
                              , J = B ? ne(0, be) : 0
                              , D = B ? 0 : ne(0, ce)
                              , H = G.pointerType === "touch" ? 10 : 2
                              , Ce = {
                                x: J,
                                y: D
                            }
                              , Ne = {
                                originalEvent: G,
                                delta: Ce
                            };
                            ie ? (M.current = Ce,
                            mu(pk, v, Ne, {
                                discrete: !1
                            })) : $v(Ce, S.swipeDirection, H) ? (M.current = Ce,
                            mu(hk, m, Ne, {
                                discrete: !1
                            }),
                            G.target.setPointerCapture(G.pointerId)) : (Math.abs(be) > H || Math.abs(ce) > H) && (j.current = null)
                        }
                        ),
                        onPointerUp: We(e.onPointerUp, G => {
                            const be = M.current
                              , ce = G.target;
                            if (ce.hasPointerCapture(G.pointerId) && ce.releasePointerCapture(G.pointerId),
                            M.current = null,
                            j.current = null,
                            be) {
                                const ie = G.currentTarget
                                  , B = {
                                    originalEvent: G,
                                    delta: be
                                };
                                $v(be, S.swipeDirection, S.swipeThreshold) ? mu(gk, T, B, {
                                    discrete: !0
                                }) : mu(mk, x, B, {
                                    discrete: !0
                                }),
                                ie.addEventListener("click", ne => ne.preventDefault(), {
                                    once: !0
                                })
                            }
                        }
                        )
                    })
                })
            }), S.viewport)
        })]
    }) : null
}
)
  , wk = e => {
    const {__scopeToast: t, children: n, ...s} = e
      , o = gc(yc, t)
      , [a,u] = w.useState(!1)
      , [c,f] = w.useState(!1);
    return Tk( () => u(!0)),
    w.useEffect( () => {
        const h = window.setTimeout( () => f(!0), 1e3);
        return () => window.clearTimeout(h)
    }
    , []),
    c ? null : y.jsx(yp, {
        asChild: !0,
        children: y.jsx(mc, {
            ...s,
            children: a && y.jsxs(y.Fragment, {
                children: [o.label, " ", n]
            })
        })
    })
}
  , bk = "ToastTitle"
  , Bw = w.forwardRef( (e, t) => {
    const {__scopeToast: n, ...s} = e;
    return y.jsx(Xe.div, {
        ...s,
        ref: t
    })
}
);
Bw.displayName = bk;
var Sk = "ToastDescription"
  , zw = w.forwardRef( (e, t) => {
    const {__scopeToast: n, ...s} = e;
    return y.jsx(Xe.div, {
        ...s,
        ref: t
    })
}
);
zw.displayName = Sk;
var Uw = "ToastAction"
  , $w = w.forwardRef( (e, t) => {
    const {altText: n, ...s} = e;
    return n.trim() ? y.jsx(Hw, {
        altText: n,
        asChild: !0,
        children: y.jsx(wp, {
            ...s,
            ref: t
        })
    }) : (console.error(`Invalid prop \`altText\` supplied to \`${Uw}\`. Expected non-empty \`string\`.`),
    null)
}
);
$w.displayName = Uw;
var Ww = "ToastClose"
  , wp = w.forwardRef( (e, t) => {
    const {__scopeToast: n, ...s} = e
      , o = vk(Ww, n);
    return y.jsx(Hw, {
        asChild: !0,
        children: y.jsx(Xe.button, {
            type: "button",
            ...s,
            ref: t,
            onClick: We(e.onClick, o.onClose)
        })
    })
}
);
wp.displayName = Ww;
var Hw = w.forwardRef( (e, t) => {
    const {__scopeToast: n, altText: s, ...o} = e;
    return y.jsx(Xe.div, {
        "data-radix-toast-announce-exclude": "",
        "data-radix-toast-announce-alt": s || void 0,
        ...o,
        ref: t
    })
}
);
function qw(e) {
    const t = [];
    return Array.from(e.childNodes).forEach(s => {
        if (s.nodeType === s.TEXT_NODE && s.textContent && t.push(s.textContent),
        Pk(s)) {
            const o = s.ariaHidden || s.hidden || s.style.display === "none"
              , a = s.dataset.radixToastAnnounceExclude === "";
            if (!o)
                if (a) {
                    const u = s.dataset.radixToastAnnounceAlt;
                    u && t.push(u)
                } else
                    t.push(...qw(s))
        }
    }
    ),
    t
}
function mu(e, t, n, {discrete: s}) {
    const o = n.originalEvent.currentTarget
      , a = new CustomEvent(e,{
        bubbles: !0,
        cancelable: !0,
        detail: n
    });
    t && o.addEventListener(e, t, {
        once: !0
    }),
    s ? Aw(o, a) : o.dispatchEvent(a)
}
var $v = (e, t, n=0) => {
    const s = Math.abs(e.x)
      , o = Math.abs(e.y)
      , a = s > o;
    return t === "left" || t === "right" ? a && s > n : !a && o > n
}
;
function Tk(e= () => {}
) {
    const t = yn(e);
    cs( () => {
        let n = 0
          , s = 0;
        return n = window.requestAnimationFrame( () => s = window.requestAnimationFrame(t)),
        () => {
            window.cancelAnimationFrame(n),
            window.cancelAnimationFrame(s)
        }
    }
    , [t])
}
function Pk(e) {
    return e.nodeType === e.ELEMENT_NODE
}
function Ck(e) {
    const t = []
      , n = document.createTreeWalker(e, NodeFilter.SHOW_ELEMENT, {
        acceptNode: s => {
            const o = s.tagName === "INPUT" && s.type === "hidden";
            return s.disabled || s.hidden || o ? NodeFilter.FILTER_SKIP : s.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP
        }
    });
    for (; n.nextNode(); )
        t.push(n.currentNode);
    return t
}
function Vf(e) {
    const t = document.activeElement;
    return e.some(n => n === t ? !0 : (n.focus(),
    document.activeElement !== t))
}
var Ek = Mw
  , Qw = Fw
  , Kw = Vw
  , Gw = Bw
  , Zw = zw
  , Yw = $w
  , Xw = wp;
function Jw(e) {
    var t, n, s = "";
    if (typeof e == "string" || typeof e == "number")
        s += e;
    else if (typeof e == "object")
        if (Array.isArray(e)) {
            var o = e.length;
            for (t = 0; t < o; t++)
                e[t] && (n = Jw(e[t])) && (s && (s += " "),
                s += n)
        } else
            for (n in e)
                e[n] && (s && (s += " "),
                s += n);
    return s
}
function eb() {
    for (var e, t, n = 0, s = "", o = arguments.length; n < o; n++)
        (e = arguments[n]) && (t = Jw(e)) && (s && (s += " "),
        s += t);
    return s
}
const Wv = e => typeof e == "boolean" ? `${e}` : e === 0 ? "0" : e
  , Hv = eb
  , vc = (e, t) => n => {
    var s;
    if (t?.variants == null)
        return Hv(e, n?.class, n?.className);
    const {variants: o, defaultVariants: a} = t
      , u = Object.keys(o).map(h => {
        const m = n?.[h]
          , v = a?.[h];
        if (m === null)
            return null;
        const x = Wv(m) || Wv(v);
        return o[h][x]
    }
    )
      , c = n && Object.entries(n).reduce( (h, m) => {
        let[v,x] = m;
        return x === void 0 || (h[v] = x),
        h
    }
    , {})
      , f = t == null || (s = t.compoundVariants) === null || s === void 0 ? void 0 : s.reduce( (h, m) => {
        let {class: v, className: x, ...T} = m;
        return Object.entries(T).every(C => {
            let[S,P] = C;
            return Array.isArray(P) ? P.includes({
                ...a,
                ...c
            }[S]) : {
                ...a,
                ...c
            }[S] === P
        }
        ) ? [...h, v, x] : h
    }
    , []);
    return Hv(e, u, f, n?.class, n?.className)
}
;
const _k = e => e.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase()
  , tb = (...e) => e.filter( (t, n, s) => !!t && s.indexOf(t) === n).join(" ");
var kk = {
    xmlns: "http://www.w3.org/2000/svg",
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "none",
    stroke: "currentColor",
    strokeWidth: 2,
    strokeLinecap: "round",
    strokeLinejoin: "round"
};
const Nk = w.forwardRef( ({color: e="currentColor", size: t=24, strokeWidth: n=2, absoluteStrokeWidth: s, className: o="", children: a, iconNode: u, ...c}, f) => w.createElement("svg", {
    ref: f,
    ...kk,
    width: t,
    height: t,
    stroke: e,
    strokeWidth: s ? Number(n) * 24 / Number(t) : n,
    className: tb("lucide", o),
    ...c
}, [...u.map( ([h,m]) => w.createElement(h, m)), ...Array.isArray(a) ? a : [a]]));
const Tt = (e, t) => {
    const n = w.forwardRef( ({className: s, ...o}, a) => w.createElement(Nk, {
        ref: a,
        iconNode: t,
        className: tb(`lucide-${_k(e)}`, s),
        ...o
    }));
    return n.displayName = `${e}`,
    n
}
;
const Nh = Tt("ArrowRight", [["path", {
    d: "M5 12h14",
    key: "1ays0h"
}], ["path", {
    d: "m12 5 7 7-7 7",
    key: "xquz4c"
}]]);
const Ak = Tt("BookOpen", [["path", {
    d: "M12 7v14",
    key: "1akyts"
}], ["path", {
    d: "M3 18a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1h5a4 4 0 0 1 4 4 4 4 0 0 1 4-4h5a1 1 0 0 1 1 1v13a1 1 0 0 1-1 1h-6a3 3 0 0 0-3 3 3 3 0 0 0-3-3z",
    key: "ruj8y"
}]]);
const nb = Tt("Calendar", [["path", {
    d: "M8 2v4",
    key: "1cmpym"
}], ["path", {
    d: "M16 2v4",
    key: "4m81vk"
}], ["rect", {
    width: "18",
    height: "18",
    x: "3",
    y: "4",
    rx: "2",
    key: "1hopcy"
}], ["path", {
    d: "M3 10h18",
    key: "8toen8"
}]]);
const Rk = Tt("CircleAlert", [["circle", {
    cx: "12",
    cy: "12",
    r: "10",
    key: "1mglay"
}], ["line", {
    x1: "12",
    x2: "12",
    y1: "8",
    y2: "12",
    key: "1pkeuh"
}], ["line", {
    x1: "12",
    x2: "12.01",
    y1: "16",
    y2: "16",
    key: "4dfq90"
}]]);
const jk = Tt("ExternalLink", [["path", {
    d: "M15 3h6v6",
    key: "1q9fwt"
}], ["path", {
    d: "M10 14 21 3",
    key: "gplh6r"
}], ["path", {
    d: "M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6",
    key: "a6xqqp"
}]]);
const qv = Tt("House", [["path", {
    d: "M15 21v-8a1 1 0 0 0-1-1h-4a1 1 0 0 0-1 1v8",
    key: "5wwlr5"
}], ["path", {
    d: "M3 10a2 2 0 0 1 .709-1.528l7-5.999a2 2 0 0 1 2.582 0l7 5.999A2 2 0 0 1 21 10v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z",
    key: "1d0kgt"
}]]);
const Dk = Tt("MapPin", [["path", {
    d: "M20 10c0 4.993-5.539 10.193-7.399 11.799a1 1 0 0 1-1.202 0C9.539 20.193 4 14.993 4 10a8 8 0 0 1 16 0",
    key: "1r0f0z"
}], ["circle", {
    cx: "12",
    cy: "10",
    r: "3",
    key: "ilqhr7"
}]]);
const Ok = Tt("Menu", [["line", {
    x1: "4",
    x2: "20",
    y1: "12",
    y2: "12",
    key: "1e0a9i"
}], ["line", {
    x1: "4",
    x2: "20",
    y1: "6",
    y2: "6",
    key: "1owob3"
}], ["line", {
    x1: "4",
    x2: "20",
    y1: "18",
    y2: "18",
    key: "yk5zj1"
}]]);
const rb = Tt("Plus", [["path", {
    d: "M5 12h14",
    key: "1ays0h"
}], ["path", {
    d: "M12 5v14",
    key: "s699le"
}]]);
const Mk = Tt("ShieldCheck", [["path", {
    d: "M20 13c0 5-3.5 7.5-7.66 8.95a1 1 0 0 1-.67-.01C7.5 20.5 4 18 4 13V6a1 1 0 0 1 1-1c2 0 4.5-1.2 6.24-2.72a1.17 1.17 0 0 1 1.52 0C14.51 3.81 17 5 19 5a1 1 0 0 1 1 1z",
    key: "oel41y"
}], ["path", {
    d: "m9 12 2 2 4-4",
    key: "dzmm74"
}]]);
const Ah = Tt("Shield", [["path", {
    d: "M20 13c0 5-3.5 7.5-7.66 8.95a1 1 0 0 1-.67-.01C7.5 20.5 4 18 4 13V6a1 1 0 0 1 1-1c2 0 4.5-1.2 6.24-2.72a1.17 1.17 0 0 1 1.52 0C14.51 3.81 17 5 19 5a1 1 0 0 1 1 1z",
    key: "oel41y"
}]]);
const Ik = Tt("Sparkles", [["path", {
    d: "M9.937 15.5A2 2 0 0 0 8.5 14.063l-6.135-1.582a.5.5 0 0 1 0-.962L8.5 9.936A2 2 0 0 0 9.937 8.5l1.582-6.135a.5.5 0 0 1 .963 0L14.063 8.5A2 2 0 0 0 15.5 9.937l6.135 1.581a.5.5 0 0 1 0 .964L15.5 14.063a2 2 0 0 0-1.437 1.437l-1.582 6.135a.5.5 0 0 1-.963 0z",
    key: "4pj2yx"
}], ["path", {
    d: "M20 3v4",
    key: "1olli1"
}], ["path", {
    d: "M22 5h-4",
    key: "1gvqau"
}], ["path", {
    d: "M4 17v2",
    key: "vumght"
}], ["path", {
    d: "M5 18H3",
    key: "zchphs"
}]]);
const Fk = Tt("SquarePen", [["path", {
    d: "M12 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7",
    key: "1m0v6g"
}], ["path", {
    d: "M18.375 2.625a1 1 0 0 1 3 3l-9.013 9.014a2 2 0 0 1-.853.505l-2.873.84a.5.5 0 0 1-.62-.62l.84-2.873a2 2 0 0 1 .506-.852z",
    key: "ohrbg2"
}]]);
const Lk = Tt("Trash2", [["path", {
    d: "M3 6h18",
    key: "d0wm0j"
}], ["path", {
    d: "M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6",
    key: "4alrt4"
}], ["path", {
    d: "M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2",
    key: "v07s0e"
}], ["line", {
    x1: "10",
    x2: "10",
    y1: "11",
    y2: "17",
    key: "1uufr5"
}], ["line", {
    x1: "14",
    x2: "14",
    y1: "11",
    y2: "17",
    key: "xtxkd"
}]]);
const Vk = Tt("Trash", [["path", {
    d: "M3 6h18",
    key: "d0wm0j"
}], ["path", {
    d: "M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6",
    key: "4alrt4"
}], ["path", {
    d: "M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2",
    key: "v07s0e"
}]]);
const Bk = Tt("TriangleAlert", [["path", {
    d: "m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3",
    key: "wmoenq"
}], ["path", {
    d: "M12 9v4",
    key: "juzpu7"
}], ["path", {
    d: "M12 17h.01",
    key: "p32p05"
}]]);
const ir = Tt("Trophy", [["path", {
    d: "M6 9H4.5a2.5 2.5 0 0 1 0-5H6",
    key: "17hqa7"
}], ["path", {
    d: "M18 9h1.5a2.5 2.5 0 0 0 0-5H18",
    key: "lmptdp"
}], ["path", {
    d: "M4 22h16",
    key: "57wxv0"
}], ["path", {
    d: "M10 14.66V17c0 .55-.47.98-.97 1.21C7.85 18.75 7 20.24 7 22",
    key: "1nw9bq"
}], ["path", {
    d: "M14 14.66V17c0 .55.47.98.97 1.21C16.15 18.75 17 20.24 17 22",
    key: "1np0yb"
}], ["path", {
    d: "M18 2H6v7a6 6 0 0 0 12 0V2Z",
    key: "u46fv3"
}]]);
const zk = Tt("UserCheck", [["path", {
    d: "M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2",
    key: "1yyitq"
}], ["circle", {
    cx: "9",
    cy: "7",
    r: "4",
    key: "nufk8"
}], ["polyline", {
    points: "16 11 18 13 22 9",
    key: "1pwet4"
}]]);
const sb = Tt("Users", [["path", {
    d: "M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2",
    key: "1yyitq"
}], ["circle", {
    cx: "9",
    cy: "7",
    r: "4",
    key: "nufk8"
}], ["path", {
    d: "M22 21v-2a4 4 0 0 0-3-3.87",
    key: "kshegd"
}], ["path", {
    d: "M16 3.13a4 4 0 0 1 0 7.75",
    key: "1da9ce"
}]]);
const bp = Tt("X", [["path", {
    d: "M18 6 6 18",
    key: "1bl5f8"
}], ["path", {
    d: "m6 6 12 12",
    key: "d8bk6v"
}]])
  , Sp = "-"
  , Uk = e => {
    const t = Wk(e)
      , {conflictingClassGroups: n, conflictingClassGroupModifiers: s} = e;
    return {
        getClassGroupId: u => {
            const c = u.split(Sp);
            return c[0] === "" && c.length !== 1 && c.shift(),
            ib(c, t) || $k(u)
        }
        ,
        getConflictingClassGroupIds: (u, c) => {
            const f = n[u] || [];
            return c && s[u] ? [...f, ...s[u]] : f
        }
    }
}
  , ib = (e, t) => {
    if (e.length === 0)
        return t.classGroupId;
    const n = e[0]
      , s = t.nextPart.get(n)
      , o = s ? ib(e.slice(1), s) : void 0;
    if (o)
        return o;
    if (t.validators.length === 0)
        return;
    const a = e.join(Sp);
    return t.validators.find( ({validator: u}) => u(a))?.classGroupId
}
  , Qv = /^\[(.+)\]$/
  , $k = e => {
    if (Qv.test(e)) {
        const t = Qv.exec(e)[1]
          , n = t?.substring(0, t.indexOf(":"));
        if (n)
            return "arbitrary.." + n
    }
}
  , Wk = e => {
    const {theme: t, prefix: n} = e
      , s = {
        nextPart: new Map,
        validators: []
    };
    return qk(Object.entries(e.classGroups), n).forEach( ([a,u]) => {
        Rh(u, s, a, t)
    }
    ),
    s
}
  , Rh = (e, t, n, s) => {
    e.forEach(o => {
        if (typeof o == "string") {
            const a = o === "" ? t : Kv(t, o);
            a.classGroupId = n;
            return
        }
        if (typeof o == "function") {
            if (Hk(o)) {
                Rh(o(s), t, n, s);
                return
            }
            t.validators.push({
                validator: o,
                classGroupId: n
            });
            return
        }
        Object.entries(o).forEach( ([a,u]) => {
            Rh(u, Kv(t, a), n, s)
        }
        )
    }
    )
}
  , Kv = (e, t) => {
    let n = e;
    return t.split(Sp).forEach(s => {
        n.nextPart.has(s) || n.nextPart.set(s, {
            nextPart: new Map,
            validators: []
        }),
        n = n.nextPart.get(s)
    }
    ),
    n
}
  , Hk = e => e.isThemeGetter
  , qk = (e, t) => t ? e.map( ([n,s]) => {
    const o = s.map(a => typeof a == "string" ? t + a : typeof a == "object" ? Object.fromEntries(Object.entries(a).map( ([u,c]) => [t + u, c])) : a);
    return [n, o]
}
) : e
  , Qk = e => {
    if (e < 1)
        return {
            get: () => {}
            ,
            set: () => {}
        };
    let t = 0
      , n = new Map
      , s = new Map;
    const o = (a, u) => {
        n.set(a, u),
        t++,
        t > e && (t = 0,
        s = n,
        n = new Map)
    }
    ;
    return {
        get(a) {
            let u = n.get(a);
            if (u !== void 0)
                return u;
            if ((u = s.get(a)) !== void 0)
                return o(a, u),
                u
        },
        set(a, u) {
            n.has(a) ? n.set(a, u) : o(a, u)
        }
    }
}
  , ob = "!"
  , Kk = e => {
    const {separator: t, experimentalParseClassName: n} = e
      , s = t.length === 1
      , o = t[0]
      , a = t.length
      , u = c => {
        const f = [];
        let h = 0, m = 0, v;
        for (let P = 0; P < c.length; P++) {
            let _ = c[P];
            if (h === 0) {
                if (_ === o && (s || c.slice(P, P + a) === t)) {
                    f.push(c.slice(m, P)),
                    m = P + a;
                    continue
                }
                if (_ === "/") {
                    v = P;
                    continue
                }
            }
            _ === "[" ? h++ : _ === "]" && h--
        }
        const x = f.length === 0 ? c : c.substring(m)
          , T = x.startsWith(ob)
          , C = T ? x.substring(1) : x
          , S = v && v > m ? v - m : void 0;
        return {
            modifiers: f,
            hasImportantModifier: T,
            baseClassName: C,
            maybePostfixModifierPosition: S
        }
    }
    ;
    return n ? c => n({
        className: c,
        parseClassName: u
    }) : u
}
  , Gk = e => {
    if (e.length <= 1)
        return e;
    const t = [];
    let n = [];
    return e.forEach(s => {
        s[0] === "[" ? (t.push(...n.sort(), s),
        n = []) : n.push(s)
    }
    ),
    t.push(...n.sort()),
    t
}
  , Zk = e => ({
    cache: Qk(e.cacheSize),
    parseClassName: Kk(e),
    ...Uk(e)
})
  , Yk = /\s+/
  , Xk = (e, t) => {
    const {parseClassName: n, getClassGroupId: s, getConflictingClassGroupIds: o} = t
      , a = []
      , u = e.trim().split(Yk);
    let c = "";
    for (let f = u.length - 1; f >= 0; f -= 1) {
        const h = u[f]
          , {modifiers: m, hasImportantModifier: v, baseClassName: x, maybePostfixModifierPosition: T} = n(h);
        let C = !!T
          , S = s(C ? x.substring(0, T) : x);
        if (!S) {
            if (!C) {
                c = h + (c.length > 0 ? " " + c : c);
                continue
            }
            if (S = s(x),
            !S) {
                c = h + (c.length > 0 ? " " + c : c);
                continue
            }
            C = !1
        }
        const P = Gk(m).join(":")
          , _ = v ? P + ob : P
          , k = _ + S;
        if (a.includes(k))
            continue;
        a.push(k);
        const j = o(S, C);
        for (let M = 0; M < j.length; ++M) {
            const O = j[M];
            a.push(_ + O)
        }
        c = h + (c.length > 0 ? " " + c : c)
    }
    return c
}
;
function Jk() {
    let e = 0, t, n, s = "";
    for (; e < arguments.length; )
        (t = arguments[e++]) && (n = ab(t)) && (s && (s += " "),
        s += n);
    return s
}
const ab = e => {
    if (typeof e == "string")
        return e;
    let t, n = "";
    for (let s = 0; s < e.length; s++)
        e[s] && (t = ab(e[s])) && (n && (n += " "),
        n += t);
    return n
}
;
function eN(e, ...t) {
    let n, s, o, a = u;
    function u(f) {
        const h = t.reduce( (m, v) => v(m), e());
        return n = Zk(h),
        s = n.cache.get,
        o = n.cache.set,
        a = c,
        c(f)
    }
    function c(f) {
        const h = s(f);
        if (h)
            return h;
        const m = Xk(f, n);
        return o(f, m),
        m
    }
    return function() {
        return a(Jk.apply(null, arguments))
    }
}
const rt = e => {
    const t = n => n[e] || [];
    return t.isThemeGetter = !0,
    t
}
  , lb = /^\[(?:([a-z-]+):)?(.+)\]$/i
  , tN = /^\d+\/\d+$/
  , nN = new Set(["px", "full", "screen"])
  , rN = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/
  , sN = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/
  , iN = /^(rgba?|hsla?|hwb|(ok)?(lab|lch))\(.+\)$/
  , oN = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/
  , aN = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/
  , Pr = e => Qi(e) || nN.has(e) || tN.test(e)
  , rs = e => co(e, "length", mN)
  , Qi = e => !!e && !Number.isNaN(Number(e))
  , Bf = e => co(e, "number", Qi)
  , na = e => !!e && Number.isInteger(Number(e))
  , lN = e => e.endsWith("%") && Qi(e.slice(0, -1))
  , De = e => lb.test(e)
  , ss = e => rN.test(e)
  , uN = new Set(["length", "size", "percentage"])
  , cN = e => co(e, uN, ub)
  , dN = e => co(e, "position", ub)
  , fN = new Set(["image", "url"])
  , hN = e => co(e, fN, yN)
  , pN = e => co(e, "", gN)
  , ra = () => !0
  , co = (e, t, n) => {
    const s = lb.exec(e);
    return s ? s[1] ? typeof t == "string" ? s[1] === t : t.has(s[1]) : n(s[2]) : !1
}
  , mN = e => sN.test(e) && !iN.test(e)
  , ub = () => !1
  , gN = e => oN.test(e)
  , yN = e => aN.test(e)
  , vN = () => {
    const e = rt("colors")
      , t = rt("spacing")
      , n = rt("blur")
      , s = rt("brightness")
      , o = rt("borderColor")
      , a = rt("borderRadius")
      , u = rt("borderSpacing")
      , c = rt("borderWidth")
      , f = rt("contrast")
      , h = rt("grayscale")
      , m = rt("hueRotate")
      , v = rt("invert")
      , x = rt("gap")
      , T = rt("gradientColorStops")
      , C = rt("gradientColorStopPositions")
      , S = rt("inset")
      , P = rt("margin")
      , _ = rt("opacity")
      , k = rt("padding")
      , j = rt("saturate")
      , M = rt("scale")
      , O = rt("sepia")
      , z = rt("skew")
      , U = rt("space")
      , W = rt("translate")
      , oe = () => ["auto", "contain", "none"]
      , fe = () => ["auto", "hidden", "clip", "visible", "scroll"]
      , we = () => ["auto", De, t]
      , X = () => [De, t]
      , se = () => ["", Pr, rs]
      , G = () => ["auto", Qi, De]
      , be = () => ["bottom", "center", "left", "left-bottom", "left-top", "right", "right-bottom", "right-top", "top"]
      , ce = () => ["solid", "dashed", "dotted", "double", "none"]
      , ie = () => ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"]
      , B = () => ["start", "end", "center", "between", "around", "evenly", "stretch"]
      , ne = () => ["", "0", De]
      , J = () => ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"]
      , D = () => [Qi, De];
    return {
        cacheSize: 500,
        separator: ":",
        theme: {
            colors: [ra],
            spacing: [Pr, rs],
            blur: ["none", "", ss, De],
            brightness: D(),
            borderColor: [e],
            borderRadius: ["none", "", "full", ss, De],
            borderSpacing: X(),
            borderWidth: se(),
            contrast: D(),
            grayscale: ne(),
            hueRotate: D(),
            invert: ne(),
            gap: X(),
            gradientColorStops: [e],
            gradientColorStopPositions: [lN, rs],
            inset: we(),
            margin: we(),
            opacity: D(),
            padding: X(),
            saturate: D(),
            scale: D(),
            sepia: ne(),
            skew: D(),
            space: X(),
            translate: X()
        },
        classGroups: {
            aspect: [{
                aspect: ["auto", "square", "video", De]
            }],
            container: ["container"],
            columns: [{
                columns: [ss]
            }],
            "break-after": [{
                "break-after": J()
            }],
            "break-before": [{
                "break-before": J()
            }],
            "break-inside": [{
                "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"]
            }],
            "box-decoration": [{
                "box-decoration": ["slice", "clone"]
            }],
            box: [{
                box: ["border", "content"]
            }],
            display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"],
            float: [{
                float: ["right", "left", "none", "start", "end"]
            }],
            clear: [{
                clear: ["left", "right", "both", "none", "start", "end"]
            }],
            isolation: ["isolate", "isolation-auto"],
            "object-fit": [{
                object: ["contain", "cover", "fill", "none", "scale-down"]
            }],
            "object-position": [{
                object: [...be(), De]
            }],
            overflow: [{
                overflow: fe()
            }],
            "overflow-x": [{
                "overflow-x": fe()
            }],
            "overflow-y": [{
                "overflow-y": fe()
            }],
            overscroll: [{
                overscroll: oe()
            }],
            "overscroll-x": [{
                "overscroll-x": oe()
            }],
            "overscroll-y": [{
                "overscroll-y": oe()
            }],
            position: ["static", "fixed", "absolute", "relative", "sticky"],
            inset: [{
                inset: [S]
            }],
            "inset-x": [{
                "inset-x": [S]
            }],
            "inset-y": [{
                "inset-y": [S]
            }],
            start: [{
                start: [S]
            }],
            end: [{
                end: [S]
            }],
            top: [{
                top: [S]
            }],
            right: [{
                right: [S]
            }],
            bottom: [{
                bottom: [S]
            }],
            left: [{
                left: [S]
            }],
            visibility: ["visible", "invisible", "collapse"],
            z: [{
                z: ["auto", na, De]
            }],
            basis: [{
                basis: we()
            }],
            "flex-direction": [{
                flex: ["row", "row-reverse", "col", "col-reverse"]
            }],
            "flex-wrap": [{
                flex: ["wrap", "wrap-reverse", "nowrap"]
            }],
            flex: [{
                flex: ["1", "auto", "initial", "none", De]
            }],
            grow: [{
                grow: ne()
            }],
            shrink: [{
                shrink: ne()
            }],
            order: [{
                order: ["first", "last", "none", na, De]
            }],
            "grid-cols": [{
                "grid-cols": [ra]
            }],
            "col-start-end": [{
                col: ["auto", {
                    span: ["full", na, De]
                }, De]
            }],
            "col-start": [{
                "col-start": G()
            }],
            "col-end": [{
                "col-end": G()
            }],
            "grid-rows": [{
                "grid-rows": [ra]
            }],
            "row-start-end": [{
                row: ["auto", {
                    span: [na, De]
                }, De]
            }],
            "row-start": [{
                "row-start": G()
            }],
            "row-end": [{
                "row-end": G()
            }],
            "grid-flow": [{
                "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"]
            }],
            "auto-cols": [{
                "auto-cols": ["auto", "min", "max", "fr", De]
            }],
            "auto-rows": [{
                "auto-rows": ["auto", "min", "max", "fr", De]
            }],
            gap: [{
                gap: [x]
            }],
            "gap-x": [{
                "gap-x": [x]
            }],
            "gap-y": [{
                "gap-y": [x]
            }],
            "justify-content": [{
                justify: ["normal", ...B()]
            }],
            "justify-items": [{
                "justify-items": ["start", "end", "center", "stretch"]
            }],
            "justify-self": [{
                "justify-self": ["auto", "start", "end", "center", "stretch"]
            }],
            "align-content": [{
                content: ["normal", ...B(), "baseline"]
            }],
            "align-items": [{
                items: ["start", "end", "center", "baseline", "stretch"]
            }],
            "align-self": [{
                self: ["auto", "start", "end", "center", "stretch", "baseline"]
            }],
            "place-content": [{
                "place-content": [...B(), "baseline"]
            }],
            "place-items": [{
                "place-items": ["start", "end", "center", "baseline", "stretch"]
            }],
            "place-self": [{
                "place-self": ["auto", "start", "end", "center", "stretch"]
            }],
            p: [{
                p: [k]
            }],
            px: [{
                px: [k]
            }],
            py: [{
                py: [k]
            }],
            ps: [{
                ps: [k]
            }],
            pe: [{
                pe: [k]
            }],
            pt: [{
                pt: [k]
            }],
            pr: [{
                pr: [k]
            }],
            pb: [{
                pb: [k]
            }],
            pl: [{
                pl: [k]
            }],
            m: [{
                m: [P]
            }],
            mx: [{
                mx: [P]
            }],
            my: [{
                my: [P]
            }],
            ms: [{
                ms: [P]
            }],
            me: [{
                me: [P]
            }],
            mt: [{
                mt: [P]
            }],
            mr: [{
                mr: [P]
            }],
            mb: [{
                mb: [P]
            }],
            ml: [{
                ml: [P]
            }],
            "space-x": [{
                "space-x": [U]
            }],
            "space-x-reverse": ["space-x-reverse"],
            "space-y": [{
                "space-y": [U]
            }],
            "space-y-reverse": ["space-y-reverse"],
            w: [{
                w: ["auto", "min", "max", "fit", "svw", "lvw", "dvw", De, t]
            }],
            "min-w": [{
                "min-w": [De, t, "min", "max", "fit"]
            }],
            "max-w": [{
                "max-w": [De, t, "none", "full", "min", "max", "fit", "prose", {
                    screen: [ss]
                }, ss]
            }],
            h: [{
                h: [De, t, "auto", "min", "max", "fit", "svh", "lvh", "dvh"]
            }],
            "min-h": [{
                "min-h": [De, t, "min", "max", "fit", "svh", "lvh", "dvh"]
            }],
            "max-h": [{
                "max-h": [De, t, "min", "max", "fit", "svh", "lvh", "dvh"]
            }],
            size: [{
                size: [De, t, "auto", "min", "max", "fit"]
            }],
            "font-size": [{
                text: ["base", ss, rs]
            }],
            "font-smoothing": ["antialiased", "subpixel-antialiased"],
            "font-style": ["italic", "not-italic"],
            "font-weight": [{
                font: ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black", Bf]
            }],
            "font-family": [{
                font: [ra]
            }],
            "fvn-normal": ["normal-nums"],
            "fvn-ordinal": ["ordinal"],
            "fvn-slashed-zero": ["slashed-zero"],
            "fvn-figure": ["lining-nums", "oldstyle-nums"],
            "fvn-spacing": ["proportional-nums", "tabular-nums"],
            "fvn-fraction": ["diagonal-fractions", "stacked-fractions"],
            tracking: [{
                tracking: ["tighter", "tight", "normal", "wide", "wider", "widest", De]
            }],
            "line-clamp": [{
                "line-clamp": ["none", Qi, Bf]
            }],
            leading: [{
                leading: ["none", "tight", "snug", "normal", "relaxed", "loose", Pr, De]
            }],
            "list-image": [{
                "list-image": ["none", De]
            }],
            "list-style-type": [{
                list: ["none", "disc", "decimal", De]
            }],
            "list-style-position": [{
                list: ["inside", "outside"]
            }],
            "placeholder-color": [{
                placeholder: [e]
            }],
            "placeholder-opacity": [{
                "placeholder-opacity": [_]
            }],
            "text-alignment": [{
                text: ["left", "center", "right", "justify", "start", "end"]
            }],
            "text-color": [{
                text: [e]
            }],
            "text-opacity": [{
                "text-opacity": [_]
            }],
            "text-decoration": ["underline", "overline", "line-through", "no-underline"],
            "text-decoration-style": [{
                decoration: [...ce(), "wavy"]
            }],
            "text-decoration-thickness": [{
                decoration: ["auto", "from-font", Pr, rs]
            }],
            "underline-offset": [{
                "underline-offset": ["auto", Pr, De]
            }],
            "text-decoration-color": [{
                decoration: [e]
            }],
            "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"],
            "text-overflow": ["truncate", "text-ellipsis", "text-clip"],
            "text-wrap": [{
                text: ["wrap", "nowrap", "balance", "pretty"]
            }],
            indent: [{
                indent: X()
            }],
            "vertical-align": [{
                align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", De]
            }],
            whitespace: [{
                whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"]
            }],
            break: [{
                break: ["normal", "words", "all", "keep"]
            }],
            hyphens: [{
                hyphens: ["none", "manual", "auto"]
            }],
            content: [{
                content: ["none", De]
            }],
            "bg-attachment": [{
                bg: ["fixed", "local", "scroll"]
            }],
            "bg-clip": [{
                "bg-clip": ["border", "padding", "content", "text"]
            }],
            "bg-opacity": [{
                "bg-opacity": [_]
            }],
            "bg-origin": [{
                "bg-origin": ["border", "padding", "content"]
            }],
            "bg-position": [{
                bg: [...be(), dN]
            }],
            "bg-repeat": [{
                bg: ["no-repeat", {
                    repeat: ["", "x", "y", "round", "space"]
                }]
            }],
            "bg-size": [{
                bg: ["auto", "cover", "contain", cN]
            }],
            "bg-image": [{
                bg: ["none", {
                    "gradient-to": ["t", "tr", "r", "br", "b", "bl", "l", "tl"]
                }, hN]
            }],
            "bg-color": [{
                bg: [e]
            }],
            "gradient-from-pos": [{
                from: [C]
            }],
            "gradient-via-pos": [{
                via: [C]
            }],
            "gradient-to-pos": [{
                to: [C]
            }],
            "gradient-from": [{
                from: [T]
            }],
            "gradient-via": [{
                via: [T]
            }],
            "gradient-to": [{
                to: [T]
            }],
            rounded: [{
                rounded: [a]
            }],
            "rounded-s": [{
                "rounded-s": [a]
            }],
            "rounded-e": [{
                "rounded-e": [a]
            }],
            "rounded-t": [{
                "rounded-t": [a]
            }],
            "rounded-r": [{
                "rounded-r": [a]
            }],
            "rounded-b": [{
                "rounded-b": [a]
            }],
            "rounded-l": [{
                "rounded-l": [a]
            }],
            "rounded-ss": [{
                "rounded-ss": [a]
            }],
            "rounded-se": [{
                "rounded-se": [a]
            }],
            "rounded-ee": [{
                "rounded-ee": [a]
            }],
            "rounded-es": [{
                "rounded-es": [a]
            }],
            "rounded-tl": [{
                "rounded-tl": [a]
            }],
            "rounded-tr": [{
                "rounded-tr": [a]
            }],
            "rounded-br": [{
                "rounded-br": [a]
            }],
            "rounded-bl": [{
                "rounded-bl": [a]
            }],
            "border-w": [{
                border: [c]
            }],
            "border-w-x": [{
                "border-x": [c]
            }],
            "border-w-y": [{
                "border-y": [c]
            }],
            "border-w-s": [{
                "border-s": [c]
            }],
            "border-w-e": [{
                "border-e": [c]
            }],
            "border-w-t": [{
                "border-t": [c]
            }],
            "border-w-r": [{
                "border-r": [c]
            }],
            "border-w-b": [{
                "border-b": [c]
            }],
            "border-w-l": [{
                "border-l": [c]
            }],
            "border-opacity": [{
                "border-opacity": [_]
            }],
            "border-style": [{
                border: [...ce(), "hidden"]
            }],
            "divide-x": [{
                "divide-x": [c]
            }],
            "divide-x-reverse": ["divide-x-reverse"],
            "divide-y": [{
                "divide-y": [c]
            }],
            "divide-y-reverse": ["divide-y-reverse"],
            "divide-opacity": [{
                "divide-opacity": [_]
            }],
            "divide-style": [{
                divide: ce()
            }],
            "border-color": [{
                border: [o]
            }],
            "border-color-x": [{
                "border-x": [o]
            }],
            "border-color-y": [{
                "border-y": [o]
            }],
            "border-color-s": [{
                "border-s": [o]
            }],
            "border-color-e": [{
                "border-e": [o]
            }],
            "border-color-t": [{
                "border-t": [o]
            }],
            "border-color-r": [{
                "border-r": [o]
            }],
            "border-color-b": [{
                "border-b": [o]
            }],
            "border-color-l": [{
                "border-l": [o]
            }],
            "divide-color": [{
                divide: [o]
            }],
            "outline-style": [{
                outline: ["", ...ce()]
            }],
            "outline-offset": [{
                "outline-offset": [Pr, De]
            }],
            "outline-w": [{
                outline: [Pr, rs]
            }],
            "outline-color": [{
                outline: [e]
            }],
            "ring-w": [{
                ring: se()
            }],
            "ring-w-inset": ["ring-inset"],
            "ring-color": [{
                ring: [e]
            }],
            "ring-opacity": [{
                "ring-opacity": [_]
            }],
            "ring-offset-w": [{
                "ring-offset": [Pr, rs]
            }],
            "ring-offset-color": [{
                "ring-offset": [e]
            }],
            shadow: [{
                shadow: ["", "inner", "none", ss, pN]
            }],
            "shadow-color": [{
                shadow: [ra]
            }],
            opacity: [{
                opacity: [_]
            }],
            "mix-blend": [{
                "mix-blend": [...ie(), "plus-lighter", "plus-darker"]
            }],
            "bg-blend": [{
                "bg-blend": ie()
            }],
            filter: [{
                filter: ["", "none"]
            }],
            blur: [{
                blur: [n]
            }],
            brightness: [{
                brightness: [s]
            }],
            contrast: [{
                contrast: [f]
            }],
            "drop-shadow": [{
                "drop-shadow": ["", "none", ss, De]
            }],
            grayscale: [{
                grayscale: [h]
            }],
            "hue-rotate": [{
                "hue-rotate": [m]
            }],
            invert: [{
                invert: [v]
            }],
            saturate: [{
                saturate: [j]
            }],
            sepia: [{
                sepia: [O]
            }],
            "backdrop-filter": [{
                "backdrop-filter": ["", "none"]
            }],
            "backdrop-blur": [{
                "backdrop-blur": [n]
            }],
            "backdrop-brightness": [{
                "backdrop-brightness": [s]
            }],
            "backdrop-contrast": [{
                "backdrop-contrast": [f]
            }],
            "backdrop-grayscale": [{
                "backdrop-grayscale": [h]
            }],
            "backdrop-hue-rotate": [{
                "backdrop-hue-rotate": [m]
            }],
            "backdrop-invert": [{
                "backdrop-invert": [v]
            }],
            "backdrop-opacity": [{
                "backdrop-opacity": [_]
            }],
            "backdrop-saturate": [{
                "backdrop-saturate": [j]
            }],
            "backdrop-sepia": [{
                "backdrop-sepia": [O]
            }],
            "border-collapse": [{
                border: ["collapse", "separate"]
            }],
            "border-spacing": [{
                "border-spacing": [u]
            }],
            "border-spacing-x": [{
                "border-spacing-x": [u]
            }],
            "border-spacing-y": [{
                "border-spacing-y": [u]
            }],
            "table-layout": [{
                table: ["auto", "fixed"]
            }],
            caption: [{
                caption: ["top", "bottom"]
            }],
            transition: [{
                transition: ["none", "all", "", "colors", "opacity", "shadow", "transform", De]
            }],
            duration: [{
                duration: D()
            }],
            ease: [{
                ease: ["linear", "in", "out", "in-out", De]
            }],
            delay: [{
                delay: D()
            }],
            animate: [{
                animate: ["none", "spin", "ping", "pulse", "bounce", De]
            }],
            transform: [{
                transform: ["", "gpu", "none"]
            }],
            scale: [{
                scale: [M]
            }],
            "scale-x": [{
                "scale-x": [M]
            }],
            "scale-y": [{
                "scale-y": [M]
            }],
            rotate: [{
                rotate: [na, De]
            }],
            "translate-x": [{
                "translate-x": [W]
            }],
            "translate-y": [{
                "translate-y": [W]
            }],
            "skew-x": [{
                "skew-x": [z]
            }],
            "skew-y": [{
                "skew-y": [z]
            }],
            "transform-origin": [{
                origin: ["center", "top", "top-right", "right", "bottom-right", "bottom", "bottom-left", "left", "top-left", De]
            }],
            accent: [{
                accent: ["auto", e]
            }],
            appearance: [{
                appearance: ["none", "auto"]
            }],
            cursor: [{
                cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", De]
            }],
            "caret-color": [{
                caret: [e]
            }],
            "pointer-events": [{
                "pointer-events": ["none", "auto"]
            }],
            resize: [{
                resize: ["none", "y", "x", ""]
            }],
            "scroll-behavior": [{
                scroll: ["auto", "smooth"]
            }],
            "scroll-m": [{
                "scroll-m": X()
            }],
            "scroll-mx": [{
                "scroll-mx": X()
            }],
            "scroll-my": [{
                "scroll-my": X()
            }],
            "scroll-ms": [{
                "scroll-ms": X()
            }],
            "scroll-me": [{
                "scroll-me": X()
            }],
            "scroll-mt": [{
                "scroll-mt": X()
            }],
            "scroll-mr": [{
                "scroll-mr": X()
            }],
            "scroll-mb": [{
                "scroll-mb": X()
            }],
            "scroll-ml": [{
                "scroll-ml": X()
            }],
            "scroll-p": [{
                "scroll-p": X()
            }],
            "scroll-px": [{
                "scroll-px": X()
            }],
            "scroll-py": [{
                "scroll-py": X()
            }],
            "scroll-ps": [{
                "scroll-ps": X()
            }],
            "scroll-pe": [{
                "scroll-pe": X()
            }],
            "scroll-pt": [{
                "scroll-pt": X()
            }],
            "scroll-pr": [{
                "scroll-pr": X()
            }],
            "scroll-pb": [{
                "scroll-pb": X()
            }],
            "scroll-pl": [{
                "scroll-pl": X()
            }],
            "snap-align": [{
                snap: ["start", "end", "center", "align-none"]
            }],
            "snap-stop": [{
                snap: ["normal", "always"]
            }],
            "snap-type": [{
                snap: ["none", "x", "y", "both"]
            }],
            "snap-strictness": [{
                snap: ["mandatory", "proximity"]
            }],
            touch: [{
                touch: ["auto", "none", "manipulation"]
            }],
            "touch-x": [{
                "touch-pan": ["x", "left", "right"]
            }],
            "touch-y": [{
                "touch-pan": ["y", "up", "down"]
            }],
            "touch-pz": ["touch-pinch-zoom"],
            select: [{
                select: ["none", "text", "all", "auto"]
            }],
            "will-change": [{
                "will-change": ["auto", "scroll", "contents", "transform", De]
            }],
            fill: [{
                fill: [e, "none"]
            }],
            "stroke-w": [{
                stroke: [Pr, rs, Bf]
            }],
            stroke: [{
                stroke: [e, "none"]
            }],
            sr: ["sr-only", "not-sr-only"],
            "forced-color-adjust": [{
                "forced-color-adjust": ["auto", "none"]
            }]
        },
        conflictingClassGroups: {
            overflow: ["overflow-x", "overflow-y"],
            overscroll: ["overscroll-x", "overscroll-y"],
            inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"],
            "inset-x": ["right", "left"],
            "inset-y": ["top", "bottom"],
            flex: ["basis", "grow", "shrink"],
            gap: ["gap-x", "gap-y"],
            p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"],
            px: ["pr", "pl"],
            py: ["pt", "pb"],
            m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"],
            mx: ["mr", "ml"],
            my: ["mt", "mb"],
            size: ["w", "h"],
            "font-size": ["leading"],
            "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"],
            "fvn-ordinal": ["fvn-normal"],
            "fvn-slashed-zero": ["fvn-normal"],
            "fvn-figure": ["fvn-normal"],
            "fvn-spacing": ["fvn-normal"],
            "fvn-fraction": ["fvn-normal"],
            "line-clamp": ["display", "overflow"],
            rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"],
            "rounded-s": ["rounded-ss", "rounded-es"],
            "rounded-e": ["rounded-se", "rounded-ee"],
            "rounded-t": ["rounded-tl", "rounded-tr"],
            "rounded-r": ["rounded-tr", "rounded-br"],
            "rounded-b": ["rounded-br", "rounded-bl"],
            "rounded-l": ["rounded-tl", "rounded-bl"],
            "border-spacing": ["border-spacing-x", "border-spacing-y"],
            "border-w": ["border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"],
            "border-w-x": ["border-w-r", "border-w-l"],
            "border-w-y": ["border-w-t", "border-w-b"],
            "border-color": ["border-color-s", "border-color-e", "border-color-t", "border-color-r", "border-color-b", "border-color-l"],
            "border-color-x": ["border-color-r", "border-color-l"],
            "border-color-y": ["border-color-t", "border-color-b"],
            "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"],
            "scroll-mx": ["scroll-mr", "scroll-ml"],
            "scroll-my": ["scroll-mt", "scroll-mb"],
            "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"],
            "scroll-px": ["scroll-pr", "scroll-pl"],
            "scroll-py": ["scroll-pt", "scroll-pb"],
            touch: ["touch-x", "touch-y", "touch-pz"],
            "touch-x": ["touch"],
            "touch-y": ["touch"],
            "touch-pz": ["touch"]
        },
        conflictingClassGroupModifiers: {
            "font-size": ["leading"]
        }
    }
}
  , xN = eN(vN);
function Ge(...e) {
    return xN(eb(e))
}
const wN = Ek
  , cb = w.forwardRef( ({className: e, ...t}, n) => y.jsx(Qw, {
    ref: n,
    className: Ge("fixed top-0 z-[100] flex max-h-screen w-full flex-col-reverse p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:flex-col md:max-w-[420px]", e),
    ...t
}));
cb.displayName = Qw.displayName;
const bN = vc("group pointer-events-auto relative flex w-full items-center justify-between space-x-4 overflow-hidden rounded-md border p-6 pr-8 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-[var(--radix-toast-swipe-end-x)] data-[swipe=move]:translate-x-[var(--radix-toast-swipe-move-x)] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full data-[state=open]:slide-in-from-top-full data-[state=open]:sm:slide-in-from-bottom-full", {
    variants: {
        variant: {
            default: "border bg-background text-foreground",
            destructive: "destructive group border-destructive bg-destructive text-destructive-foreground"
        }
    },
    defaultVariants: {
        variant: "default"
    }
})
  , db = w.forwardRef( ({className: e, variant: t, ...n}, s) => y.jsx(Kw, {
    ref: s,
    className: Ge(bN({
        variant: t
    }), e),
    ...n
}));
db.displayName = Kw.displayName;
const SN = w.forwardRef( ({className: e, ...t}, n) => y.jsx(Yw, {
    ref: n,
    className: Ge("inline-flex h-8 shrink-0 items-center justify-center rounded-md border bg-transparent px-3 text-sm font-medium ring-offset-background transition-colors hover:bg-secondary focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 group-[.destructive]:border-muted/40 group-[.destructive]:hover:border-destructive/30 group-[.destructive]:hover:bg-destructive group-[.destructive]:hover:text-destructive-foreground group-[.destructive]:focus:ring-destructive", e),
    ...t
}));
SN.displayName = Yw.displayName;
const fb = w.forwardRef( ({className: e, ...t}, n) => y.jsx(Xw, {
    ref: n,
    className: Ge("absolute right-2 top-2 rounded-md p-1 text-foreground/50 opacity-0 transition-opacity hover:text-foreground focus:opacity-100 focus:outline-none focus:ring-2 group-hover:opacity-100 group-[.destructive]:text-red-300 group-[.destructive]:hover:text-red-50 group-[.destructive]:focus:ring-red-400 group-[.destructive]:focus:ring-offset-red-600", e),
    "toast-close": "",
    ...t,
    children: y.jsx(bp, {
        className: "h-4 w-4"
    })
}));
fb.displayName = Xw.displayName;
const hb = w.forwardRef( ({className: e, ...t}, n) => y.jsx(Gw, {
    ref: n,
    className: Ge("text-sm font-semibold", e),
    ...t
}));
hb.displayName = Gw.displayName;
const pb = w.forwardRef( ({className: e, ...t}, n) => y.jsx(Zw, {
    ref: n,
    className: Ge("text-sm opacity-90", e),
    ...t
}));
pb.displayName = Zw.displayName;
function TN() {
    const {toasts: e} = gp();
    return y.jsxs(wN, {
        children: [e.map(function({id: t, title: n, description: s, action: o, ...a}) {
            return y.jsxs(db, {
                ...a,
                children: [y.jsxs("div", {
                    className: "grid gap-1",
                    children: [n && y.jsx(hb, {
                        children: n
                    }), s && y.jsx(pb, {
                        children: s
                    })]
                }), o, y.jsx(fb, {})]
            }, t)
        }), y.jsx(cb, {})]
    })
}
var PN = iw[" useId ".trim().toString()] || ( () => {}
)
  , CN = 0;
function ga(e) {
    const [t,n] = w.useState(PN());
    return cs( () => {
        n(s => s ?? String(CN++))
    }
    , [e]),
    t ? `radix-${t}` : ""
}
const EN = ["top", "right", "bottom", "left"]
  , ds = Math.min
  , fn = Math.max
  , Fu = Math.round
  , gu = Math.floor
  , or = e => ({
    x: e,
    y: e
})
  , _N = {
    left: "right",
    right: "left",
    bottom: "top",
    top: "bottom"
}
  , kN = {
    start: "end",
    end: "start"
};
function jh(e, t, n) {
    return fn(e, ds(t, n))
}
function Or(e, t) {
    return typeof e == "function" ? e(t) : e
}
function Mr(e) {
    return e.split("-")[0]
}
function fo(e) {
    return e.split("-")[1]
}
function Tp(e) {
    return e === "x" ? "y" : "x"
}
function Pp(e) {
    return e === "y" ? "height" : "width"
}
function fs(e) {
    return ["top", "bottom"].includes(Mr(e)) ? "y" : "x"
}
function Cp(e) {
    return Tp(fs(e))
}
function NN(e, t, n) {
    n === void 0 && (n = !1);
    const s = fo(e)
      , o = Cp(e)
      , a = Pp(o);
    let u = o === "x" ? s === (n ? "end" : "start") ? "right" : "left" : s === "start" ? "bottom" : "top";
    return t.reference[a] > t.floating[a] && (u = Lu(u)),
    [u, Lu(u)]
}
function AN(e) {
    const t = Lu(e);
    return [Dh(e), t, Dh(t)]
}
function Dh(e) {
    return e.replace(/start|end/g, t => kN[t])
}
function RN(e, t, n) {
    const s = ["left", "right"]
      , o = ["right", "left"]
      , a = ["top", "bottom"]
      , u = ["bottom", "top"];
    switch (e) {
    case "top":
    case "bottom":
        return n ? t ? o : s : t ? s : o;
    case "left":
    case "right":
        return t ? a : u;
    default:
        return []
    }
}
function jN(e, t, n, s) {
    const o = fo(e);
    let a = RN(Mr(e), n === "start", s);
    return o && (a = a.map(u => u + "-" + o),
    t && (a = a.concat(a.map(Dh)))),
    a
}
function Lu(e) {
    return e.replace(/left|right|bottom|top/g, t => _N[t])
}
function DN(e) {
    return {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0,
        ...e
    }
}
function mb(e) {
    return typeof e != "number" ? DN(e) : {
        top: e,
        right: e,
        bottom: e,
        left: e
    }
}
function Vu(e) {
    const {x: t, y: n, width: s, height: o} = e;
    return {
        width: s,
        height: o,
        top: n,
        left: t,
        right: t + s,
        bottom: n + o,
        x: t,
        y: n
    }
}
function Gv(e, t, n) {
    let {reference: s, floating: o} = e;
    const a = fs(t)
      , u = Cp(t)
      , c = Pp(u)
      , f = Mr(t)
      , h = a === "y"
      , m = s.x + s.width / 2 - o.width / 2
      , v = s.y + s.height / 2 - o.height / 2
      , x = s[c] / 2 - o[c] / 2;
    let T;
    switch (f) {
    case "top":
        T = {
            x: m,
            y: s.y - o.height
        };
        break;
    case "bottom":
        T = {
            x: m,
            y: s.y + s.height
        };
        break;
    case "right":
        T = {
            x: s.x + s.width,
            y: v
        };
        break;
    case "left":
        T = {
            x: s.x - o.width,
            y: v
        };
        break;
    default:
        T = {
            x: s.x,
            y: s.y
        }
    }
    switch (fo(t)) {
    case "start":
        T[u] -= x * (n && h ? -1 : 1);
        break;
    case "end":
        T[u] += x * (n && h ? -1 : 1);
        break
    }
    return T
}
const ON = async (e, t, n) => {
    const {placement: s="bottom", strategy: o="absolute", middleware: a=[], platform: u} = n
      , c = a.filter(Boolean)
      , f = await (u.isRTL == null ? void 0 : u.isRTL(t));
    let h = await u.getElementRects({
        reference: e,
        floating: t,
        strategy: o
    })
      , {x: m, y: v} = Gv(h, s, f)
      , x = s
      , T = {}
      , C = 0;
    for (let S = 0; S < c.length; S++) {
        const {name: P, fn: _} = c[S]
          , {x: k, y: j, data: M, reset: O} = await _({
            x: m,
            y: v,
            initialPlacement: s,
            placement: x,
            strategy: o,
            middlewareData: T,
            rects: h,
            platform: u,
            elements: {
                reference: e,
                floating: t
            }
        });
        m = k ?? m,
        v = j ?? v,
        T = {
            ...T,
            [P]: {
                ...T[P],
                ...M
            }
        },
        O && C <= 50 && (C++,
        typeof O == "object" && (O.placement && (x = O.placement),
        O.rects && (h = O.rects === !0 ? await u.getElementRects({
            reference: e,
            floating: t,
            strategy: o
        }) : O.rects),
        {x: m, y: v} = Gv(h, x, f)),
        S = -1)
    }
    return {
        x: m,
        y: v,
        placement: x,
        strategy: o,
        middlewareData: T
    }
}
;
async function Ca(e, t) {
    var n;
    t === void 0 && (t = {});
    const {x: s, y: o, platform: a, rects: u, elements: c, strategy: f} = e
      , {boundary: h="clippingAncestors", rootBoundary: m="viewport", elementContext: v="floating", altBoundary: x=!1, padding: T=0} = Or(t, e)
      , C = mb(T)
      , P = c[x ? v === "floating" ? "reference" : "floating" : v]
      , _ = Vu(await a.getClippingRect({
        element: (n = await (a.isElement == null ? void 0 : a.isElement(P))) == null || n ? P : P.contextElement || await (a.getDocumentElement == null ? void 0 : a.getDocumentElement(c.floating)),
        boundary: h,
        rootBoundary: m,
        strategy: f
    }))
      , k = v === "floating" ? {
        x: s,
        y: o,
        width: u.floating.width,
        height: u.floating.height
    } : u.reference
      , j = await (a.getOffsetParent == null ? void 0 : a.getOffsetParent(c.floating))
      , M = await (a.isElement == null ? void 0 : a.isElement(j)) ? await (a.getScale == null ? void 0 : a.getScale(j)) || {
        x: 1,
        y: 1
    } : {
        x: 1,
        y: 1
    }
      , O = Vu(a.convertOffsetParentRelativeRectToViewportRelativeRect ? await a.convertOffsetParentRelativeRectToViewportRelativeRect({
        elements: c,
        rect: k,
        offsetParent: j,
        strategy: f
    }) : k);
    return {
        top: (_.top - O.top + C.top) / M.y,
        bottom: (O.bottom - _.bottom + C.bottom) / M.y,
        left: (_.left - O.left + C.left) / M.x,
        right: (O.right - _.right + C.right) / M.x
    }
}
const MN = e => ({
    name: "arrow",
    options: e,
    async fn(t) {
        const {x: n, y: s, placement: o, rects: a, platform: u, elements: c, middlewareData: f} = t
          , {element: h, padding: m=0} = Or(e, t) || {};
        if (h == null)
            return {};
        const v = mb(m)
          , x = {
            x: n,
            y: s
        }
          , T = Cp(o)
          , C = Pp(T)
          , S = await u.getDimensions(h)
          , P = T === "y"
          , _ = P ? "top" : "left"
          , k = P ? "bottom" : "right"
          , j = P ? "clientHeight" : "clientWidth"
          , M = a.reference[C] + a.reference[T] - x[T] - a.floating[C]
          , O = x[T] - a.reference[T]
          , z = await (u.getOffsetParent == null ? void 0 : u.getOffsetParent(h));
        let U = z ? z[j] : 0;
        (!U || !await (u.isElement == null ? void 0 : u.isElement(z))) && (U = c.floating[j] || a.floating[C]);
        const W = M / 2 - O / 2
          , oe = U / 2 - S[C] / 2 - 1
          , fe = ds(v[_], oe)
          , we = ds(v[k], oe)
          , X = fe
          , se = U - S[C] - we
          , G = U / 2 - S[C] / 2 + W
          , be = jh(X, G, se)
          , ce = !f.arrow && fo(o) != null && G !== be && a.reference[C] / 2 - (G < X ? fe : we) - S[C] / 2 < 0
          , ie = ce ? G < X ? G - X : G - se : 0;
        return {
            [T]: x[T] + ie,
            data: {
                [T]: be,
                centerOffset: G - be - ie,
                ...ce && {
                    alignmentOffset: ie
                }
            },
            reset: ce
        }
    }
})
  , IN = function(e) {
    return e === void 0 && (e = {}),
    {
        name: "flip",
        options: e,
        async fn(t) {
            var n, s;
            const {placement: o, middlewareData: a, rects: u, initialPlacement: c, platform: f, elements: h} = t
              , {mainAxis: m=!0, crossAxis: v=!0, fallbackPlacements: x, fallbackStrategy: T="bestFit", fallbackAxisSideDirection: C="none", flipAlignment: S=!0, ...P} = Or(e, t);
            if ((n = a.arrow) != null && n.alignmentOffset)
                return {};
            const _ = Mr(o)
              , k = fs(c)
              , j = Mr(c) === c
              , M = await (f.isRTL == null ? void 0 : f.isRTL(h.floating))
              , O = x || (j || !S ? [Lu(c)] : AN(c))
              , z = C !== "none";
            !x && z && O.push(...jN(c, S, C, M));
            const U = [c, ...O]
              , W = await Ca(t, P)
              , oe = [];
            let fe = ((s = a.flip) == null ? void 0 : s.overflows) || [];
            if (m && oe.push(W[_]),
            v) {
                const G = NN(o, u, M);
                oe.push(W[G[0]], W[G[1]])
            }
            if (fe = [...fe, {
                placement: o,
                overflows: oe
            }],
            !oe.every(G => G <= 0)) {
                var we, X;
                const G = (((we = a.flip) == null ? void 0 : we.index) || 0) + 1
                  , be = U[G];
                if (be)
                    return {
                        data: {
                            index: G,
                            overflows: fe
                        },
                        reset: {
                            placement: be
                        }
                    };
                let ce = (X = fe.filter(ie => ie.overflows[0] <= 0).sort( (ie, B) => ie.overflows[1] - B.overflows[1])[0]) == null ? void 0 : X.placement;
                if (!ce)
                    switch (T) {
                    case "bestFit":
                        {
                            var se;
                            const ie = (se = fe.filter(B => {
                                if (z) {
                                    const ne = fs(B.placement);
                                    return ne === k || ne === "y"
                                }
                                return !0
                            }
                            ).map(B => [B.placement, B.overflows.filter(ne => ne > 0).reduce( (ne, J) => ne + J, 0)]).sort( (B, ne) => B[1] - ne[1])[0]) == null ? void 0 : se[0];
                            ie && (ce = ie);
                            break
                        }
                    case "initialPlacement":
                        ce = c;
                        break
                    }
                if (o !== ce)
                    return {
                        reset: {
                            placement: ce
                        }
                    }
            }
            return {}
        }
    }
};
function Zv(e, t) {
    return {
        top: e.top - t.height,
        right: e.right - t.width,
        bottom: e.bottom - t.height,
        left: e.left - t.width
    }
}
function Yv(e) {
    return EN.some(t => e[t] >= 0)
}
const FN = function(e) {
    return e === void 0 && (e = {}),
    {
        name: "hide",
        options: e,
        async fn(t) {
            const {rects: n} = t
              , {strategy: s="referenceHidden", ...o} = Or(e, t);
            switch (s) {
            case "referenceHidden":
                {
                    const a = await Ca(t, {
                        ...o,
                        elementContext: "reference"
                    })
                      , u = Zv(a, n.reference);
                    return {
                        data: {
                            referenceHiddenOffsets: u,
                            referenceHidden: Yv(u)
                        }
                    }
                }
            case "escaped":
                {
                    const a = await Ca(t, {
                        ...o,
                        altBoundary: !0
                    })
                      , u = Zv(a, n.floating);
                    return {
                        data: {
                            escapedOffsets: u,
                            escaped: Yv(u)
                        }
                    }
                }
            default:
                return {}
            }
        }
    }
};
async function LN(e, t) {
    const {placement: n, platform: s, elements: o} = e
      , a = await (s.isRTL == null ? void 0 : s.isRTL(o.floating))
      , u = Mr(n)
      , c = fo(n)
      , f = fs(n) === "y"
      , h = ["left", "top"].includes(u) ? -1 : 1
      , m = a && f ? -1 : 1
      , v = Or(t, e);
    let {mainAxis: x, crossAxis: T, alignmentAxis: C} = typeof v == "number" ? {
        mainAxis: v,
        crossAxis: 0,
        alignmentAxis: null
    } : {
        mainAxis: v.mainAxis || 0,
        crossAxis: v.crossAxis || 0,
        alignmentAxis: v.alignmentAxis
    };
    return c && typeof C == "number" && (T = c === "end" ? C * -1 : C),
    f ? {
        x: T * m,
        y: x * h
    } : {
        x: x * h,
        y: T * m
    }
}
const VN = function(e) {
    return e === void 0 && (e = 0),
    {
        name: "offset",
        options: e,
        async fn(t) {
            var n, s;
            const {x: o, y: a, placement: u, middlewareData: c} = t
              , f = await LN(t, e);
            return u === ((n = c.offset) == null ? void 0 : n.placement) && (s = c.arrow) != null && s.alignmentOffset ? {} : {
                x: o + f.x,
                y: a + f.y,
                data: {
                    ...f,
                    placement: u
                }
            }
        }
    }
}
  , BN = function(e) {
    return e === void 0 && (e = {}),
    {
        name: "shift",
        options: e,
        async fn(t) {
            const {x: n, y: s, placement: o} = t
              , {mainAxis: a=!0, crossAxis: u=!1, limiter: c={
                fn: P => {
                    let {x: _, y: k} = P;
                    return {
                        x: _,
                        y: k
                    }
                }
            }, ...f} = Or(e, t)
              , h = {
                x: n,
                y: s
            }
              , m = await Ca(t, f)
              , v = fs(Mr(o))
              , x = Tp(v);
            let T = h[x]
              , C = h[v];
            if (a) {
                const P = x === "y" ? "top" : "left"
                  , _ = x === "y" ? "bottom" : "right"
                  , k = T + m[P]
                  , j = T - m[_];
                T = jh(k, T, j)
            }
            if (u) {
                const P = v === "y" ? "top" : "left"
                  , _ = v === "y" ? "bottom" : "right"
                  , k = C + m[P]
                  , j = C - m[_];
                C = jh(k, C, j)
            }
            const S = c.fn({
                ...t,
                [x]: T,
                [v]: C
            });
            return {
                ...S,
                data: {
                    x: S.x - n,
                    y: S.y - s,
                    enabled: {
                        [x]: a,
                        [v]: u
                    }
                }
            }
        }
    }
}
  , zN = function(e) {
    return e === void 0 && (e = {}),
    {
        options: e,
        fn(t) {
            const {x: n, y: s, placement: o, rects: a, middlewareData: u} = t
              , {offset: c=0, mainAxis: f=!0, crossAxis: h=!0} = Or(e, t)
              , m = {
                x: n,
                y: s
            }
              , v = fs(o)
              , x = Tp(v);
            let T = m[x]
              , C = m[v];
            const S = Or(c, t)
              , P = typeof S == "number" ? {
                mainAxis: S,
                crossAxis: 0
            } : {
                mainAxis: 0,
                crossAxis: 0,
                ...S
            };
            if (f) {
                const j = x === "y" ? "height" : "width"
                  , M = a.reference[x] - a.floating[j] + P.mainAxis
                  , O = a.reference[x] + a.reference[j] - P.mainAxis;
                T < M ? T = M : T > O && (T = O)
            }
            if (h) {
                var _, k;
                const j = x === "y" ? "width" : "height"
                  , M = ["top", "left"].includes(Mr(o))
                  , O = a.reference[v] - a.floating[j] + (M && ((_ = u.offset) == null ? void 0 : _[v]) || 0) + (M ? 0 : P.crossAxis)
                  , z = a.reference[v] + a.reference[j] + (M ? 0 : ((k = u.offset) == null ? void 0 : k[v]) || 0) - (M ? P.crossAxis : 0);
                C < O ? C = O : C > z && (C = z)
            }
            return {
                [x]: T,
                [v]: C
            }
        }
    }
}
  , UN = function(e) {
    return e === void 0 && (e = {}),
    {
        name: "size",
        options: e,
        async fn(t) {
            var n, s;
            const {placement: o, rects: a, platform: u, elements: c} = t
              , {apply: f= () => {}
            , ...h} = Or(e, t)
              , m = await Ca(t, h)
              , v = Mr(o)
              , x = fo(o)
              , T = fs(o) === "y"
              , {width: C, height: S} = a.floating;
            let P, _;
            v === "top" || v === "bottom" ? (P = v,
            _ = x === (await (u.isRTL == null ? void 0 : u.isRTL(c.floating)) ? "start" : "end") ? "left" : "right") : (_ = v,
            P = x === "end" ? "top" : "bottom");
            const k = S - m.top - m.bottom
              , j = C - m.left - m.right
              , M = ds(S - m[P], k)
              , O = ds(C - m[_], j)
              , z = !t.middlewareData.shift;
            let U = M
              , W = O;
            if ((n = t.middlewareData.shift) != null && n.enabled.x && (W = j),
            (s = t.middlewareData.shift) != null && s.enabled.y && (U = k),
            z && !x) {
                const fe = fn(m.left, 0)
                  , we = fn(m.right, 0)
                  , X = fn(m.top, 0)
                  , se = fn(m.bottom, 0);
                T ? W = C - 2 * (fe !== 0 || we !== 0 ? fe + we : fn(m.left, m.right)) : U = S - 2 * (X !== 0 || se !== 0 ? X + se : fn(m.top, m.bottom))
            }
            await f({
                ...t,
                availableWidth: W,
                availableHeight: U
            });
            const oe = await u.getDimensions(c.floating);
            return C !== oe.width || S !== oe.height ? {
                reset: {
                    rects: !0
                }
            } : {}
        }
    }
};
function xc() {
    return typeof window < "u"
}
function ho(e) {
    return gb(e) ? (e.nodeName || "").toLowerCase() : "#document"
}
function pn(e) {
    var t;
    return (e == null || (t = e.ownerDocument) == null ? void 0 : t.defaultView) || window
}
function pr(e) {
    var t;
    return (t = (gb(e) ? e.ownerDocument : e.document) || window.document) == null ? void 0 : t.documentElement
}
function gb(e) {
    return xc() ? e instanceof Node || e instanceof pn(e).Node : !1
}
function $n(e) {
    return xc() ? e instanceof Element || e instanceof pn(e).Element : !1
}
function cr(e) {
    return xc() ? e instanceof HTMLElement || e instanceof pn(e).HTMLElement : !1
}
function Xv(e) {
    return !xc() || typeof ShadowRoot > "u" ? !1 : e instanceof ShadowRoot || e instanceof pn(e).ShadowRoot
}
function Ka(e) {
    const {overflow: t, overflowX: n, overflowY: s, display: o} = Wn(e);
    return /auto|scroll|overlay|hidden|clip/.test(t + s + n) && !["inline", "contents"].includes(o)
}
function $N(e) {
    return ["table", "td", "th"].includes(ho(e))
}
function wc(e) {
    return [":popover-open", ":modal"].some(t => {
        try {
            return e.matches(t)
        } catch {
            return !1
        }
    }
    )
}
function Ep(e) {
    const t = _p()
      , n = $n(e) ? Wn(e) : e;
    return ["transform", "translate", "scale", "rotate", "perspective"].some(s => n[s] ? n[s] !== "none" : !1) || (n.containerType ? n.containerType !== "normal" : !1) || !t && (n.backdropFilter ? n.backdropFilter !== "none" : !1) || !t && (n.filter ? n.filter !== "none" : !1) || ["transform", "translate", "scale", "rotate", "perspective", "filter"].some(s => (n.willChange || "").includes(s)) || ["paint", "layout", "strict", "content"].some(s => (n.contain || "").includes(s))
}
function WN(e) {
    let t = hs(e);
    for (; cr(t) && !Ji(t); ) {
        if (Ep(t))
            return t;
        if (wc(t))
            return null;
        t = hs(t)
    }
    return null
}
function _p() {
    return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none")
}
function Ji(e) {
    return ["html", "body", "#document"].includes(ho(e))
}
function Wn(e) {
    return pn(e).getComputedStyle(e)
}
function bc(e) {
    return $n(e) ? {
        scrollLeft: e.scrollLeft,
        scrollTop: e.scrollTop
    } : {
        scrollLeft: e.scrollX,
        scrollTop: e.scrollY
    }
}
function hs(e) {
    if (ho(e) === "html")
        return e;
    const t = e.assignedSlot || e.parentNode || Xv(e) && e.host || pr(e);
    return Xv(t) ? t.host : t
}
function yb(e) {
    const t = hs(e);
    return Ji(t) ? e.ownerDocument ? e.ownerDocument.body : e.body : cr(t) && Ka(t) ? t : yb(t)
}
function Ea(e, t, n) {
    var s;
    t === void 0 && (t = []),
    n === void 0 && (n = !0);
    const o = yb(e)
      , a = o === ((s = e.ownerDocument) == null ? void 0 : s.body)
      , u = pn(o);
    if (a) {
        const c = Oh(u);
        return t.concat(u, u.visualViewport || [], Ka(o) ? o : [], c && n ? Ea(c) : [])
    }
    return t.concat(o, Ea(o, [], n))
}
function Oh(e) {
    return e.parent && Object.getPrototypeOf(e.parent) ? e.frameElement : null
}
function vb(e) {
    const t = Wn(e);
    let n = parseFloat(t.width) || 0
      , s = parseFloat(t.height) || 0;
    const o = cr(e)
      , a = o ? e.offsetWidth : n
      , u = o ? e.offsetHeight : s
      , c = Fu(n) !== a || Fu(s) !== u;
    return c && (n = a,
    s = u),
    {
        width: n,
        height: s,
        $: c
    }
}
function kp(e) {
    return $n(e) ? e : e.contextElement
}
function Ki(e) {
    const t = kp(e);
    if (!cr(t))
        return or(1);
    const n = t.getBoundingClientRect()
      , {width: s, height: o, $: a} = vb(t);
    let u = (a ? Fu(n.width) : n.width) / s
      , c = (a ? Fu(n.height) : n.height) / o;
    return (!u || !Number.isFinite(u)) && (u = 1),
    (!c || !Number.isFinite(c)) && (c = 1),
    {
        x: u,
        y: c
    }
}
const HN = or(0);
function xb(e) {
    const t = pn(e);
    return !_p() || !t.visualViewport ? HN : {
        x: t.visualViewport.offsetLeft,
        y: t.visualViewport.offsetTop
    }
}
function qN(e, t, n) {
    return t === void 0 && (t = !1),
    !n || t && n !== pn(e) ? !1 : t
}
function Ks(e, t, n, s) {
    t === void 0 && (t = !1),
    n === void 0 && (n = !1);
    const o = e.getBoundingClientRect()
      , a = kp(e);
    let u = or(1);
    t && (s ? $n(s) && (u = Ki(s)) : u = Ki(e));
    const c = qN(a, n, s) ? xb(a) : or(0);
    let f = (o.left + c.x) / u.x
      , h = (o.top + c.y) / u.y
      , m = o.width / u.x
      , v = o.height / u.y;
    if (a) {
        const x = pn(a)
          , T = s && $n(s) ? pn(s) : s;
        let C = x
          , S = Oh(C);
        for (; S && s && T !== C; ) {
            const P = Ki(S)
              , _ = S.getBoundingClientRect()
              , k = Wn(S)
              , j = _.left + (S.clientLeft + parseFloat(k.paddingLeft)) * P.x
              , M = _.top + (S.clientTop + parseFloat(k.paddingTop)) * P.y;
            f *= P.x,
            h *= P.y,
            m *= P.x,
            v *= P.y,
            f += j,
            h += M,
            C = pn(S),
            S = Oh(C)
        }
    }
    return Vu({
        width: m,
        height: v,
        x: f,
        y: h
    })
}
function Np(e, t) {
    const n = bc(e).scrollLeft;
    return t ? t.left + n : Ks(pr(e)).left + n
}
function wb(e, t, n) {
    n === void 0 && (n = !1);
    const s = e.getBoundingClientRect()
      , o = s.left + t.scrollLeft - (n ? 0 : Np(e, s))
      , a = s.top + t.scrollTop;
    return {
        x: o,
        y: a
    }
}
function QN(e) {
    let {elements: t, rect: n, offsetParent: s, strategy: o} = e;
    const a = o === "fixed"
      , u = pr(s)
      , c = t ? wc(t.floating) : !1;
    if (s === u || c && a)
        return n;
    let f = {
        scrollLeft: 0,
        scrollTop: 0
    }
      , h = or(1);
    const m = or(0)
      , v = cr(s);
    if ((v || !v && !a) && ((ho(s) !== "body" || Ka(u)) && (f = bc(s)),
    cr(s))) {
        const T = Ks(s);
        h = Ki(s),
        m.x = T.x + s.clientLeft,
        m.y = T.y + s.clientTop
    }
    const x = u && !v && !a ? wb(u, f, !0) : or(0);
    return {
        width: n.width * h.x,
        height: n.height * h.y,
        x: n.x * h.x - f.scrollLeft * h.x + m.x + x.x,
        y: n.y * h.y - f.scrollTop * h.y + m.y + x.y
    }
}
function KN(e) {
    return Array.from(e.getClientRects())
}
function GN(e) {
    const t = pr(e)
      , n = bc(e)
      , s = e.ownerDocument.body
      , o = fn(t.scrollWidth, t.clientWidth, s.scrollWidth, s.clientWidth)
      , a = fn(t.scrollHeight, t.clientHeight, s.scrollHeight, s.clientHeight);
    let u = -n.scrollLeft + Np(e);
    const c = -n.scrollTop;
    return Wn(s).direction === "rtl" && (u += fn(t.clientWidth, s.clientWidth) - o),
    {
        width: o,
        height: a,
        x: u,
        y: c
    }
}
function ZN(e, t) {
    const n = pn(e)
      , s = pr(e)
      , o = n.visualViewport;
    let a = s.clientWidth
      , u = s.clientHeight
      , c = 0
      , f = 0;
    if (o) {
        a = o.width,
        u = o.height;
        const h = _p();
        (!h || h && t === "fixed") && (c = o.offsetLeft,
        f = o.offsetTop)
    }
    return {
        width: a,
        height: u,
        x: c,
        y: f
    }
}
function YN(e, t) {
    const n = Ks(e, !0, t === "fixed")
      , s = n.top + e.clientTop
      , o = n.left + e.clientLeft
      , a = cr(e) ? Ki(e) : or(1)
      , u = e.clientWidth * a.x
      , c = e.clientHeight * a.y
      , f = o * a.x
      , h = s * a.y;
    return {
        width: u,
        height: c,
        x: f,
        y: h
    }
}
function Jv(e, t, n) {
    let s;
    if (t === "viewport")
        s = ZN(e, n);
    else if (t === "document")
        s = GN(pr(e));
    else if ($n(t))
        s = YN(t, n);
    else {
        const o = xb(e);
        s = {
            x: t.x - o.x,
            y: t.y - o.y,
            width: t.width,
            height: t.height
        }
    }
    return Vu(s)
}
function bb(e, t) {
    const n = hs(e);
    return n === t || !$n(n) || Ji(n) ? !1 : Wn(n).position === "fixed" || bb(n, t)
}
function XN(e, t) {
    const n = t.get(e);
    if (n)
        return n;
    let s = Ea(e, [], !1).filter(c => $n(c) && ho(c) !== "body")
      , o = null;
    const a = Wn(e).position === "fixed";
    let u = a ? hs(e) : e;
    for (; $n(u) && !Ji(u); ) {
        const c = Wn(u)
          , f = Ep(u);
        !f && c.position === "fixed" && (o = null),
        (a ? !f && !o : !f && c.position === "static" && !!o && ["absolute", "fixed"].includes(o.position) || Ka(u) && !f && bb(e, u)) ? s = s.filter(m => m !== u) : o = c,
        u = hs(u)
    }
    return t.set(e, s),
    s
}
function JN(e) {
    let {element: t, boundary: n, rootBoundary: s, strategy: o} = e;
    const u = [...n === "clippingAncestors" ? wc(t) ? [] : XN(t, this._c) : [].concat(n), s]
      , c = u[0]
      , f = u.reduce( (h, m) => {
        const v = Jv(t, m, o);
        return h.top = fn(v.top, h.top),
        h.right = ds(v.right, h.right),
        h.bottom = ds(v.bottom, h.bottom),
        h.left = fn(v.left, h.left),
        h
    }
    , Jv(t, c, o));
    return {
        width: f.right - f.left,
        height: f.bottom - f.top,
        x: f.left,
        y: f.top
    }
}
function eA(e) {
    const {width: t, height: n} = vb(e);
    return {
        width: t,
        height: n
    }
}
function tA(e, t, n) {
    const s = cr(t)
      , o = pr(t)
      , a = n === "fixed"
      , u = Ks(e, !0, a, t);
    let c = {
        scrollLeft: 0,
        scrollTop: 0
    };
    const f = or(0);
    if (s || !s && !a)
        if ((ho(t) !== "body" || Ka(o)) && (c = bc(t)),
        s) {
            const x = Ks(t, !0, a, t);
            f.x = x.x + t.clientLeft,
            f.y = x.y + t.clientTop
        } else
            o && (f.x = Np(o));
    const h = o && !s && !a ? wb(o, c) : or(0)
      , m = u.left + c.scrollLeft - f.x - h.x
      , v = u.top + c.scrollTop - f.y - h.y;
    return {
        x: m,
        y: v,
        width: u.width,
        height: u.height
    }
}
function zf(e) {
    return Wn(e).position === "static"
}
function ex(e, t) {
    if (!cr(e) || Wn(e).position === "fixed")
        return null;
    if (t)
        return t(e);
    let n = e.offsetParent;
    return pr(e) === n && (n = n.ownerDocument.body),
    n
}
function Sb(e, t) {
    const n = pn(e);
    if (wc(e))
        return n;
    if (!cr(e)) {
        let o = hs(e);
        for (; o && !Ji(o); ) {
            if ($n(o) && !zf(o))
                return o;
            o = hs(o)
        }
        return n
    }
    let s = ex(e, t);
    for (; s && $N(s) && zf(s); )
        s = ex(s, t);
    return s && Ji(s) && zf(s) && !Ep(s) ? n : s || WN(e) || n
}
const nA = async function(e) {
    const t = this.getOffsetParent || Sb
      , n = this.getDimensions
      , s = await n(e.floating);
    return {
        reference: tA(e.reference, await t(e.floating), e.strategy),
        floating: {
            x: 0,
            y: 0,
            width: s.width,
            height: s.height
        }
    }
};
function rA(e) {
    return Wn(e).direction === "rtl"
}
const sA = {
    convertOffsetParentRelativeRectToViewportRelativeRect: QN,
    getDocumentElement: pr,
    getClippingRect: JN,
    getOffsetParent: Sb,
    getElementRects: nA,
    getClientRects: KN,
    getDimensions: eA,
    getScale: Ki,
    isElement: $n,
    isRTL: rA
};
function Tb(e, t) {
    return e.x === t.x && e.y === t.y && e.width === t.width && e.height === t.height
}
function iA(e, t) {
    let n = null, s;
    const o = pr(e);
    function a() {
        var c;
        clearTimeout(s),
        (c = n) == null || c.disconnect(),
        n = null
    }
    function u(c, f) {
        c === void 0 && (c = !1),
        f === void 0 && (f = 1),
        a();
        const h = e.getBoundingClientRect()
          , {left: m, top: v, width: x, height: T} = h;
        if (c || t(),
        !x || !T)
            return;
        const C = gu(v)
          , S = gu(o.clientWidth - (m + x))
          , P = gu(o.clientHeight - (v + T))
          , _ = gu(m)
          , j = {
            rootMargin: -C + "px " + -S + "px " + -P + "px " + -_ + "px",
            threshold: fn(0, ds(1, f)) || 1
        };
        let M = !0;
        function O(z) {
            const U = z[0].intersectionRatio;
            if (U !== f) {
                if (!M)
                    return u();
                U ? u(!1, U) : s = setTimeout( () => {
                    u(!1, 1e-7)
                }
                , 1e3)
            }
            U === 1 && !Tb(h, e.getBoundingClientRect()) && u(),
            M = !1
        }
        try {
            n = new IntersectionObserver(O,{
                ...j,
                root: o.ownerDocument
            })
        } catch {
            n = new IntersectionObserver(O,j)
        }
        n.observe(e)
    }
    return u(!0),
    a
}
function oA(e, t, n, s) {
    s === void 0 && (s = {});
    const {ancestorScroll: o=!0, ancestorResize: a=!0, elementResize: u=typeof ResizeObserver == "function", layoutShift: c=typeof IntersectionObserver == "function", animationFrame: f=!1} = s
      , h = kp(e)
      , m = o || a ? [...h ? Ea(h) : [], ...Ea(t)] : [];
    m.forEach(_ => {
        o && _.addEventListener("scroll", n, {
            passive: !0
        }),
        a && _.addEventListener("resize", n)
    }
    );
    const v = h && c ? iA(h, n) : null;
    let x = -1
      , T = null;
    u && (T = new ResizeObserver(_ => {
        let[k] = _;
        k && k.target === h && T && (T.unobserve(t),
        cancelAnimationFrame(x),
        x = requestAnimationFrame( () => {
            var j;
            (j = T) == null || j.observe(t)
        }
        )),
        n()
    }
    ),
    h && !f && T.observe(h),
    T.observe(t));
    let C, S = f ? Ks(e) : null;
    f && P();
    function P() {
        const _ = Ks(e);
        S && !Tb(S, _) && n(),
        S = _,
        C = requestAnimationFrame(P)
    }
    return n(),
    () => {
        var _;
        m.forEach(k => {
            o && k.removeEventListener("scroll", n),
            a && k.removeEventListener("resize", n)
        }
        ),
        v?.(),
        (_ = T) == null || _.disconnect(),
        T = null,
        f && cancelAnimationFrame(C)
    }
}
const aA = VN
  , lA = BN
  , uA = IN
  , cA = UN
  , dA = FN
  , tx = MN
  , fA = zN
  , hA = (e, t, n) => {
    const s = new Map
      , o = {
        platform: sA,
        ...n
    }
      , a = {
        ...o.platform,
        _c: s
    };
    return ON(e, t, {
        ...o,
        platform: a
    })
}
;
var _u = typeof document < "u" ? w.useLayoutEffect : w.useEffect;
function Bu(e, t) {
    if (e === t)
        return !0;
    if (typeof e != typeof t)
        return !1;
    if (typeof e == "function" && e.toString() === t.toString())
        return !0;
    let n, s, o;
    if (e && t && typeof e == "object") {
        if (Array.isArray(e)) {
            if (n = e.length,
            n !== t.length)
                return !1;
            for (s = n; s-- !== 0; )
                if (!Bu(e[s], t[s]))
                    return !1;
            return !0
        }
        if (o = Object.keys(e),
        n = o.length,
        n !== Object.keys(t).length)
            return !1;
        for (s = n; s-- !== 0; )
            if (!{}.hasOwnProperty.call(t, o[s]))
                return !1;
        for (s = n; s-- !== 0; ) {
            const a = o[s];
            if (!(a === "_owner" && e.$$typeof) && !Bu(e[a], t[a]))
                return !1
        }
        return !0
    }
    return e !== e && t !== t
}
function Pb(e) {
    return typeof window > "u" ? 1 : (e.ownerDocument.defaultView || window).devicePixelRatio || 1
}
function nx(e, t) {
    const n = Pb(e);
    return Math.round(t * n) / n
}
function Uf(e) {
    const t = w.useRef(e);
    return _u( () => {
        t.current = e
    }
    ),
    t
}
function pA(e) {
    e === void 0 && (e = {});
    const {placement: t="bottom", strategy: n="absolute", middleware: s=[], platform: o, elements: {reference: a, floating: u}={}, transform: c=!0, whileElementsMounted: f, open: h} = e
      , [m,v] = w.useState({
        x: 0,
        y: 0,
        strategy: n,
        placement: t,
        middlewareData: {},
        isPositioned: !1
    })
      , [x,T] = w.useState(s);
    Bu(x, s) || T(s);
    const [C,S] = w.useState(null)
      , [P,_] = w.useState(null)
      , k = w.useCallback(B => {
        B !== z.current && (z.current = B,
        S(B))
    }
    , [])
      , j = w.useCallback(B => {
        B !== U.current && (U.current = B,
        _(B))
    }
    , [])
      , M = a || C
      , O = u || P
      , z = w.useRef(null)
      , U = w.useRef(null)
      , W = w.useRef(m)
      , oe = f != null
      , fe = Uf(f)
      , we = Uf(o)
      , X = Uf(h)
      , se = w.useCallback( () => {
        if (!z.current || !U.current)
            return;
        const B = {
            placement: t,
            strategy: n,
            middleware: x
        };
        we.current && (B.platform = we.current),
        hA(z.current, U.current, B).then(ne => {
            const J = {
                ...ne,
                isPositioned: X.current !== !1
            };
            G.current && !Bu(W.current, J) && (W.current = J,
            fc.flushSync( () => {
                v(J)
            }
            ))
        }
        )
    }
    , [x, t, n, we, X]);
    _u( () => {
        h === !1 && W.current.isPositioned && (W.current.isPositioned = !1,
        v(B => ({
            ...B,
            isPositioned: !1
        })))
    }
    , [h]);
    const G = w.useRef(!1);
    _u( () => (G.current = !0,
    () => {
        G.current = !1
    }
    ), []),
    _u( () => {
        if (M && (z.current = M),
        O && (U.current = O),
        M && O) {
            if (fe.current)
                return fe.current(M, O, se);
            se()
        }
    }
    , [M, O, se, fe, oe]);
    const be = w.useMemo( () => ({
        reference: z,
        floating: U,
        setReference: k,
        setFloating: j
    }), [k, j])
      , ce = w.useMemo( () => ({
        reference: M,
        floating: O
    }), [M, O])
      , ie = w.useMemo( () => {
        const B = {
            position: n,
            left: 0,
            top: 0
        };
        if (!ce.floating)
            return B;
        const ne = nx(ce.floating, m.x)
          , J = nx(ce.floating, m.y);
        return c ? {
            ...B,
            transform: "translate(" + ne + "px, " + J + "px)",
            ...Pb(ce.floating) >= 1.5 && {
                willChange: "transform"
            }
        } : {
            position: n,
            left: ne,
            top: J
        }
    }
    , [n, c, ce.floating, m.x, m.y]);
    return w.useMemo( () => ({
        ...m,
        update: se,
        refs: be,
        elements: ce,
        floatingStyles: ie
    }), [m, se, be, ce, ie])
}
const mA = e => {
    function t(n) {
        return {}.hasOwnProperty.call(n, "current")
    }
    return {
        name: "arrow",
        options: e,
        fn(n) {
            const {element: s, padding: o} = typeof e == "function" ? e(n) : e;
            return s && t(s) ? s.current != null ? tx({
                element: s.current,
                padding: o
            }).fn(n) : {} : s ? tx({
                element: s,
                padding: o
            }).fn(n) : {}
        }
    }
}
  , gA = (e, t) => ({
    ...aA(e),
    options: [e, t]
})
  , yA = (e, t) => ({
    ...lA(e),
    options: [e, t]
})
  , vA = (e, t) => ({
    ...fA(e),
    options: [e, t]
})
  , xA = (e, t) => ({
    ...uA(e),
    options: [e, t]
})
  , wA = (e, t) => ({
    ...cA(e),
    options: [e, t]
})
  , bA = (e, t) => ({
    ...dA(e),
    options: [e, t]
})
  , SA = (e, t) => ({
    ...mA(e),
    options: [e, t]
});
var TA = "Arrow"
  , Cb = w.forwardRef( (e, t) => {
    const {children: n, width: s=10, height: o=5, ...a} = e;
    return y.jsx(Xe.svg, {
        ...a,
        ref: t,
        width: s,
        height: o,
        viewBox: "0 0 30 10",
        preserveAspectRatio: "none",
        children: e.asChild ? n : y.jsx("polygon", {
            points: "0,0 30,0 15,10"
        })
    })
}
);
Cb.displayName = TA;
var PA = Cb;
function CA(e) {
    const [t,n] = w.useState(void 0);
    return cs( () => {
        if (e) {
            n({
                width: e.offsetWidth,
                height: e.offsetHeight
            });
            const s = new ResizeObserver(o => {
                if (!Array.isArray(o) || !o.length)
                    return;
                const a = o[0];
                let u, c;
                if ("borderBoxSize"in a) {
                    const f = a.borderBoxSize
                      , h = Array.isArray(f) ? f[0] : f;
                    u = h.inlineSize,
                    c = h.blockSize
                } else
                    u = e.offsetWidth,
                    c = e.offsetHeight;
                n({
                    width: u,
                    height: c
                })
            }
            );
            return s.observe(e, {
                box: "border-box"
            }),
            () => s.unobserve(e)
        } else
            n(void 0)
    }
    , [e]),
    t
}
var Eb = "Popper"
  , [_b,kb] = ei(Eb)
  , [L3,Nb] = _b(Eb)
  , Ab = "PopperAnchor"
  , Rb = w.forwardRef( (e, t) => {
    const {__scopePopper: n, virtualRef: s, ...o} = e
      , a = Nb(Ab, n)
      , u = w.useRef(null)
      , c = qt(t, u);
    return w.useEffect( () => {
        a.onAnchorChange(s?.current || u.current)
    }
    ),
    s ? null : y.jsx(Xe.div, {
        ...o,
        ref: c
    })
}
);
Rb.displayName = Ab;
var Ap = "PopperContent"
  , [EA,_A] = _b(Ap)
  , jb = w.forwardRef( (e, t) => {
    const {__scopePopper: n, side: s="bottom", sideOffset: o=0, align: a="center", alignOffset: u=0, arrowPadding: c=0, avoidCollisions: f=!0, collisionBoundary: h=[], collisionPadding: m=0, sticky: v="partial", hideWhenDetached: x=!1, updatePositionStrategy: T="optimized", onPlaced: C, ...S} = e
      , P = Nb(Ap, n)
      , [_,k] = w.useState(null)
      , j = qt(t, Ve => k(Ve))
      , [M,O] = w.useState(null)
      , z = CA(M)
      , U = z?.width ?? 0
      , W = z?.height ?? 0
      , oe = s + (a !== "center" ? "-" + a : "")
      , fe = typeof m == "number" ? m : {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0,
        ...m
    }
      , we = Array.isArray(h) ? h : [h]
      , X = we.length > 0
      , se = {
        padding: fe,
        boundary: we.filter(NA),
        altBoundary: X
    }
      , {refs: G, floatingStyles: be, placement: ce, isPositioned: ie, middlewareData: B} = pA({
        strategy: "fixed",
        placement: oe,
        whileElementsMounted: (...Ve) => oA(...Ve, {
            animationFrame: T === "always"
        }),
        elements: {
            reference: P.anchor
        },
        middleware: [gA({
            mainAxis: o + W,
            alignmentAxis: u
        }), f && yA({
            mainAxis: !0,
            crossAxis: !1,
            limiter: v === "partial" ? vA() : void 0,
            ...se
        }), f && xA({
            ...se
        }), wA({
            ...se,
            apply: ({elements: Ve, rects: ze, availableWidth: Qe, availableHeight: kt}) => {
                const {width: Kn, height: Ts} = ze.reference
                  , kn = Ve.floating.style;
                kn.setProperty("--radix-popper-available-width", `${Qe}px`),
                kn.setProperty("--radix-popper-available-height", `${kt}px`),
                kn.setProperty("--radix-popper-anchor-width", `${Kn}px`),
                kn.setProperty("--radix-popper-anchor-height", `${Ts}px`)
            }
        }), M && SA({
            element: M,
            padding: c
        }), AA({
            arrowWidth: U,
            arrowHeight: W
        }), x && bA({
            strategy: "referenceHidden",
            ...se
        })]
    })
      , [ne,J] = Mb(ce)
      , D = yn(C);
    cs( () => {
        ie && D?.()
    }
    , [ie, D]);
    const H = B.arrow?.x
      , Ce = B.arrow?.y
      , Ne = B.arrow?.centerOffset !== 0
      , [Fe,Le] = w.useState();
    return cs( () => {
        _ && Le(window.getComputedStyle(_).zIndex)
    }
    , [_]),
    y.jsx("div", {
        ref: G.setFloating,
        "data-radix-popper-content-wrapper": "",
        style: {
            ...be,
            transform: ie ? be.transform : "translate(0, -200%)",
            minWidth: "max-content",
            zIndex: Fe,
            "--radix-popper-transform-origin": [B.transformOrigin?.x, B.transformOrigin?.y].join(" "),
            ...B.hide?.referenceHidden && {
                visibility: "hidden",
                pointerEvents: "none"
            }
        },
        dir: e.dir,
        children: y.jsx(EA, {
            scope: n,
            placedSide: ne,
            onArrowChange: O,
            arrowX: H,
            arrowY: Ce,
            shouldHideArrow: Ne,
            children: y.jsx(Xe.div, {
                "data-side": ne,
                "data-align": J,
                ...S,
                ref: j,
                style: {
                    ...S.style,
                    animation: ie ? void 0 : "none"
                }
            })
        })
    })
}
);
jb.displayName = Ap;
var Db = "PopperArrow"
  , kA = {
    top: "bottom",
    right: "left",
    bottom: "top",
    left: "right"
}
  , Ob = w.forwardRef(function(t, n) {
    const {__scopePopper: s, ...o} = t
      , a = _A(Db, s)
      , u = kA[a.placedSide];
    return y.jsx("span", {
        ref: a.onArrowChange,
        style: {
            position: "absolute",
            left: a.arrowX,
            top: a.arrowY,
            [u]: 0,
            transformOrigin: {
                top: "",
                right: "0 0",
                bottom: "center 0",
                left: "100% 0"
            }[a.placedSide],
            transform: {
                top: "translateY(100%)",
                right: "translateY(50%) rotate(90deg) translateX(-50%)",
                bottom: "rotate(180deg)",
                left: "translateY(50%) rotate(-90deg) translateX(50%)"
            }[a.placedSide],
            visibility: a.shouldHideArrow ? "hidden" : void 0
        },
        children: y.jsx(PA, {
            ...o,
            ref: n,
            style: {
                ...o.style,
                display: "block"
            }
        })
    })
});
Ob.displayName = Db;
function NA(e) {
    return e !== null
}
var AA = e => ({
    name: "transformOrigin",
    options: e,
    fn(t) {
        const {placement: n, rects: s, middlewareData: o} = t
          , u = o.arrow?.centerOffset !== 0
          , c = u ? 0 : e.arrowWidth
          , f = u ? 0 : e.arrowHeight
          , [h,m] = Mb(n)
          , v = {
            start: "0%",
            center: "50%",
            end: "100%"
        }[m]
          , x = (o.arrow?.x ?? 0) + c / 2
          , T = (o.arrow?.y ?? 0) + f / 2;
        let C = ""
          , S = "";
        return h === "bottom" ? (C = u ? v : `${x}px`,
        S = `${-f}px`) : h === "top" ? (C = u ? v : `${x}px`,
        S = `${s.floating.height + f}px`) : h === "right" ? (C = `${-f}px`,
        S = u ? v : `${T}px`) : h === "left" && (C = `${s.floating.width + f}px`,
        S = u ? v : `${T}px`),
        {
            data: {
                x: C,
                y: S
            }
        }
    }
});
function Mb(e) {
    const [t,n="center"] = e.split("-");
    return [t, n]
}
var RA = Rb
  , jA = jb
  , DA = Ob
  , [Sc] = ei("Tooltip", [kb])
  , Rp = kb()
  , Ib = "TooltipProvider"
  , OA = 700
  , rx = "tooltip.open"
  , [MA,Fb] = Sc(Ib)
  , Lb = e => {
    const {__scopeTooltip: t, delayDuration: n=OA, skipDelayDuration: s=300, disableHoverableContent: o=!1, children: a} = e
      , u = w.useRef(!0)
      , c = w.useRef(!1)
      , f = w.useRef(0);
    return w.useEffect( () => {
        const h = f.current;
        return () => window.clearTimeout(h)
    }
    , []),
    y.jsx(MA, {
        scope: t,
        isOpenDelayedRef: u,
        delayDuration: n,
        onOpen: w.useCallback( () => {
            window.clearTimeout(f.current),
            u.current = !1
        }
        , []),
        onClose: w.useCallback( () => {
            window.clearTimeout(f.current),
            f.current = window.setTimeout( () => u.current = !0, s)
        }
        , [s]),
        isPointerInTransitRef: c,
        onPointerInTransitChange: w.useCallback(h => {
            c.current = h
        }
        , []),
        disableHoverableContent: o,
        children: a
    })
}
;
Lb.displayName = Ib;
var Vb = "Tooltip"
  , [V3,Tc] = Sc(Vb)
  , Mh = "TooltipTrigger"
  , IA = w.forwardRef( (e, t) => {
    const {__scopeTooltip: n, ...s} = e
      , o = Tc(Mh, n)
      , a = Fb(Mh, n)
      , u = Rp(n)
      , c = w.useRef(null)
      , f = qt(t, c, o.onTriggerChange)
      , h = w.useRef(!1)
      , m = w.useRef(!1)
      , v = w.useCallback( () => h.current = !1, []);
    return w.useEffect( () => () => document.removeEventListener("pointerup", v), [v]),
    y.jsx(RA, {
        asChild: !0,
        ...u,
        children: y.jsx(Xe.button, {
            "aria-describedby": o.open ? o.contentId : void 0,
            "data-state": o.stateAttribute,
            ...s,
            ref: f,
            onPointerMove: We(e.onPointerMove, x => {
                x.pointerType !== "touch" && !m.current && !a.isPointerInTransitRef.current && (o.onTriggerEnter(),
                m.current = !0)
            }
            ),
            onPointerLeave: We(e.onPointerLeave, () => {
                o.onTriggerLeave(),
                m.current = !1
            }
            ),
            onPointerDown: We(e.onPointerDown, () => {
                o.open && o.onClose(),
                h.current = !0,
                document.addEventListener("pointerup", v, {
                    once: !0
                })
            }
            ),
            onFocus: We(e.onFocus, () => {
                h.current || o.onOpen()
            }
            ),
            onBlur: We(e.onBlur, o.onClose),
            onClick: We(e.onClick, o.onClose)
        })
    })
}
);
IA.displayName = Mh;
var FA = "TooltipPortal"
  , [B3,LA] = Sc(FA, {
    forceMount: void 0
})
  , eo = "TooltipContent"
  , Bb = w.forwardRef( (e, t) => {
    const n = LA(eo, e.__scopeTooltip)
      , {forceMount: s=n.forceMount, side: o="top", ...a} = e
      , u = Tc(eo, e.__scopeTooltip);
    return y.jsx(ti, {
        present: s || u.open,
        children: u.disableHoverableContent ? y.jsx(zb, {
            side: o,
            ...a,
            ref: t
        }) : y.jsx(VA, {
            side: o,
            ...a,
            ref: t
        })
    })
}
)
  , VA = w.forwardRef( (e, t) => {
    const n = Tc(eo, e.__scopeTooltip)
      , s = Fb(eo, e.__scopeTooltip)
      , o = w.useRef(null)
      , a = qt(t, o)
      , [u,c] = w.useState(null)
      , {trigger: f, onClose: h} = n
      , m = o.current
      , {onPointerInTransitChange: v} = s
      , x = w.useCallback( () => {
        c(null),
        v(!1)
    }
    , [v])
      , T = w.useCallback( (C, S) => {
        const P = C.currentTarget
          , _ = {
            x: C.clientX,
            y: C.clientY
        }
          , k = WA(_, P.getBoundingClientRect())
          , j = HA(_, k)
          , M = qA(S.getBoundingClientRect())
          , O = KA([...j, ...M]);
        c(O),
        v(!0)
    }
    , [v]);
    return w.useEffect( () => () => x(), [x]),
    w.useEffect( () => {
        if (f && m) {
            const C = P => T(P, m)
              , S = P => T(P, f);
            return f.addEventListener("pointerleave", C),
            m.addEventListener("pointerleave", S),
            () => {
                f.removeEventListener("pointerleave", C),
                m.removeEventListener("pointerleave", S)
            }
        }
    }
    , [f, m, T, x]),
    w.useEffect( () => {
        if (u) {
            const C = S => {
                const P = S.target
                  , _ = {
                    x: S.clientX,
                    y: S.clientY
                }
                  , k = f?.contains(P) || m?.contains(P)
                  , j = !QA(_, u);
                k ? x() : j && (x(),
                h())
            }
            ;
            return document.addEventListener("pointermove", C),
            () => document.removeEventListener("pointermove", C)
        }
    }
    , [f, m, u, h, x]),
    y.jsx(zb, {
        ...e,
        ref: a
    })
}
)
  , [BA,zA] = Sc(Vb, {
    isInside: !1
})
  , UA = U_("TooltipContent")
  , zb = w.forwardRef( (e, t) => {
    const {__scopeTooltip: n, children: s, "aria-label": o, onEscapeKeyDown: a, onPointerDownOutside: u, ...c} = e
      , f = Tc(eo, n)
      , h = Rp(n)
      , {onClose: m} = f;
    return w.useEffect( () => (document.addEventListener(rx, m),
    () => document.removeEventListener(rx, m)), [m]),
    w.useEffect( () => {
        if (f.trigger) {
            const v = x => {
                x.target?.contains(f.trigger) && m()
            }
            ;
            return window.addEventListener("scroll", v, {
                capture: !0
            }),
            () => window.removeEventListener("scroll", v, {
                capture: !0
            })
        }
    }
    , [f.trigger, m]),
    y.jsx(hc, {
        asChild: !0,
        disableOutsidePointerEvents: !1,
        onEscapeKeyDown: a,
        onPointerDownOutside: u,
        onFocusOutside: v => v.preventDefault(),
        onDismiss: m,
        children: y.jsxs(jA, {
            "data-state": f.stateAttribute,
            ...h,
            ...c,
            ref: t,
            style: {
                ...c.style,
                "--radix-tooltip-content-transform-origin": "var(--radix-popper-transform-origin)",
                "--radix-tooltip-content-available-width": "var(--radix-popper-available-width)",
                "--radix-tooltip-content-available-height": "var(--radix-popper-available-height)",
                "--radix-tooltip-trigger-width": "var(--radix-popper-anchor-width)",
                "--radix-tooltip-trigger-height": "var(--radix-popper-anchor-height)"
            },
            children: [y.jsx(UA, {
                children: s
            }), y.jsx(BA, {
                scope: n,
                isInside: !0,
                children: y.jsx(lk, {
                    id: f.contentId,
                    role: "tooltip",
                    children: o || s
                })
            })]
        })
    })
}
);
Bb.displayName = eo;
var Ub = "TooltipArrow"
  , $A = w.forwardRef( (e, t) => {
    const {__scopeTooltip: n, ...s} = e
      , o = Rp(n);
    return zA(Ub, n).isInside ? null : y.jsx(DA, {
        ...o,
        ...s,
        ref: t
    })
}
);
$A.displayName = Ub;
function WA(e, t) {
    const n = Math.abs(t.top - e.y)
      , s = Math.abs(t.bottom - e.y)
      , o = Math.abs(t.right - e.x)
      , a = Math.abs(t.left - e.x);
    switch (Math.min(n, s, o, a)) {
    case a:
        return "left";
    case o:
        return "right";
    case n:
        return "top";
    case s:
        return "bottom";
    default:
        throw new Error("unreachable")
    }
}
function HA(e, t, n=5) {
    const s = [];
    switch (t) {
    case "top":
        s.push({
            x: e.x - n,
            y: e.y + n
        }, {
            x: e.x + n,
            y: e.y + n
        });
        break;
    case "bottom":
        s.push({
            x: e.x - n,
            y: e.y - n
        }, {
            x: e.x + n,
            y: e.y - n
        });
        break;
    case "left":
        s.push({
            x: e.x + n,
            y: e.y - n
        }, {
            x: e.x + n,
            y: e.y + n
        });
        break;
    case "right":
        s.push({
            x: e.x - n,
            y: e.y - n
        }, {
            x: e.x - n,
            y: e.y + n
        });
        break
    }
    return s
}
function qA(e) {
    const {top: t, right: n, bottom: s, left: o} = e;
    return [{
        x: o,
        y: t
    }, {
        x: n,
        y: t
    }, {
        x: n,
        y: s
    }, {
        x: o,
        y: s
    }]
}
function QA(e, t) {
    const {x: n, y: s} = e;
    let o = !1;
    for (let a = 0, u = t.length - 1; a < t.length; u = a++) {
        const c = t[a].x
          , f = t[a].y
          , h = t[u].x
          , m = t[u].y;
        f > s != m > s && n < (h - c) * (s - f) / (m - f) + c && (o = !o)
    }
    return o
}
function KA(e) {
    const t = e.slice();
    return t.sort( (n, s) => n.x < s.x ? -1 : n.x > s.x ? 1 : n.y < s.y ? -1 : n.y > s.y ? 1 : 0),
    GA(t)
}
function GA(e) {
    if (e.length <= 1)
        return e.slice();
    const t = [];
    for (let s = 0; s < e.length; s++) {
        const o = e[s];
        for (; t.length >= 2; ) {
            const a = t[t.length - 1]
              , u = t[t.length - 2];
            if ((a.x - u.x) * (o.y - u.y) >= (a.y - u.y) * (o.x - u.x))
                t.pop();
            else
                break
        }
        t.push(o)
    }
    t.pop();
    const n = [];
    for (let s = e.length - 1; s >= 0; s--) {
        const o = e[s];
        for (; n.length >= 2; ) {
            const a = n[n.length - 1]
              , u = n[n.length - 2];
            if ((a.x - u.x) * (o.y - u.y) >= (a.y - u.y) * (o.x - u.x))
                n.pop();
            else
                break
        }
        n.push(o)
    }
    return n.pop(),
    t.length === 1 && n.length === 1 && t[0].x === n[0].x && t[0].y === n[0].y ? t : t.concat(n)
}
var ZA = Lb
  , $b = Bb;
const YA = ZA
  , XA = w.forwardRef( ({className: e, sideOffset: t=4, ...n}, s) => y.jsx($b, {
    ref: s,
    sideOffset: t,
    className: Ge("z-50 overflow-hidden rounded-md border bg-popover px-3 py-1.5 text-sm text-popover-foreground shadow-md animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-tooltip-content-transform-origin]", e),
    ...n
}));
XA.displayName = $b.displayName;
const Wb = w.forwardRef( ({className: e, ...t}, n) => y.jsx("div", {
    ref: n,
    className: Ge("shadcn-card rounded-xl border bg-card border-card-border text-card-foreground shadow-sm", e),
    ...t
}));
Wb.displayName = "Card";
const JA = w.forwardRef( ({className: e, ...t}, n) => y.jsx("div", {
    ref: n,
    className: Ge("flex flex-col space-y-1.5 p-6", e),
    ...t
}));
JA.displayName = "CardHeader";
const eR = w.forwardRef( ({className: e, ...t}, n) => y.jsx("div", {
    ref: n,
    className: Ge("text-2xl font-semibold leading-none tracking-tight", e),
    ...t
}));
eR.displayName = "CardTitle";
const tR = w.forwardRef( ({className: e, ...t}, n) => y.jsx("div", {
    ref: n,
    className: Ge("text-sm text-muted-foreground", e),
    ...t
}));
tR.displayName = "CardDescription";
const Hb = w.forwardRef( ({className: e, ...t}, n) => y.jsx("div", {
    ref: n,
    className: Ge("p-6 pt-0", e),
    ...t
}));
Hb.displayName = "CardContent";
const nR = w.forwardRef( ({className: e, ...t}, n) => y.jsx("div", {
    ref: n,
    className: Ge("flex items-center p-6 pt-0", e),
    ...t
}));
nR.displayName = "CardFooter";
function rR() {
    return y.jsx("div", {
        className: "min-h-screen w-full flex items-center justify-center bg-gray-50",
        children: y.jsx(Wb, {
            className: "w-full max-w-md mx-4",
            children: y.jsxs(Hb, {
                className: "pt-6",
                children: [y.jsxs("div", {
                    className: "flex mb-4 gap-2",
                    children: [y.jsx(Rk, {
                        className: "h-8 w-8 text-red-500"
                    }), y.jsx("h1", {
                        className: "text-2xl font-bold text-gray-900",
                        children: "404 Page Not Found"
                    })]
                }), y.jsx("p", {
                    className: "mt-4 text-sm text-gray-600",
                    children: "Did you forget to add the page to the router?"
                })]
            })
        })
    })
}
var Ue;
(function(e) {
    e.assertEqual = o => o;
    function t(o) {}
    e.assertIs = t;
    function n(o) {
        throw new Error
    }
    e.assertNever = n,
    e.arrayToEnum = o => {
        const a = {};
        for (const u of o)
            a[u] = u;
        return a
    }
    ,
    e.getValidEnumValues = o => {
        const a = e.objectKeys(o).filter(c => typeof o[o[c]] != "number")
          , u = {};
        for (const c of a)
            u[c] = o[c];
        return e.objectValues(u)
    }
    ,
    e.objectValues = o => e.objectKeys(o).map(function(a) {
        return o[a]
    }),
    e.objectKeys = typeof Object.keys == "function" ? o => Object.keys(o) : o => {
        const a = [];
        for (const u in o)
            Object.prototype.hasOwnProperty.call(o, u) && a.push(u);
        return a
    }
    ,
    e.find = (o, a) => {
        for (const u of o)
            if (a(u))
                return u
    }
    ,
    e.isInteger = typeof Number.isInteger == "function" ? o => Number.isInteger(o) : o => typeof o == "number" && isFinite(o) && Math.floor(o) === o;
    function s(o, a=" | ") {
        return o.map(u => typeof u == "string" ? `'${u}'` : u).join(a)
    }
    e.joinValues = s,
    e.jsonStringifyReplacer = (o, a) => typeof a == "bigint" ? a.toString() : a
}
)(Ue || (Ue = {}));
var Ih;
(function(e) {
    e.mergeShapes = (t, n) => ({
        ...t,
        ...n
    })
}
)(Ih || (Ih = {}));
const he = Ue.arrayToEnum(["string", "nan", "number", "integer", "float", "boolean", "date", "bigint", "symbol", "function", "undefined", "null", "array", "object", "unknown", "promise", "void", "never", "map", "set"])
  , _r = e => {
    switch (typeof e) {
    case "undefined":
        return he.undefined;
    case "string":
        return he.string;
    case "number":
        return isNaN(e) ? he.nan : he.number;
    case "boolean":
        return he.boolean;
    case "function":
        return he.function;
    case "bigint":
        return he.bigint;
    case "symbol":
        return he.symbol;
    case "object":
        return Array.isArray(e) ? he.array : e === null ? he.null : e.then && typeof e.then == "function" && e.catch && typeof e.catch == "function" ? he.promise : typeof Map < "u" && e instanceof Map ? he.map : typeof Set < "u" && e instanceof Set ? he.set : typeof Date < "u" && e instanceof Date ? he.date : he.object;
    default:
        return he.unknown
    }
}
  , Y = Ue.arrayToEnum(["invalid_type", "invalid_literal", "custom", "invalid_union", "invalid_union_discriminator", "invalid_enum_value", "unrecognized_keys", "invalid_arguments", "invalid_return_type", "invalid_date", "invalid_string", "too_small", "too_big", "invalid_intersection_types", "not_multiple_of", "not_finite"])
  , sR = e => JSON.stringify(e, null, 2).replace(/"([^"]+)":/g, "$1:");
class mn extends Error {
    get errors() {
        return this.issues
    }
    constructor(t) {
        super(),
        this.issues = [],
        this.addIssue = s => {
            this.issues = [...this.issues, s]
        }
        ,
        this.addIssues = (s=[]) => {
            this.issues = [...this.issues, ...s]
        }
        ;
        const n = new.target.prototype;
        Object.setPrototypeOf ? Object.setPrototypeOf(this, n) : this.__proto__ = n,
        this.name = "ZodError",
        this.issues = t
    }
    format(t) {
        const n = t || function(a) {
            return a.message
        }
          , s = {
            _errors: []
        }
          , o = a => {
            for (const u of a.issues)
                if (u.code === "invalid_union")
                    u.unionErrors.map(o);
                else if (u.code === "invalid_return_type")
                    o(u.returnTypeError);
                else if (u.code === "invalid_arguments")
                    o(u.argumentsError);
                else if (u.path.length === 0)
                    s._errors.push(n(u));
                else {
                    let c = s
                      , f = 0;
                    for (; f < u.path.length; ) {
                        const h = u.path[f];
                        f === u.path.length - 1 ? (c[h] = c[h] || {
                            _errors: []
                        },
                        c[h]._errors.push(n(u))) : c[h] = c[h] || {
                            _errors: []
                        },
                        c = c[h],
                        f++
                    }
                }
        }
        ;
        return o(this),
        s
    }
    static assert(t) {
        if (!(t instanceof mn))
            throw new Error(`Not a ZodError: ${t}`)
    }
    toString() {
        return this.message
    }
    get message() {
        return JSON.stringify(this.issues, Ue.jsonStringifyReplacer, 2)
    }
    get isEmpty() {
        return this.issues.length === 0
    }
    flatten(t=n => n.message) {
        const n = {}
          , s = [];
        for (const o of this.issues)
            o.path.length > 0 ? (n[o.path[0]] = n[o.path[0]] || [],
            n[o.path[0]].push(t(o))) : s.push(t(o));
        return {
            formErrors: s,
            fieldErrors: n
        }
    }
    get formErrors() {
        return this.flatten()
    }
}
mn.create = e => new mn(e);
const to = (e, t) => {
    let n;
    switch (e.code) {
    case Y.invalid_type:
        e.received === he.undefined ? n = "Required" : n = `Expected ${e.expected}, received ${e.received}`;
        break;
    case Y.invalid_literal:
        n = `Invalid literal value, expected ${JSON.stringify(e.expected, Ue.jsonStringifyReplacer)}`;
        break;
    case Y.unrecognized_keys:
        n = `Unrecognized key(s) in object: ${Ue.joinValues(e.keys, ", ")}`;
        break;
    case Y.invalid_union:
        n = "Invalid input";
        break;
    case Y.invalid_union_discriminator:
        n = `Invalid discriminator value. Expected ${Ue.joinValues(e.options)}`;
        break;
    case Y.invalid_enum_value:
        n = `Invalid enum value. Expected ${Ue.joinValues(e.options)}, received '${e.received}'`;
        break;
    case Y.invalid_arguments:
        n = "Invalid function arguments";
        break;
    case Y.invalid_return_type:
        n = "Invalid function return type";
        break;
    case Y.invalid_date:
        n = "Invalid date";
        break;
    case Y.invalid_string:
        typeof e.validation == "object" ? "includes"in e.validation ? (n = `Invalid input: must include "${e.validation.includes}"`,
        typeof e.validation.position == "number" && (n = `${n} at one or more positions greater than or equal to ${e.validation.position}`)) : "startsWith"in e.validation ? n = `Invalid input: must start with "${e.validation.startsWith}"` : "endsWith"in e.validation ? n = `Invalid input: must end with "${e.validation.endsWith}"` : Ue.assertNever(e.validation) : e.validation !== "regex" ? n = `Invalid ${e.validation}` : n = "Invalid";
        break;
    case Y.too_small:
        e.type === "array" ? n = `Array must contain ${e.exact ? "exactly" : e.inclusive ? "at least" : "more than"} ${e.minimum} element(s)` : e.type === "string" ? n = `String must contain ${e.exact ? "exactly" : e.inclusive ? "at least" : "over"} ${e.minimum} character(s)` : e.type === "number" ? n = `Number must be ${e.exact ? "exactly equal to " : e.inclusive ? "greater than or equal to " : "greater than "}${e.minimum}` : e.type === "date" ? n = `Date must be ${e.exact ? "exactly equal to " : e.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(e.minimum))}` : n = "Invalid input";
        break;
    case Y.too_big:
        e.type === "array" ? n = `Array must contain ${e.exact ? "exactly" : e.inclusive ? "at most" : "less than"} ${e.maximum} element(s)` : e.type === "string" ? n = `String must contain ${e.exact ? "exactly" : e.inclusive ? "at most" : "under"} ${e.maximum} character(s)` : e.type === "number" ? n = `Number must be ${e.exact ? "exactly" : e.inclusive ? "less than or equal to" : "less than"} ${e.maximum}` : e.type === "bigint" ? n = `BigInt must be ${e.exact ? "exactly" : e.inclusive ? "less than or equal to" : "less than"} ${e.maximum}` : e.type === "date" ? n = `Date must be ${e.exact ? "exactly" : e.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(e.maximum))}` : n = "Invalid input";
        break;
    case Y.custom:
        n = "Invalid input";
        break;
    case Y.invalid_intersection_types:
        n = "Intersection results could not be merged";
        break;
    case Y.not_multiple_of:
        n = `Number must be a multiple of ${e.multipleOf}`;
        break;
    case Y.not_finite:
        n = "Number must be finite";
        break;
    default:
        n = t.defaultError,
        Ue.assertNever(e)
    }
    return {
        message: n
    }
}
;
let qb = to;
function iR(e) {
    qb = e
}
function zu() {
    return qb
}
const Uu = e => {
    const {data: t, path: n, errorMaps: s, issueData: o} = e
      , a = [...n, ...o.path || []]
      , u = {
        ...o,
        path: a
    };
    if (o.message !== void 0)
        return {
            ...o,
            path: a,
            message: o.message
        };
    let c = "";
    const f = s.filter(h => !!h).slice().reverse();
    for (const h of f)
        c = h(u, {
            data: t,
            defaultError: c
        }).message;
    return {
        ...o,
        path: a,
        message: c
    }
}
  , oR = [];
function le(e, t) {
    const n = zu()
      , s = Uu({
        issueData: t,
        data: e.data,
        path: e.path,
        errorMaps: [e.common.contextualErrorMap, e.schemaErrorMap, n, n === to ? void 0 : to].filter(o => !!o)
    });
    e.common.issues.push(s)
}
class Qt {
    constructor() {
        this.value = "valid"
    }
    dirty() {
        this.value === "valid" && (this.value = "dirty")
    }
    abort() {
        this.value !== "aborted" && (this.value = "aborted")
    }
    static mergeArray(t, n) {
        const s = [];
        for (const o of n) {
            if (o.status === "aborted")
                return _e;
            o.status === "dirty" && t.dirty(),
            s.push(o.value)
        }
        return {
            status: t.value,
            value: s
        }
    }
    static async mergeObjectAsync(t, n) {
        const s = [];
        for (const o of n) {
            const a = await o.key
              , u = await o.value;
            s.push({
                key: a,
                value: u
            })
        }
        return Qt.mergeObjectSync(t, s)
    }
    static mergeObjectSync(t, n) {
        const s = {};
        for (const o of n) {
            const {key: a, value: u} = o;
            if (a.status === "aborted" || u.status === "aborted")
                return _e;
            a.status === "dirty" && t.dirty(),
            u.status === "dirty" && t.dirty(),
            a.value !== "__proto__" && (typeof u.value < "u" || o.alwaysSet) && (s[a.value] = u.value)
        }
        return {
            status: t.value,
            value: s
        }
    }
}
const _e = Object.freeze({
    status: "aborted"
})
  , Bi = e => ({
    status: "dirty",
    value: e
})
  , Xt = e => ({
    status: "valid",
    value: e
})
  , Fh = e => e.status === "aborted"
  , Lh = e => e.status === "dirty"
  , Gs = e => e.status === "valid"
  , _a = e => typeof Promise < "u" && e instanceof Promise;
function $u(e, t, n, s) {
    if (typeof t == "function" ? e !== t || !0 : !t.has(e))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return t.get(e)
}
function Qb(e, t, n, s, o) {
    if (typeof t == "function" ? e !== t || !0 : !t.has(e))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return t.set(e, n),
    n
}
var xe;
(function(e) {
    e.errToObj = t => typeof t == "string" ? {
        message: t
    } : t || {},
    e.toString = t => typeof t == "string" ? t : t?.message
}
)(xe || (xe = {}));
var ua, ca;
class dr {
    constructor(t, n, s, o) {
        this._cachedPath = [],
        this.parent = t,
        this.data = n,
        this._path = s,
        this._key = o
    }
    get path() {
        return this._cachedPath.length || (this._key instanceof Array ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)),
        this._cachedPath
    }
}
const sx = (e, t) => {
    if (Gs(t))
        return {
            success: !0,
            data: t.value
        };
    if (!e.common.issues.length)
        throw new Error("Validation failed but no issues detected.");
    return {
        success: !1,
        get error() {
            if (this._error)
                return this._error;
            const n = new mn(e.common.issues);
            return this._error = n,
            this._error
        }
    }
}
;
function je(e) {
    if (!e)
        return {};
    const {errorMap: t, invalid_type_error: n, required_error: s, description: o} = e;
    if (t && (n || s))
        throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
    return t ? {
        errorMap: t,
        description: o
    } : {
        errorMap: (u, c) => {
            var f, h;
            const {message: m} = e;
            return u.code === "invalid_enum_value" ? {
                message: m ?? c.defaultError
            } : typeof c.data > "u" ? {
                message: (f = m ?? s) !== null && f !== void 0 ? f : c.defaultError
            } : u.code !== "invalid_type" ? {
                message: c.defaultError
            } : {
                message: (h = m ?? n) !== null && h !== void 0 ? h : c.defaultError
            }
        }
        ,
        description: o
    }
}
class Me {
    get description() {
        return this._def.description
    }
    _getType(t) {
        return _r(t.data)
    }
    _getOrReturnCtx(t, n) {
        return n || {
            common: t.parent.common,
            data: t.data,
            parsedType: _r(t.data),
            schemaErrorMap: this._def.errorMap,
            path: t.path,
            parent: t.parent
        }
    }
    _processInputParams(t) {
        return {
            status: new Qt,
            ctx: {
                common: t.parent.common,
                data: t.data,
                parsedType: _r(t.data),
                schemaErrorMap: this._def.errorMap,
                path: t.path,
                parent: t.parent
            }
        }
    }
    _parseSync(t) {
        const n = this._parse(t);
        if (_a(n))
            throw new Error("Synchronous parse encountered promise.");
        return n
    }
    _parseAsync(t) {
        const n = this._parse(t);
        return Promise.resolve(n)
    }
    parse(t, n) {
        const s = this.safeParse(t, n);
        if (s.success)
            return s.data;
        throw s.error
    }
    safeParse(t, n) {
        var s;
        const o = {
            common: {
                issues: [],
                async: (s = n?.async) !== null && s !== void 0 ? s : !1,
                contextualErrorMap: n?.errorMap
            },
            path: n?.path || [],
            schemaErrorMap: this._def.errorMap,
            parent: null,
            data: t,
            parsedType: _r(t)
        }
          , a = this._parseSync({
            data: t,
            path: o.path,
            parent: o
        });
        return sx(o, a)
    }
    "~validate"(t) {
        var n, s;
        const o = {
            common: {
                issues: [],
                async: !!this["~standard"].async
            },
            path: [],
            schemaErrorMap: this._def.errorMap,
            parent: null,
            data: t,
            parsedType: _r(t)
        };
        if (!this["~standard"].async)
            try {
                const a = this._parseSync({
                    data: t,
                    path: [],
                    parent: o
                });
                return Gs(a) ? {
                    value: a.value
                } : {
                    issues: o.common.issues
                }
            } catch (a) {
                !((s = (n = a?.message) === null || n === void 0 ? void 0 : n.toLowerCase()) === null || s === void 0) && s.includes("encountered") && (this["~standard"].async = !0),
                o.common = {
                    issues: [],
                    async: !0
                }
            }
        return this._parseAsync({
            data: t,
            path: [],
            parent: o
        }).then(a => Gs(a) ? {
            value: a.value
        } : {
            issues: o.common.issues
        })
    }
    async parseAsync(t, n) {
        const s = await this.safeParseAsync(t, n);
        if (s.success)
            return s.data;
        throw s.error
    }
    async safeParseAsync(t, n) {
        const s = {
            common: {
                issues: [],
                contextualErrorMap: n?.errorMap,
                async: !0
            },
            path: n?.path || [],
            schemaErrorMap: this._def.errorMap,
            parent: null,
            data: t,
            parsedType: _r(t)
        }
          , o = this._parse({
            data: t,
            path: s.path,
            parent: s
        })
          , a = await (_a(o) ? o : Promise.resolve(o));
        return sx(s, a)
    }
    refine(t, n) {
        const s = o => typeof n == "string" || typeof n > "u" ? {
            message: n
        } : typeof n == "function" ? n(o) : n;
        return this._refinement( (o, a) => {
            const u = t(o)
              , c = () => a.addIssue({
                code: Y.custom,
                ...s(o)
            });
            return typeof Promise < "u" && u instanceof Promise ? u.then(f => f ? !0 : (c(),
            !1)) : u ? !0 : (c(),
            !1)
        }
        )
    }
    refinement(t, n) {
        return this._refinement( (s, o) => t(s) ? !0 : (o.addIssue(typeof n == "function" ? n(s, o) : n),
        !1))
    }
    _refinement(t) {
        return new Hn({
            schema: this,
            typeName: Ee.ZodEffects,
            effect: {
                type: "refinement",
                refinement: t
            }
        })
    }
    superRefine(t) {
        return this._refinement(t)
    }
    constructor(t) {
        this.spa = this.safeParseAsync,
        this._def = t,
        this.parse = this.parse.bind(this),
        this.safeParse = this.safeParse.bind(this),
        this.parseAsync = this.parseAsync.bind(this),
        this.safeParseAsync = this.safeParseAsync.bind(this),
        this.spa = this.spa.bind(this),
        this.refine = this.refine.bind(this),
        this.refinement = this.refinement.bind(this),
        this.superRefine = this.superRefine.bind(this),
        this.optional = this.optional.bind(this),
        this.nullable = this.nullable.bind(this),
        this.nullish = this.nullish.bind(this),
        this.array = this.array.bind(this),
        this.promise = this.promise.bind(this),
        this.or = this.or.bind(this),
        this.and = this.and.bind(this),
        this.transform = this.transform.bind(this),
        this.brand = this.brand.bind(this),
        this.default = this.default.bind(this),
        this.catch = this.catch.bind(this),
        this.describe = this.describe.bind(this),
        this.pipe = this.pipe.bind(this),
        this.readonly = this.readonly.bind(this),
        this.isNullable = this.isNullable.bind(this),
        this.isOptional = this.isOptional.bind(this),
        this["~standard"] = {
            version: 1,
            vendor: "zod",
            validate: n => this["~validate"](n)
        }
    }
    optional() {
        return ar.create(this, this._def)
    }
    nullable() {
        return ys.create(this, this._def)
    }
    nullish() {
        return this.nullable().optional()
    }
    array() {
        return Un.create(this)
    }
    promise() {
        return ro.create(this, this._def)
    }
    or(t) {
        return Ra.create([this, t], this._def)
    }
    and(t) {
        return ja.create(this, t, this._def)
    }
    transform(t) {
        return new Hn({
            ...je(this._def),
            schema: this,
            typeName: Ee.ZodEffects,
            effect: {
                type: "transform",
                transform: t
            }
        })
    }
    default(t) {
        const n = typeof t == "function" ? t : () => t;
        return new Fa({
            ...je(this._def),
            innerType: this,
            defaultValue: n,
            typeName: Ee.ZodDefault
        })
    }
    brand() {
        return new jp({
            typeName: Ee.ZodBranded,
            type: this,
            ...je(this._def)
        })
    }
    catch(t) {
        const n = typeof t == "function" ? t : () => t;
        return new La({
            ...je(this._def),
            innerType: this,
            catchValue: n,
            typeName: Ee.ZodCatch
        })
    }
    describe(t) {
        const n = this.constructor;
        return new n({
            ...this._def,
            description: t
        })
    }
    pipe(t) {
        return Ga.create(this, t)
    }
    readonly() {
        return Va.create(this)
    }
    isOptional() {
        return this.safeParse(void 0).success
    }
    isNullable() {
        return this.safeParse(null).success
    }
}
const aR = /^c[^\s-]{8,}$/i
  , lR = /^[0-9a-z]+$/
  , uR = /^[0-9A-HJKMNP-TV-Z]{26}$/i
  , cR = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i
  , dR = /^[a-z0-9_-]{21}$/i
  , fR = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/
  , hR = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/
  , pR = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i
  , mR = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
let $f;
const gR = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/
  , yR = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/
  , vR = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/
  , xR = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/
  , wR = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/
  , bR = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/
  , Kb = "((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))"
  , SR = new RegExp(`^${Kb}$`);
function Gb(e) {
    let t = "([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d";
    return e.precision ? t = `${t}\\.\\d{${e.precision}}` : e.precision == null && (t = `${t}(\\.\\d+)?`),
    t
}
function TR(e) {
    return new RegExp(`^${Gb(e)}$`)
}
function Zb(e) {
    let t = `${Kb}T${Gb(e)}`;
    const n = [];
    return n.push(e.local ? "Z?" : "Z"),
    e.offset && n.push("([+-]\\d{2}:?\\d{2})"),
    t = `${t}(${n.join("|")})`,
    new RegExp(`^${t}$`)
}
function PR(e, t) {
    return !!((t === "v4" || !t) && gR.test(e) || (t === "v6" || !t) && vR.test(e))
}
function CR(e, t) {
    if (!fR.test(e))
        return !1;
    try {
        const [n] = e.split(".")
          , s = n.replace(/-/g, "+").replace(/_/g, "/").padEnd(n.length + (4 - n.length % 4) % 4, "=")
          , o = JSON.parse(atob(s));
        return !(typeof o != "object" || o === null || !o.typ || !o.alg || t && o.alg !== t)
    } catch {
        return !1
    }
}
function ER(e, t) {
    return !!((t === "v4" || !t) && yR.test(e) || (t === "v6" || !t) && xR.test(e))
}
class zn extends Me {
    _parse(t) {
        if (this._def.coerce && (t.data = String(t.data)),
        this._getType(t) !== he.string) {
            const a = this._getOrReturnCtx(t);
            return le(a, {
                code: Y.invalid_type,
                expected: he.string,
                received: a.parsedType
            }),
            _e
        }
        const s = new Qt;
        let o;
        for (const a of this._def.checks)
            if (a.kind === "min")
                t.data.length < a.value && (o = this._getOrReturnCtx(t, o),
                le(o, {
                    code: Y.too_small,
                    minimum: a.value,
                    type: "string",
                    inclusive: !0,
                    exact: !1,
                    message: a.message
                }),
                s.dirty());
            else if (a.kind === "max")
                t.data.length > a.value && (o = this._getOrReturnCtx(t, o),
                le(o, {
                    code: Y.too_big,
                    maximum: a.value,
                    type: "string",
                    inclusive: !0,
                    exact: !1,
                    message: a.message
                }),
                s.dirty());
            else if (a.kind === "length") {
                const u = t.data.length > a.value
                  , c = t.data.length < a.value;
                (u || c) && (o = this._getOrReturnCtx(t, o),
                u ? le(o, {
                    code: Y.too_big,
                    maximum: a.value,
                    type: "string",
                    inclusive: !0,
                    exact: !0,
                    message: a.message
                }) : c && le(o, {
                    code: Y.too_small,
                    minimum: a.value,
                    type: "string",
                    inclusive: !0,
                    exact: !0,
                    message: a.message
                }),
                s.dirty())
            } else if (a.kind === "email")
                pR.test(t.data) || (o = this._getOrReturnCtx(t, o),
                le(o, {
                    validation: "email",
                    code: Y.invalid_string,
                    message: a.message
                }),
                s.dirty());
            else if (a.kind === "emoji")
                $f || ($f = new RegExp(mR,"u")),
                $f.test(t.data) || (o = this._getOrReturnCtx(t, o),
                le(o, {
                    validation: "emoji",
                    code: Y.invalid_string,
                    message: a.message
                }),
                s.dirty());
            else if (a.kind === "uuid")
                cR.test(t.data) || (o = this._getOrReturnCtx(t, o),
                le(o, {
                    validation: "uuid",
                    code: Y.invalid_string,
                    message: a.message
                }),
                s.dirty());
            else if (a.kind === "nanoid")
                dR.test(t.data) || (o = this._getOrReturnCtx(t, o),
                le(o, {
                    validation: "nanoid",
                    code: Y.invalid_string,
                    message: a.message
                }),
                s.dirty());
            else if (a.kind === "cuid")
                aR.test(t.data) || (o = this._getOrReturnCtx(t, o),
                le(o, {
                    validation: "cuid",
                    code: Y.invalid_string,
                    message: a.message
                }),
                s.dirty());
            else if (a.kind === "cuid2")
                lR.test(t.data) || (o = this._getOrReturnCtx(t, o),
                le(o, {
                    validation: "cuid2",
                    code: Y.invalid_string,
                    message: a.message
                }),
                s.dirty());
            else if (a.kind === "ulid")
                uR.test(t.data) || (o = this._getOrReturnCtx(t, o),
                le(o, {
                    validation: "ulid",
                    code: Y.invalid_string,
                    message: a.message
                }),
                s.dirty());
            else if (a.kind === "url")
                try {
                    new URL(t.data)
                } catch {
                    o = this._getOrReturnCtx(t, o),
                    le(o, {
                        validation: "url",
                        code: Y.invalid_string,
                        message: a.message
                    }),
                    s.dirty()
                }
            else
                a.kind === "regex" ? (a.regex.lastIndex = 0,
                a.regex.test(t.data) || (o = this._getOrReturnCtx(t, o),
                le(o, {
                    validation: "regex",
                    code: Y.invalid_string,
                    message: a.message
                }),
                s.dirty())) : a.kind === "trim" ? t.data = t.data.trim() : a.kind === "includes" ? t.data.includes(a.value, a.position) || (o = this._getOrReturnCtx(t, o),
                le(o, {
                    code: Y.invalid_string,
                    validation: {
                        includes: a.value,
                        position: a.position
                    },
                    message: a.message
                }),
                s.dirty()) : a.kind === "toLowerCase" ? t.data = t.data.toLowerCase() : a.kind === "toUpperCase" ? t.data = t.data.toUpperCase() : a.kind === "startsWith" ? t.data.startsWith(a.value) || (o = this._getOrReturnCtx(t, o),
                le(o, {
                    code: Y.invalid_string,
                    validation: {
                        startsWith: a.value
                    },
                    message: a.message
                }),
                s.dirty()) : a.kind === "endsWith" ? t.data.endsWith(a.value) || (o = this._getOrReturnCtx(t, o),
                le(o, {
                    code: Y.invalid_string,
                    validation: {
                        endsWith: a.value
                    },
                    message: a.message
                }),
                s.dirty()) : a.kind === "datetime" ? Zb(a).test(t.data) || (o = this._getOrReturnCtx(t, o),
                le(o, {
                    code: Y.invalid_string,
                    validation: "datetime",
                    message: a.message
                }),
                s.dirty()) : a.kind === "date" ? SR.test(t.data) || (o = this._getOrReturnCtx(t, o),
                le(o, {
                    code: Y.invalid_string,
                    validation: "date",
                    message: a.message
                }),
                s.dirty()) : a.kind === "time" ? TR(a).test(t.data) || (o = this._getOrReturnCtx(t, o),
                le(o, {
                    code: Y.invalid_string,
                    validation: "time",
                    message: a.message
                }),
                s.dirty()) : a.kind === "duration" ? hR.test(t.data) || (o = this._getOrReturnCtx(t, o),
                le(o, {
                    validation: "duration",
                    code: Y.invalid_string,
                    message: a.message
                }),
                s.dirty()) : a.kind === "ip" ? PR(t.data, a.version) || (o = this._getOrReturnCtx(t, o),
                le(o, {
                    validation: "ip",
                    code: Y.invalid_string,
                    message: a.message
                }),
                s.dirty()) : a.kind === "jwt" ? CR(t.data, a.alg) || (o = this._getOrReturnCtx(t, o),
                le(o, {
                    validation: "jwt",
                    code: Y.invalid_string,
                    message: a.message
                }),
                s.dirty()) : a.kind === "cidr" ? ER(t.data, a.version) || (o = this._getOrReturnCtx(t, o),
                le(o, {
                    validation: "cidr",
                    code: Y.invalid_string,
                    message: a.message
                }),
                s.dirty()) : a.kind === "base64" ? wR.test(t.data) || (o = this._getOrReturnCtx(t, o),
                le(o, {
                    validation: "base64",
                    code: Y.invalid_string,
                    message: a.message
                }),
                s.dirty()) : a.kind === "base64url" ? bR.test(t.data) || (o = this._getOrReturnCtx(t, o),
                le(o, {
                    validation: "base64url",
                    code: Y.invalid_string,
                    message: a.message
                }),
                s.dirty()) : Ue.assertNever(a);
        return {
            status: s.value,
            value: t.data
        }
    }
    _regex(t, n, s) {
        return this.refinement(o => t.test(o), {
            validation: n,
            code: Y.invalid_string,
            ...xe.errToObj(s)
        })
    }
    _addCheck(t) {
        return new zn({
            ...this._def,
            checks: [...this._def.checks, t]
        })
    }
    email(t) {
        return this._addCheck({
            kind: "email",
            ...xe.errToObj(t)
        })
    }
    url(t) {
        return this._addCheck({
            kind: "url",
            ...xe.errToObj(t)
        })
    }
    emoji(t) {
        return this._addCheck({
            kind: "emoji",
            ...xe.errToObj(t)
        })
    }
    uuid(t) {
        return this._addCheck({
            kind: "uuid",
            ...xe.errToObj(t)
        })
    }
    nanoid(t) {
        return this._addCheck({
            kind: "nanoid",
            ...xe.errToObj(t)
        })
    }
    cuid(t) {
        return this._addCheck({
            kind: "cuid",
            ...xe.errToObj(t)
        })
    }
    cuid2(t) {
        return this._addCheck({
            kind: "cuid2",
            ...xe.errToObj(t)
        })
    }
    ulid(t) {
        return this._addCheck({
            kind: "ulid",
            ...xe.errToObj(t)
        })
    }
    base64(t) {
        return this._addCheck({
            kind: "base64",
            ...xe.errToObj(t)
        })
    }
    base64url(t) {
        return this._addCheck({
            kind: "base64url",
            ...xe.errToObj(t)
        })
    }
    jwt(t) {
        return this._addCheck({
            kind: "jwt",
            ...xe.errToObj(t)
        })
    }
    ip(t) {
        return this._addCheck({
            kind: "ip",
            ...xe.errToObj(t)
        })
    }
    cidr(t) {
        return this._addCheck({
            kind: "cidr",
            ...xe.errToObj(t)
        })
    }
    datetime(t) {
        var n, s;
        return typeof t == "string" ? this._addCheck({
            kind: "datetime",
            precision: null,
            offset: !1,
            local: !1,
            message: t
        }) : this._addCheck({
            kind: "datetime",
            precision: typeof t?.precision > "u" ? null : t?.precision,
            offset: (n = t?.offset) !== null && n !== void 0 ? n : !1,
            local: (s = t?.local) !== null && s !== void 0 ? s : !1,
            ...xe.errToObj(t?.message)
        })
    }
    date(t) {
        return this._addCheck({
            kind: "date",
            message: t
        })
    }
    time(t) {
        return typeof t == "string" ? this._addCheck({
            kind: "time",
            precision: null,
            message: t
        }) : this._addCheck({
            kind: "time",
            precision: typeof t?.precision > "u" ? null : t?.precision,
            ...xe.errToObj(t?.message)
        })
    }
    duration(t) {
        return this._addCheck({
            kind: "duration",
            ...xe.errToObj(t)
        })
    }
    regex(t, n) {
        return this._addCheck({
            kind: "regex",
            regex: t,
            ...xe.errToObj(n)
        })
    }
    includes(t, n) {
        return this._addCheck({
            kind: "includes",
            value: t,
            position: n?.position,
            ...xe.errToObj(n?.message)
        })
    }
    startsWith(t, n) {
        return this._addCheck({
            kind: "startsWith",
            value: t,
            ...xe.errToObj(n)
        })
    }
    endsWith(t, n) {
        return this._addCheck({
            kind: "endsWith",
            value: t,
            ...xe.errToObj(n)
        })
    }
    min(t, n) {
        return this._addCheck({
            kind: "min",
            value: t,
            ...xe.errToObj(n)
        })
    }
    max(t, n) {
        return this._addCheck({
            kind: "max",
            value: t,
            ...xe.errToObj(n)
        })
    }
    length(t, n) {
        return this._addCheck({
            kind: "length",
            value: t,
            ...xe.errToObj(n)
        })
    }
    nonempty(t) {
        return this.min(1, xe.errToObj(t))
    }
    trim() {
        return new zn({
            ...this._def,
            checks: [...this._def.checks, {
                kind: "trim"
            }]
        })
    }
    toLowerCase() {
        return new zn({
            ...this._def,
            checks: [...this._def.checks, {
                kind: "toLowerCase"
            }]
        })
    }
    toUpperCase() {
        return new zn({
            ...this._def,
            checks: [...this._def.checks, {
                kind: "toUpperCase"
            }]
        })
    }
    get isDatetime() {
        return !!this._def.checks.find(t => t.kind === "datetime")
    }
    get isDate() {
        return !!this._def.checks.find(t => t.kind === "date")
    }
    get isTime() {
        return !!this._def.checks.find(t => t.kind === "time")
    }
    get isDuration() {
        return !!this._def.checks.find(t => t.kind === "duration")
    }
    get isEmail() {
        return !!this._def.checks.find(t => t.kind === "email")
    }
    get isURL() {
        return !!this._def.checks.find(t => t.kind === "url")
    }
    get isEmoji() {
        return !!this._def.checks.find(t => t.kind === "emoji")
    }
    get isUUID() {
        return !!this._def.checks.find(t => t.kind === "uuid")
    }
    get isNANOID() {
        return !!this._def.checks.find(t => t.kind === "nanoid")
    }
    get isCUID() {
        return !!this._def.checks.find(t => t.kind === "cuid")
    }
    get isCUID2() {
        return !!this._def.checks.find(t => t.kind === "cuid2")
    }
    get isULID() {
        return !!this._def.checks.find(t => t.kind === "ulid")
    }
    get isIP() {
        return !!this._def.checks.find(t => t.kind === "ip")
    }
    get isCIDR() {
        return !!this._def.checks.find(t => t.kind === "cidr")
    }
    get isBase64() {
        return !!this._def.checks.find(t => t.kind === "base64")
    }
    get isBase64url() {
        return !!this._def.checks.find(t => t.kind === "base64url")
    }
    get minLength() {
        let t = null;
        for (const n of this._def.checks)
            n.kind === "min" && (t === null || n.value > t) && (t = n.value);
        return t
    }
    get maxLength() {
        let t = null;
        for (const n of this._def.checks)
            n.kind === "max" && (t === null || n.value < t) && (t = n.value);
        return t
    }
}
zn.create = e => {
    var t;
    return new zn({
        checks: [],
        typeName: Ee.ZodString,
        coerce: (t = e?.coerce) !== null && t !== void 0 ? t : !1,
        ...je(e)
    })
}
;
function _R(e, t) {
    const n = (e.toString().split(".")[1] || "").length
      , s = (t.toString().split(".")[1] || "").length
      , o = n > s ? n : s
      , a = parseInt(e.toFixed(o).replace(".", ""))
      , u = parseInt(t.toFixed(o).replace(".", ""));
    return a % u / Math.pow(10, o)
}
class ps extends Me {
    constructor() {
        super(...arguments),
        this.min = this.gte,
        this.max = this.lte,
        this.step = this.multipleOf
    }
    _parse(t) {
        if (this._def.coerce && (t.data = Number(t.data)),
        this._getType(t) !== he.number) {
            const a = this._getOrReturnCtx(t);
            return le(a, {
                code: Y.invalid_type,
                expected: he.number,
                received: a.parsedType
            }),
            _e
        }
        let s;
        const o = new Qt;
        for (const a of this._def.checks)
            a.kind === "int" ? Ue.isInteger(t.data) || (s = this._getOrReturnCtx(t, s),
            le(s, {
                code: Y.invalid_type,
                expected: "integer",
                received: "float",
                message: a.message
            }),
            o.dirty()) : a.kind === "min" ? (a.inclusive ? t.data < a.value : t.data <= a.value) && (s = this._getOrReturnCtx(t, s),
            le(s, {
                code: Y.too_small,
                minimum: a.value,
                type: "number",
                inclusive: a.inclusive,
                exact: !1,
                message: a.message
            }),
            o.dirty()) : a.kind === "max" ? (a.inclusive ? t.data > a.value : t.data >= a.value) && (s = this._getOrReturnCtx(t, s),
            le(s, {
                code: Y.too_big,
                maximum: a.value,
                type: "number",
                inclusive: a.inclusive,
                exact: !1,
                message: a.message
            }),
            o.dirty()) : a.kind === "multipleOf" ? _R(t.data, a.value) !== 0 && (s = this._getOrReturnCtx(t, s),
            le(s, {
                code: Y.not_multiple_of,
                multipleOf: a.value,
                message: a.message
            }),
            o.dirty()) : a.kind === "finite" ? Number.isFinite(t.data) || (s = this._getOrReturnCtx(t, s),
            le(s, {
                code: Y.not_finite,
                message: a.message
            }),
            o.dirty()) : Ue.assertNever(a);
        return {
            status: o.value,
            value: t.data
        }
    }
    gte(t, n) {
        return this.setLimit("min", t, !0, xe.toString(n))
    }
    gt(t, n) {
        return this.setLimit("min", t, !1, xe.toString(n))
    }
    lte(t, n) {
        return this.setLimit("max", t, !0, xe.toString(n))
    }
    lt(t, n) {
        return this.setLimit("max", t, !1, xe.toString(n))
    }
    setLimit(t, n, s, o) {
        return new ps({
            ...this._def,
            checks: [...this._def.checks, {
                kind: t,
                value: n,
                inclusive: s,
                message: xe.toString(o)
            }]
        })
    }
    _addCheck(t) {
        return new ps({
            ...this._def,
            checks: [...this._def.checks, t]
        })
    }
    int(t) {
        return this._addCheck({
            kind: "int",
            message: xe.toString(t)
        })
    }
    positive(t) {
        return this._addCheck({
            kind: "min",
            value: 0,
            inclusive: !1,
            message: xe.toString(t)
        })
    }
    negative(t) {
        return this._addCheck({
            kind: "max",
            value: 0,
            inclusive: !1,
            message: xe.toString(t)
        })
    }
    nonpositive(t) {
        return this._addCheck({
            kind: "max",
            value: 0,
            inclusive: !0,
            message: xe.toString(t)
        })
    }
    nonnegative(t) {
        return this._addCheck({
            kind: "min",
            value: 0,
            inclusive: !0,
            message: xe.toString(t)
        })
    }
    multipleOf(t, n) {
        return this._addCheck({
            kind: "multipleOf",
            value: t,
            message: xe.toString(n)
        })
    }
    finite(t) {
        return this._addCheck({
            kind: "finite",
            message: xe.toString(t)
        })
    }
    safe(t) {
        return this._addCheck({
            kind: "min",
            inclusive: !0,
            value: Number.MIN_SAFE_INTEGER,
            message: xe.toString(t)
        })._addCheck({
            kind: "max",
            inclusive: !0,
            value: Number.MAX_SAFE_INTEGER,
            message: xe.toString(t)
        })
    }
    get minValue() {
        let t = null;
        for (const n of this._def.checks)
            n.kind === "min" && (t === null || n.value > t) && (t = n.value);
        return t
    }
    get maxValue() {
        let t = null;
        for (const n of this._def.checks)
            n.kind === "max" && (t === null || n.value < t) && (t = n.value);
        return t
    }
    get isInt() {
        return !!this._def.checks.find(t => t.kind === "int" || t.kind === "multipleOf" && Ue.isInteger(t.value))
    }
    get isFinite() {
        let t = null
          , n = null;
        for (const s of this._def.checks) {
            if (s.kind === "finite" || s.kind === "int" || s.kind === "multipleOf")
                return !0;
            s.kind === "min" ? (n === null || s.value > n) && (n = s.value) : s.kind === "max" && (t === null || s.value < t) && (t = s.value)
        }
        return Number.isFinite(n) && Number.isFinite(t)
    }
}
ps.create = e => new ps({
    checks: [],
    typeName: Ee.ZodNumber,
    coerce: e?.coerce || !1,
    ...je(e)
});
class ms extends Me {
    constructor() {
        super(...arguments),
        this.min = this.gte,
        this.max = this.lte
    }
    _parse(t) {
        if (this._def.coerce)
            try {
                t.data = BigInt(t.data)
            } catch {
                return this._getInvalidInput(t)
            }
        if (this._getType(t) !== he.bigint)
            return this._getInvalidInput(t);
        let s;
        const o = new Qt;
        for (const a of this._def.checks)
            a.kind === "min" ? (a.inclusive ? t.data < a.value : t.data <= a.value) && (s = this._getOrReturnCtx(t, s),
            le(s, {
                code: Y.too_small,
                type: "bigint",
                minimum: a.value,
                inclusive: a.inclusive,
                message: a.message
            }),
            o.dirty()) : a.kind === "max" ? (a.inclusive ? t.data > a.value : t.data >= a.value) && (s = this._getOrReturnCtx(t, s),
            le(s, {
                code: Y.too_big,
                type: "bigint",
                maximum: a.value,
                inclusive: a.inclusive,
                message: a.message
            }),
            o.dirty()) : a.kind === "multipleOf" ? t.data % a.value !== BigInt(0) && (s = this._getOrReturnCtx(t, s),
            le(s, {
                code: Y.not_multiple_of,
                multipleOf: a.value,
                message: a.message
            }),
            o.dirty()) : Ue.assertNever(a);
        return {
            status: o.value,
            value: t.data
        }
    }
    _getInvalidInput(t) {
        const n = this._getOrReturnCtx(t);
        return le(n, {
            code: Y.invalid_type,
            expected: he.bigint,
            received: n.parsedType
        }),
        _e
    }
    gte(t, n) {
        return this.setLimit("min", t, !0, xe.toString(n))
    }
    gt(t, n) {
        return this.setLimit("min", t, !1, xe.toString(n))
    }
    lte(t, n) {
        return this.setLimit("max", t, !0, xe.toString(n))
    }
    lt(t, n) {
        return this.setLimit("max", t, !1, xe.toString(n))
    }
    setLimit(t, n, s, o) {
        return new ms({
            ...this._def,
            checks: [...this._def.checks, {
                kind: t,
                value: n,
                inclusive: s,
                message: xe.toString(o)
            }]
        })
    }
    _addCheck(t) {
        return new ms({
            ...this._def,
            checks: [...this._def.checks, t]
        })
    }
    positive(t) {
        return this._addCheck({
            kind: "min",
            value: BigInt(0),
            inclusive: !1,
            message: xe.toString(t)
        })
    }
    negative(t) {
        return this._addCheck({
            kind: "max",
            value: BigInt(0),
            inclusive: !1,
            message: xe.toString(t)
        })
    }
    nonpositive(t) {
        return this._addCheck({
            kind: "max",
            value: BigInt(0),
            inclusive: !0,
            message: xe.toString(t)
        })
    }
    nonnegative(t) {
        return this._addCheck({
            kind: "min",
            value: BigInt(0),
            inclusive: !0,
            message: xe.toString(t)
        })
    }
    multipleOf(t, n) {
        return this._addCheck({
            kind: "multipleOf",
            value: t,
            message: xe.toString(n)
        })
    }
    get minValue() {
        let t = null;
        for (const n of this._def.checks)
            n.kind === "min" && (t === null || n.value > t) && (t = n.value);
        return t
    }
    get maxValue() {
        let t = null;
        for (const n of this._def.checks)
            n.kind === "max" && (t === null || n.value < t) && (t = n.value);
        return t
    }
}
ms.create = e => {
    var t;
    return new ms({
        checks: [],
        typeName: Ee.ZodBigInt,
        coerce: (t = e?.coerce) !== null && t !== void 0 ? t : !1,
        ...je(e)
    })
}
;
class ka extends Me {
    _parse(t) {
        if (this._def.coerce && (t.data = !!t.data),
        this._getType(t) !== he.boolean) {
            const s = this._getOrReturnCtx(t);
            return le(s, {
                code: Y.invalid_type,
                expected: he.boolean,
                received: s.parsedType
            }),
            _e
        }
        return Xt(t.data)
    }
}
ka.create = e => new ka({
    typeName: Ee.ZodBoolean,
    coerce: e?.coerce || !1,
    ...je(e)
});
class Zs extends Me {
    _parse(t) {
        if (this._def.coerce && (t.data = new Date(t.data)),
        this._getType(t) !== he.date) {
            const a = this._getOrReturnCtx(t);
            return le(a, {
                code: Y.invalid_type,
                expected: he.date,
                received: a.parsedType
            }),
            _e
        }
        if (isNaN(t.data.getTime())) {
            const a = this._getOrReturnCtx(t);
            return le(a, {
                code: Y.invalid_date
            }),
            _e
        }
        const s = new Qt;
        let o;
        for (const a of this._def.checks)
            a.kind === "min" ? t.data.getTime() < a.value && (o = this._getOrReturnCtx(t, o),
            le(o, {
                code: Y.too_small,
                message: a.message,
                inclusive: !0,
                exact: !1,
                minimum: a.value,
                type: "date"
            }),
            s.dirty()) : a.kind === "max" ? t.data.getTime() > a.value && (o = this._getOrReturnCtx(t, o),
            le(o, {
                code: Y.too_big,
                message: a.message,
                inclusive: !0,
                exact: !1,
                maximum: a.value,
                type: "date"
            }),
            s.dirty()) : Ue.assertNever(a);
        return {
            status: s.value,
            value: new Date(t.data.getTime())
        }
    }
    _addCheck(t) {
        return new Zs({
            ...this._def,
            checks: [...this._def.checks, t]
        })
    }
    min(t, n) {
        return this._addCheck({
            kind: "min",
            value: t.getTime(),
            message: xe.toString(n)
        })
    }
    max(t, n) {
        return this._addCheck({
            kind: "max",
            value: t.getTime(),
            message: xe.toString(n)
        })
    }
    get minDate() {
        let t = null;
        for (const n of this._def.checks)
            n.kind === "min" && (t === null || n.value > t) && (t = n.value);
        return t != null ? new Date(t) : null
    }
    get maxDate() {
        let t = null;
        for (const n of this._def.checks)
            n.kind === "max" && (t === null || n.value < t) && (t = n.value);
        return t != null ? new Date(t) : null
    }
}
Zs.create = e => new Zs({
    checks: [],
    coerce: e?.coerce || !1,
    typeName: Ee.ZodDate,
    ...je(e)
});
class Wu extends Me {
    _parse(t) {
        if (this._getType(t) !== he.symbol) {
            const s = this._getOrReturnCtx(t);
            return le(s, {
                code: Y.invalid_type,
                expected: he.symbol,
                received: s.parsedType
            }),
            _e
        }
        return Xt(t.data)
    }
}
Wu.create = e => new Wu({
    typeName: Ee.ZodSymbol,
    ...je(e)
});
class Na extends Me {
    _parse(t) {
        if (this._getType(t) !== he.undefined) {
            const s = this._getOrReturnCtx(t);
            return le(s, {
                code: Y.invalid_type,
                expected: he.undefined,
                received: s.parsedType
            }),
            _e
        }
        return Xt(t.data)
    }
}
Na.create = e => new Na({
    typeName: Ee.ZodUndefined,
    ...je(e)
});
class Aa extends Me {
    _parse(t) {
        if (this._getType(t) !== he.null) {
            const s = this._getOrReturnCtx(t);
            return le(s, {
                code: Y.invalid_type,
                expected: he.null,
                received: s.parsedType
            }),
            _e
        }
        return Xt(t.data)
    }
}
Aa.create = e => new Aa({
    typeName: Ee.ZodNull,
    ...je(e)
});
class no extends Me {
    constructor() {
        super(...arguments),
        this._any = !0
    }
    _parse(t) {
        return Xt(t.data)
    }
}
no.create = e => new no({
    typeName: Ee.ZodAny,
    ...je(e)
});
class Ws extends Me {
    constructor() {
        super(...arguments),
        this._unknown = !0
    }
    _parse(t) {
        return Xt(t.data)
    }
}
Ws.create = e => new Ws({
    typeName: Ee.ZodUnknown,
    ...je(e)
});
class Ir extends Me {
    _parse(t) {
        const n = this._getOrReturnCtx(t);
        return le(n, {
            code: Y.invalid_type,
            expected: he.never,
            received: n.parsedType
        }),
        _e
    }
}
Ir.create = e => new Ir({
    typeName: Ee.ZodNever,
    ...je(e)
});
class Hu extends Me {
    _parse(t) {
        if (this._getType(t) !== he.undefined) {
            const s = this._getOrReturnCtx(t);
            return le(s, {
                code: Y.invalid_type,
                expected: he.void,
                received: s.parsedType
            }),
            _e
        }
        return Xt(t.data)
    }
}
Hu.create = e => new Hu({
    typeName: Ee.ZodVoid,
    ...je(e)
});
class Un extends Me {
    _parse(t) {
        const {ctx: n, status: s} = this._processInputParams(t)
          , o = this._def;
        if (n.parsedType !== he.array)
            return le(n, {
                code: Y.invalid_type,
                expected: he.array,
                received: n.parsedType
            }),
            _e;
        if (o.exactLength !== null) {
            const u = n.data.length > o.exactLength.value
              , c = n.data.length < o.exactLength.value;
            (u || c) && (le(n, {
                code: u ? Y.too_big : Y.too_small,
                minimum: c ? o.exactLength.value : void 0,
                maximum: u ? o.exactLength.value : void 0,
                type: "array",
                inclusive: !0,
                exact: !0,
                message: o.exactLength.message
            }),
            s.dirty())
        }
        if (o.minLength !== null && n.data.length < o.minLength.value && (le(n, {
            code: Y.too_small,
            minimum: o.minLength.value,
            type: "array",
            inclusive: !0,
            exact: !1,
            message: o.minLength.message
        }),
        s.dirty()),
        o.maxLength !== null && n.data.length > o.maxLength.value && (le(n, {
            code: Y.too_big,
            maximum: o.maxLength.value,
            type: "array",
            inclusive: !0,
            exact: !1,
            message: o.maxLength.message
        }),
        s.dirty()),
        n.common.async)
            return Promise.all([...n.data].map( (u, c) => o.type._parseAsync(new dr(n,u,n.path,c)))).then(u => Qt.mergeArray(s, u));
        const a = [...n.data].map( (u, c) => o.type._parseSync(new dr(n,u,n.path,c)));
        return Qt.mergeArray(s, a)
    }
    get element() {
        return this._def.type
    }
    min(t, n) {
        return new Un({
            ...this._def,
            minLength: {
                value: t,
                message: xe.toString(n)
            }
        })
    }
    max(t, n) {
        return new Un({
            ...this._def,
            maxLength: {
                value: t,
                message: xe.toString(n)
            }
        })
    }
    length(t, n) {
        return new Un({
            ...this._def,
            exactLength: {
                value: t,
                message: xe.toString(n)
            }
        })
    }
    nonempty(t) {
        return this.min(1, t)
    }
}
Un.create = (e, t) => new Un({
    type: e,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: Ee.ZodArray,
    ...je(t)
});
function Vi(e) {
    if (e instanceof ct) {
        const t = {};
        for (const n in e.shape) {
            const s = e.shape[n];
            t[n] = ar.create(Vi(s))
        }
        return new ct({
            ...e._def,
            shape: () => t
        })
    } else
        return e instanceof Un ? new Un({
            ...e._def,
            type: Vi(e.element)
        }) : e instanceof ar ? ar.create(Vi(e.unwrap())) : e instanceof ys ? ys.create(Vi(e.unwrap())) : e instanceof fr ? fr.create(e.items.map(t => Vi(t))) : e
}
class ct extends Me {
    constructor() {
        super(...arguments),
        this._cached = null,
        this.nonstrict = this.passthrough,
        this.augment = this.extend
    }
    _getCached() {
        if (this._cached !== null)
            return this._cached;
        const t = this._def.shape()
          , n = Ue.objectKeys(t);
        return this._cached = {
            shape: t,
            keys: n
        }
    }
    _parse(t) {
        if (this._getType(t) !== he.object) {
            const h = this._getOrReturnCtx(t);
            return le(h, {
                code: Y.invalid_type,
                expected: he.object,
                received: h.parsedType
            }),
            _e
        }
        const {status: s, ctx: o} = this._processInputParams(t)
          , {shape: a, keys: u} = this._getCached()
          , c = [];
        if (!(this._def.catchall instanceof Ir && this._def.unknownKeys === "strip"))
            for (const h in o.data)
                u.includes(h) || c.push(h);
        const f = [];
        for (const h of u) {
            const m = a[h]
              , v = o.data[h];
            f.push({
                key: {
                    status: "valid",
                    value: h
                },
                value: m._parse(new dr(o,v,o.path,h)),
                alwaysSet: h in o.data
            })
        }
        if (this._def.catchall instanceof Ir) {
            const h = this._def.unknownKeys;
            if (h === "passthrough")
                for (const m of c)
                    f.push({
                        key: {
                            status: "valid",
                            value: m
                        },
                        value: {
                            status: "valid",
                            value: o.data[m]
                        }
                    });
            else if (h === "strict")
                c.length > 0 && (le(o, {
                    code: Y.unrecognized_keys,
                    keys: c
                }),
                s.dirty());
            else if (h !== "strip")
                throw new Error("Internal ZodObject error: invalid unknownKeys value.")
        } else {
            const h = this._def.catchall;
            for (const m of c) {
                const v = o.data[m];
                f.push({
                    key: {
                        status: "valid",
                        value: m
                    },
                    value: h._parse(new dr(o,v,o.path,m)),
                    alwaysSet: m in o.data
                })
            }
        }
        return o.common.async ? Promise.resolve().then(async () => {
            const h = [];
            for (const m of f) {
                const v = await m.key
                  , x = await m.value;
                h.push({
                    key: v,
                    value: x,
                    alwaysSet: m.alwaysSet
                })
            }
            return h
        }
        ).then(h => Qt.mergeObjectSync(s, h)) : Qt.mergeObjectSync(s, f)
    }
    get shape() {
        return this._def.shape()
    }
    strict(t) {
        return xe.errToObj,
        new ct({
            ...this._def,
            unknownKeys: "strict",
            ...t !== void 0 ? {
                errorMap: (n, s) => {
                    var o, a, u, c;
                    const f = (u = (a = (o = this._def).errorMap) === null || a === void 0 ? void 0 : a.call(o, n, s).message) !== null && u !== void 0 ? u : s.defaultError;
                    return n.code === "unrecognized_keys" ? {
                        message: (c = xe.errToObj(t).message) !== null && c !== void 0 ? c : f
                    } : {
                        message: f
                    }
                }
            } : {}
        })
    }
    strip() {
        return new ct({
            ...this._def,
            unknownKeys: "strip"
        })
    }
    passthrough() {
        return new ct({
            ...this._def,
            unknownKeys: "passthrough"
        })
    }
    extend(t) {
        return new ct({
            ...this._def,
            shape: () => ({
                ...this._def.shape(),
                ...t
            })
        })
    }
    merge(t) {
        return new ct({
            unknownKeys: t._def.unknownKeys,
            catchall: t._def.catchall,
            shape: () => ({
                ...this._def.shape(),
                ...t._def.shape()
            }),
            typeName: Ee.ZodObject
        })
    }
    setKey(t, n) {
        return this.augment({
            [t]: n
        })
    }
    catchall(t) {
        return new ct({
            ...this._def,
            catchall: t
        })
    }
    pick(t) {
        const n = {};
        return Ue.objectKeys(t).forEach(s => {
            t[s] && this.shape[s] && (n[s] = this.shape[s])
        }
        ),
        new ct({
            ...this._def,
            shape: () => n
        })
    }
    omit(t) {
        const n = {};
        return Ue.objectKeys(this.shape).forEach(s => {
            t[s] || (n[s] = this.shape[s])
        }
        ),
        new ct({
            ...this._def,
            shape: () => n
        })
    }
    deepPartial() {
        return Vi(this)
    }
    partial(t) {
        const n = {};
        return Ue.objectKeys(this.shape).forEach(s => {
            const o = this.shape[s];
            t && !t[s] ? n[s] = o : n[s] = o.optional()
        }
        ),
        new ct({
            ...this._def,
            shape: () => n
        })
    }
    required(t) {
        const n = {};
        return Ue.objectKeys(this.shape).forEach(s => {
            if (t && !t[s])
                n[s] = this.shape[s];
            else {
                let a = this.shape[s];
                for (; a instanceof ar; )
                    a = a._def.innerType;
                n[s] = a
            }
        }
        ),
        new ct({
            ...this._def,
            shape: () => n
        })
    }
    keyof() {
        return Yb(Ue.objectKeys(this.shape))
    }
}
ct.create = (e, t) => new ct({
    shape: () => e,
    unknownKeys: "strip",
    catchall: Ir.create(),
    typeName: Ee.ZodObject,
    ...je(t)
});
ct.strictCreate = (e, t) => new ct({
    shape: () => e,
    unknownKeys: "strict",
    catchall: Ir.create(),
    typeName: Ee.ZodObject,
    ...je(t)
});
ct.lazycreate = (e, t) => new ct({
    shape: e,
    unknownKeys: "strip",
    catchall: Ir.create(),
    typeName: Ee.ZodObject,
    ...je(t)
});
class Ra extends Me {
    _parse(t) {
        const {ctx: n} = this._processInputParams(t)
          , s = this._def.options;
        function o(a) {
            for (const c of a)
                if (c.result.status === "valid")
                    return c.result;
            for (const c of a)
                if (c.result.status === "dirty")
                    return n.common.issues.push(...c.ctx.common.issues),
                    c.result;
            const u = a.map(c => new mn(c.ctx.common.issues));
            return le(n, {
                code: Y.invalid_union,
                unionErrors: u
            }),
            _e
        }
        if (n.common.async)
            return Promise.all(s.map(async a => {
                const u = {
                    ...n,
                    common: {
                        ...n.common,
                        issues: []
                    },
                    parent: null
                };
                return {
                    result: await a._parseAsync({
                        data: n.data,
                        path: n.path,
                        parent: u
                    }),
                    ctx: u
                }
            }
            )).then(o);
        {
            let a;
            const u = [];
            for (const f of s) {
                const h = {
                    ...n,
                    common: {
                        ...n.common,
                        issues: []
                    },
                    parent: null
                }
                  , m = f._parseSync({
                    data: n.data,
                    path: n.path,
                    parent: h
                });
                if (m.status === "valid")
                    return m;
                m.status === "dirty" && !a && (a = {
                    result: m,
                    ctx: h
                }),
                h.common.issues.length && u.push(h.common.issues)
            }
            if (a)
                return n.common.issues.push(...a.ctx.common.issues),
                a.result;
            const c = u.map(f => new mn(f));
            return le(n, {
                code: Y.invalid_union,
                unionErrors: c
            }),
            _e
        }
    }
    get options() {
        return this._def.options
    }
}
Ra.create = (e, t) => new Ra({
    options: e,
    typeName: Ee.ZodUnion,
    ...je(t)
});
const Er = e => e instanceof Oa ? Er(e.schema) : e instanceof Hn ? Er(e.innerType()) : e instanceof Ma ? [e.value] : e instanceof gs ? e.options : e instanceof Ia ? Ue.objectValues(e.enum) : e instanceof Fa ? Er(e._def.innerType) : e instanceof Na ? [void 0] : e instanceof Aa ? [null] : e instanceof ar ? [void 0, ...Er(e.unwrap())] : e instanceof ys ? [null, ...Er(e.unwrap())] : e instanceof jp || e instanceof Va ? Er(e.unwrap()) : e instanceof La ? Er(e._def.innerType) : [];
class Pc extends Me {
    _parse(t) {
        const {ctx: n} = this._processInputParams(t);
        if (n.parsedType !== he.object)
            return le(n, {
                code: Y.invalid_type,
                expected: he.object,
                received: n.parsedType
            }),
            _e;
        const s = this.discriminator
          , o = n.data[s]
          , a = this.optionsMap.get(o);
        return a ? n.common.async ? a._parseAsync({
            data: n.data,
            path: n.path,
            parent: n
        }) : a._parseSync({
            data: n.data,
            path: n.path,
            parent: n
        }) : (le(n, {
            code: Y.invalid_union_discriminator,
            options: Array.from(this.optionsMap.keys()),
            path: [s]
        }),
        _e)
    }
    get discriminator() {
        return this._def.discriminator
    }
    get options() {
        return this._def.options
    }
    get optionsMap() {
        return this._def.optionsMap
    }
    static create(t, n, s) {
        const o = new Map;
        for (const a of n) {
            const u = Er(a.shape[t]);
            if (!u.length)
                throw new Error(`A discriminator value for key \`${t}\` could not be extracted from all schema options`);
            for (const c of u) {
                if (o.has(c))
                    throw new Error(`Discriminator property ${String(t)} has duplicate value ${String(c)}`);
                o.set(c, a)
            }
        }
        return new Pc({
            typeName: Ee.ZodDiscriminatedUnion,
            discriminator: t,
            options: n,
            optionsMap: o,
            ...je(s)
        })
    }
}
function Vh(e, t) {
    const n = _r(e)
      , s = _r(t);
    if (e === t)
        return {
            valid: !0,
            data: e
        };
    if (n === he.object && s === he.object) {
        const o = Ue.objectKeys(t)
          , a = Ue.objectKeys(e).filter(c => o.indexOf(c) !== -1)
          , u = {
            ...e,
            ...t
        };
        for (const c of a) {
            const f = Vh(e[c], t[c]);
            if (!f.valid)
                return {
                    valid: !1
                };
            u[c] = f.data
        }
        return {
            valid: !0,
            data: u
        }
    } else if (n === he.array && s === he.array) {
        if (e.length !== t.length)
            return {
                valid: !1
            };
        const o = [];
        for (let a = 0; a < e.length; a++) {
            const u = e[a]
              , c = t[a]
              , f = Vh(u, c);
            if (!f.valid)
                return {
                    valid: !1
                };
            o.push(f.data)
        }
        return {
            valid: !0,
            data: o
        }
    } else
        return n === he.date && s === he.date && +e == +t ? {
            valid: !0,
            data: e
        } : {
            valid: !1
        }
}
class ja extends Me {
    _parse(t) {
        const {status: n, ctx: s} = this._processInputParams(t)
          , o = (a, u) => {
            if (Fh(a) || Fh(u))
                return _e;
            const c = Vh(a.value, u.value);
            return c.valid ? ((Lh(a) || Lh(u)) && n.dirty(),
            {
                status: n.value,
                value: c.data
            }) : (le(s, {
                code: Y.invalid_intersection_types
            }),
            _e)
        }
        ;
        return s.common.async ? Promise.all([this._def.left._parseAsync({
            data: s.data,
            path: s.path,
            parent: s
        }), this._def.right._parseAsync({
            data: s.data,
            path: s.path,
            parent: s
        })]).then( ([a,u]) => o(a, u)) : o(this._def.left._parseSync({
            data: s.data,
            path: s.path,
            parent: s
        }), this._def.right._parseSync({
            data: s.data,
            path: s.path,
            parent: s
        }))
    }
}
ja.create = (e, t, n) => new ja({
    left: e,
    right: t,
    typeName: Ee.ZodIntersection,
    ...je(n)
});
class fr extends Me {
    _parse(t) {
        const {status: n, ctx: s} = this._processInputParams(t);
        if (s.parsedType !== he.array)
            return le(s, {
                code: Y.invalid_type,
                expected: he.array,
                received: s.parsedType
            }),
            _e;
        if (s.data.length < this._def.items.length)
            return le(s, {
                code: Y.too_small,
                minimum: this._def.items.length,
                inclusive: !0,
                exact: !1,
                type: "array"
            }),
            _e;
        !this._def.rest && s.data.length > this._def.items.length && (le(s, {
            code: Y.too_big,
            maximum: this._def.items.length,
            inclusive: !0,
            exact: !1,
            type: "array"
        }),
        n.dirty());
        const a = [...s.data].map( (u, c) => {
            const f = this._def.items[c] || this._def.rest;
            return f ? f._parse(new dr(s,u,s.path,c)) : null
        }
        ).filter(u => !!u);
        return s.common.async ? Promise.all(a).then(u => Qt.mergeArray(n, u)) : Qt.mergeArray(n, a)
    }
    get items() {
        return this._def.items
    }
    rest(t) {
        return new fr({
            ...this._def,
            rest: t
        })
    }
}
fr.create = (e, t) => {
    if (!Array.isArray(e))
        throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
    return new fr({
        items: e,
        typeName: Ee.ZodTuple,
        rest: null,
        ...je(t)
    })
}
;
class Da extends Me {
    get keySchema() {
        return this._def.keyType
    }
    get valueSchema() {
        return this._def.valueType
    }
    _parse(t) {
        const {status: n, ctx: s} = this._processInputParams(t);
        if (s.parsedType !== he.object)
            return le(s, {
                code: Y.invalid_type,
                expected: he.object,
                received: s.parsedType
            }),
            _e;
        const o = []
          , a = this._def.keyType
          , u = this._def.valueType;
        for (const c in s.data)
            o.push({
                key: a._parse(new dr(s,c,s.path,c)),
                value: u._parse(new dr(s,s.data[c],s.path,c)),
                alwaysSet: c in s.data
            });
        return s.common.async ? Qt.mergeObjectAsync(n, o) : Qt.mergeObjectSync(n, o)
    }
    get element() {
        return this._def.valueType
    }
    static create(t, n, s) {
        return n instanceof Me ? new Da({
            keyType: t,
            valueType: n,
            typeName: Ee.ZodRecord,
            ...je(s)
        }) : new Da({
            keyType: zn.create(),
            valueType: t,
            typeName: Ee.ZodRecord,
            ...je(n)
        })
    }
}
class qu extends Me {
    get keySchema() {
        return this._def.keyType
    }
    get valueSchema() {
        return this._def.valueType
    }
    _parse(t) {
        const {status: n, ctx: s} = this._processInputParams(t);
        if (s.parsedType !== he.map)
            return le(s, {
                code: Y.invalid_type,
                expected: he.map,
                received: s.parsedType
            }),
            _e;
        const o = this._def.keyType
          , a = this._def.valueType
          , u = [...s.data.entries()].map( ([c,f], h) => ({
            key: o._parse(new dr(s,c,s.path,[h, "key"])),
            value: a._parse(new dr(s,f,s.path,[h, "value"]))
        }));
        if (s.common.async) {
            const c = new Map;
            return Promise.resolve().then(async () => {
                for (const f of u) {
                    const h = await f.key
                      , m = await f.value;
                    if (h.status === "aborted" || m.status === "aborted")
                        return _e;
                    (h.status === "dirty" || m.status === "dirty") && n.dirty(),
                    c.set(h.value, m.value)
                }
                return {
                    status: n.value,
                    value: c
                }
            }
            )
        } else {
            const c = new Map;
            for (const f of u) {
                const h = f.key
                  , m = f.value;
                if (h.status === "aborted" || m.status === "aborted")
                    return _e;
                (h.status === "dirty" || m.status === "dirty") && n.dirty(),
                c.set(h.value, m.value)
            }
            return {
                status: n.value,
                value: c
            }
        }
    }
}
qu.create = (e, t, n) => new qu({
    valueType: t,
    keyType: e,
    typeName: Ee.ZodMap,
    ...je(n)
});
class Ys extends Me {
    _parse(t) {
        const {status: n, ctx: s} = this._processInputParams(t);
        if (s.parsedType !== he.set)
            return le(s, {
                code: Y.invalid_type,
                expected: he.set,
                received: s.parsedType
            }),
            _e;
        const o = this._def;
        o.minSize !== null && s.data.size < o.minSize.value && (le(s, {
            code: Y.too_small,
            minimum: o.minSize.value,
            type: "set",
            inclusive: !0,
            exact: !1,
            message: o.minSize.message
        }),
        n.dirty()),
        o.maxSize !== null && s.data.size > o.maxSize.value && (le(s, {
            code: Y.too_big,
            maximum: o.maxSize.value,
            type: "set",
            inclusive: !0,
            exact: !1,
            message: o.maxSize.message
        }),
        n.dirty());
        const a = this._def.valueType;
        function u(f) {
            const h = new Set;
            for (const m of f) {
                if (m.status === "aborted")
                    return _e;
                m.status === "dirty" && n.dirty(),
                h.add(m.value)
            }
            return {
                status: n.value,
                value: h
            }
        }
        const c = [...s.data.values()].map( (f, h) => a._parse(new dr(s,f,s.path,h)));
        return s.common.async ? Promise.all(c).then(f => u(f)) : u(c)
    }
    min(t, n) {
        return new Ys({
            ...this._def,
            minSize: {
                value: t,
                message: xe.toString(n)
            }
        })
    }
    max(t, n) {
        return new Ys({
            ...this._def,
            maxSize: {
                value: t,
                message: xe.toString(n)
            }
        })
    }
    size(t, n) {
        return this.min(t, n).max(t, n)
    }
    nonempty(t) {
        return this.min(1, t)
    }
}
Ys.create = (e, t) => new Ys({
    valueType: e,
    minSize: null,
    maxSize: null,
    typeName: Ee.ZodSet,
    ...je(t)
});
class Gi extends Me {
    constructor() {
        super(...arguments),
        this.validate = this.implement
    }
    _parse(t) {
        const {ctx: n} = this._processInputParams(t);
        if (n.parsedType !== he.function)
            return le(n, {
                code: Y.invalid_type,
                expected: he.function,
                received: n.parsedType
            }),
            _e;
        function s(c, f) {
            return Uu({
                data: c,
                path: n.path,
                errorMaps: [n.common.contextualErrorMap, n.schemaErrorMap, zu(), to].filter(h => !!h),
                issueData: {
                    code: Y.invalid_arguments,
                    argumentsError: f
                }
            })
        }
        function o(c, f) {
            return Uu({
                data: c,
                path: n.path,
                errorMaps: [n.common.contextualErrorMap, n.schemaErrorMap, zu(), to].filter(h => !!h),
                issueData: {
                    code: Y.invalid_return_type,
                    returnTypeError: f
                }
            })
        }
        const a = {
            errorMap: n.common.contextualErrorMap
        }
          , u = n.data;
        if (this._def.returns instanceof ro) {
            const c = this;
            return Xt(async function(...f) {
                const h = new mn([])
                  , m = await c._def.args.parseAsync(f, a).catch(T => {
                    throw h.addIssue(s(f, T)),
                    h
                }
                )
                  , v = await Reflect.apply(u, this, m);
                return await c._def.returns._def.type.parseAsync(v, a).catch(T => {
                    throw h.addIssue(o(v, T)),
                    h
                }
                )
            })
        } else {
            const c = this;
            return Xt(function(...f) {
                const h = c._def.args.safeParse(f, a);
                if (!h.success)
                    throw new mn([s(f, h.error)]);
                const m = Reflect.apply(u, this, h.data)
                  , v = c._def.returns.safeParse(m, a);
                if (!v.success)
                    throw new mn([o(m, v.error)]);
                return v.data
            })
        }
    }
    parameters() {
        return this._def.args
    }
    returnType() {
        return this._def.returns
    }
    args(...t) {
        return new Gi({
            ...this._def,
            args: fr.create(t).rest(Ws.create())
        })
    }
    returns(t) {
        return new Gi({
            ...this._def,
            returns: t
        })
    }
    implement(t) {
        return this.parse(t)
    }
    strictImplement(t) {
        return this.parse(t)
    }
    static create(t, n, s) {
        return new Gi({
            args: t || fr.create([]).rest(Ws.create()),
            returns: n || Ws.create(),
            typeName: Ee.ZodFunction,
            ...je(s)
        })
    }
}
class Oa extends Me {
    get schema() {
        return this._def.getter()
    }
    _parse(t) {
        const {ctx: n} = this._processInputParams(t);
        return this._def.getter()._parse({
            data: n.data,
            path: n.path,
            parent: n
        })
    }
}
Oa.create = (e, t) => new Oa({
    getter: e,
    typeName: Ee.ZodLazy,
    ...je(t)
});
class Ma extends Me {
    _parse(t) {
        if (t.data !== this._def.value) {
            const n = this._getOrReturnCtx(t);
            return le(n, {
                received: n.data,
                code: Y.invalid_literal,
                expected: this._def.value
            }),
            _e
        }
        return {
            status: "valid",
            value: t.data
        }
    }
    get value() {
        return this._def.value
    }
}
Ma.create = (e, t) => new Ma({
    value: e,
    typeName: Ee.ZodLiteral,
    ...je(t)
});
function Yb(e, t) {
    return new gs({
        values: e,
        typeName: Ee.ZodEnum,
        ...je(t)
    })
}
class gs extends Me {
    constructor() {
        super(...arguments),
        ua.set(this, void 0)
    }
    _parse(t) {
        if (typeof t.data != "string") {
            const n = this._getOrReturnCtx(t)
              , s = this._def.values;
            return le(n, {
                expected: Ue.joinValues(s),
                received: n.parsedType,
                code: Y.invalid_type
            }),
            _e
        }
        if ($u(this, ua) || Qb(this, ua, new Set(this._def.values)),
        !$u(this, ua).has(t.data)) {
            const n = this._getOrReturnCtx(t)
              , s = this._def.values;
            return le(n, {
                received: n.data,
                code: Y.invalid_enum_value,
                options: s
            }),
            _e
        }
        return Xt(t.data)
    }
    get options() {
        return this._def.values
    }
    get enum() {
        const t = {};
        for (const n of this._def.values)
            t[n] = n;
        return t
    }
    get Values() {
        const t = {};
        for (const n of this._def.values)
            t[n] = n;
        return t
    }
    get Enum() {
        const t = {};
        for (const n of this._def.values)
            t[n] = n;
        return t
    }
    extract(t, n=this._def) {
        return gs.create(t, {
            ...this._def,
            ...n
        })
    }
    exclude(t, n=this._def) {
        return gs.create(this.options.filter(s => !t.includes(s)), {
            ...this._def,
            ...n
        })
    }
}
ua = new WeakMap;
gs.create = Yb;
class Ia extends Me {
    constructor() {
        super(...arguments),
        ca.set(this, void 0)
    }
    _parse(t) {
        const n = Ue.getValidEnumValues(this._def.values)
          , s = this._getOrReturnCtx(t);
        if (s.parsedType !== he.string && s.parsedType !== he.number) {
            const o = Ue.objectValues(n);
            return le(s, {
                expected: Ue.joinValues(o),
                received: s.parsedType,
                code: Y.invalid_type
            }),
            _e
        }
        if ($u(this, ca) || Qb(this, ca, new Set(Ue.getValidEnumValues(this._def.values))),
        !$u(this, ca).has(t.data)) {
            const o = Ue.objectValues(n);
            return le(s, {
                received: s.data,
                code: Y.invalid_enum_value,
                options: o
            }),
            _e
        }
        return Xt(t.data)
    }
    get enum() {
        return this._def.values
    }
}
ca = new WeakMap;
Ia.create = (e, t) => new Ia({
    values: e,
    typeName: Ee.ZodNativeEnum,
    ...je(t)
});
class ro extends Me {
    unwrap() {
        return this._def.type
    }
    _parse(t) {
        const {ctx: n} = this._processInputParams(t);
        if (n.parsedType !== he.promise && n.common.async === !1)
            return le(n, {
                code: Y.invalid_type,
                expected: he.promise,
                received: n.parsedType
            }),
            _e;
        const s = n.parsedType === he.promise ? n.data : Promise.resolve(n.data);
        return Xt(s.then(o => this._def.type.parseAsync(o, {
            path: n.path,
            errorMap: n.common.contextualErrorMap
        })))
    }
}
ro.create = (e, t) => new ro({
    type: e,
    typeName: Ee.ZodPromise,
    ...je(t)
});
class Hn extends Me {
    innerType() {
        return this._def.schema
    }
    sourceType() {
        return this._def.schema._def.typeName === Ee.ZodEffects ? this._def.schema.sourceType() : this._def.schema
    }
    _parse(t) {
        const {status: n, ctx: s} = this._processInputParams(t)
          , o = this._def.effect || null
          , a = {
            addIssue: u => {
                le(s, u),
                u.fatal ? n.abort() : n.dirty()
            }
            ,
            get path() {
                return s.path
            }
        };
        if (a.addIssue = a.addIssue.bind(a),
        o.type === "preprocess") {
            const u = o.transform(s.data, a);
            if (s.common.async)
                return Promise.resolve(u).then(async c => {
                    if (n.value === "aborted")
                        return _e;
                    const f = await this._def.schema._parseAsync({
                        data: c,
                        path: s.path,
                        parent: s
                    });
                    return f.status === "aborted" ? _e : f.status === "dirty" || n.value === "dirty" ? Bi(f.value) : f
                }
                );
            {
                if (n.value === "aborted")
                    return _e;
                const c = this._def.schema._parseSync({
                    data: u,
                    path: s.path,
                    parent: s
                });
                return c.status === "aborted" ? _e : c.status === "dirty" || n.value === "dirty" ? Bi(c.value) : c
            }
        }
        if (o.type === "refinement") {
            const u = c => {
                const f = o.refinement(c, a);
                if (s.common.async)
                    return Promise.resolve(f);
                if (f instanceof Promise)
                    throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
                return c
            }
            ;
            if (s.common.async === !1) {
                const c = this._def.schema._parseSync({
                    data: s.data,
                    path: s.path,
                    parent: s
                });
                return c.status === "aborted" ? _e : (c.status === "dirty" && n.dirty(),
                u(c.value),
                {
                    status: n.value,
                    value: c.value
                })
            } else
                return this._def.schema._parseAsync({
                    data: s.data,
                    path: s.path,
                    parent: s
                }).then(c => c.status === "aborted" ? _e : (c.status === "dirty" && n.dirty(),
                u(c.value).then( () => ({
                    status: n.value,
                    value: c.value
                }))))
        }
        if (o.type === "transform")
            if (s.common.async === !1) {
                const u = this._def.schema._parseSync({
                    data: s.data,
                    path: s.path,
                    parent: s
                });
                if (!Gs(u))
                    return u;
                const c = o.transform(u.value, a);
                if (c instanceof Promise)
                    throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
                return {
                    status: n.value,
                    value: c
                }
            } else
                return this._def.schema._parseAsync({
                    data: s.data,
                    path: s.path,
                    parent: s
                }).then(u => Gs(u) ? Promise.resolve(o.transform(u.value, a)).then(c => ({
                    status: n.value,
                    value: c
                })) : u);
        Ue.assertNever(o)
    }
}
Hn.create = (e, t, n) => new Hn({
    schema: e,
    typeName: Ee.ZodEffects,
    effect: t,
    ...je(n)
});
Hn.createWithPreprocess = (e, t, n) => new Hn({
    schema: t,
    effect: {
        type: "preprocess",
        transform: e
    },
    typeName: Ee.ZodEffects,
    ...je(n)
});
class ar extends Me {
    _parse(t) {
        return this._getType(t) === he.undefined ? Xt(void 0) : this._def.innerType._parse(t)
    }
    unwrap() {
        return this._def.innerType
    }
}
ar.create = (e, t) => new ar({
    innerType: e,
    typeName: Ee.ZodOptional,
    ...je(t)
});
class ys extends Me {
    _parse(t) {
        return this._getType(t) === he.null ? Xt(null) : this._def.innerType._parse(t)
    }
    unwrap() {
        return this._def.innerType
    }
}
ys.create = (e, t) => new ys({
    innerType: e,
    typeName: Ee.ZodNullable,
    ...je(t)
});
class Fa extends Me {
    _parse(t) {
        const {ctx: n} = this._processInputParams(t);
        let s = n.data;
        return n.parsedType === he.undefined && (s = this._def.defaultValue()),
        this._def.innerType._parse({
            data: s,
            path: n.path,
            parent: n
        })
    }
    removeDefault() {
        return this._def.innerType
    }
}
Fa.create = (e, t) => new Fa({
    innerType: e,
    typeName: Ee.ZodDefault,
    defaultValue: typeof t.default == "function" ? t.default : () => t.default,
    ...je(t)
});
class La extends Me {
    _parse(t) {
        const {ctx: n} = this._processInputParams(t)
          , s = {
            ...n,
            common: {
                ...n.common,
                issues: []
            }
        }
          , o = this._def.innerType._parse({
            data: s.data,
            path: s.path,
            parent: {
                ...s
            }
        });
        return _a(o) ? o.then(a => ({
            status: "valid",
            value: a.status === "valid" ? a.value : this._def.catchValue({
                get error() {
                    return new mn(s.common.issues)
                },
                input: s.data
            })
        })) : {
            status: "valid",
            value: o.status === "valid" ? o.value : this._def.catchValue({
                get error() {
                    return new mn(s.common.issues)
                },
                input: s.data
            })
        }
    }
    removeCatch() {
        return this._def.innerType
    }
}
La.create = (e, t) => new La({
    innerType: e,
    typeName: Ee.ZodCatch,
    catchValue: typeof t.catch == "function" ? t.catch : () => t.catch,
    ...je(t)
});
class Qu extends Me {
    _parse(t) {
        if (this._getType(t) !== he.nan) {
            const s = this._getOrReturnCtx(t);
            return le(s, {
                code: Y.invalid_type,
                expected: he.nan,
                received: s.parsedType
            }),
            _e
        }
        return {
            status: "valid",
            value: t.data
        }
    }
}
Qu.create = e => new Qu({
    typeName: Ee.ZodNaN,
    ...je(e)
});
const kR = Symbol("zod_brand");
class jp extends Me {
    _parse(t) {
        const {ctx: n} = this._processInputParams(t)
          , s = n.data;
        return this._def.type._parse({
            data: s,
            path: n.path,
            parent: n
        })
    }
    unwrap() {
        return this._def.type
    }
}
class Ga extends Me {
    _parse(t) {
        const {status: n, ctx: s} = this._processInputParams(t);
        if (s.common.async)
            return (async () => {
                const a = await this._def.in._parseAsync({
                    data: s.data,
                    path: s.path,
                    parent: s
                });
                return a.status === "aborted" ? _e : a.status === "dirty" ? (n.dirty(),
                Bi(a.value)) : this._def.out._parseAsync({
                    data: a.value,
                    path: s.path,
                    parent: s
                })
            }
            )();
        {
            const o = this._def.in._parseSync({
                data: s.data,
                path: s.path,
                parent: s
            });
            return o.status === "aborted" ? _e : o.status === "dirty" ? (n.dirty(),
            {
                status: "dirty",
                value: o.value
            }) : this._def.out._parseSync({
                data: o.value,
                path: s.path,
                parent: s
            })
        }
    }
    static create(t, n) {
        return new Ga({
            in: t,
            out: n,
            typeName: Ee.ZodPipeline
        })
    }
}
class Va extends Me {
    _parse(t) {
        const n = this._def.innerType._parse(t)
          , s = o => (Gs(o) && (o.value = Object.freeze(o.value)),
        o);
        return _a(n) ? n.then(o => s(o)) : s(n)
    }
    unwrap() {
        return this._def.innerType
    }
}
Va.create = (e, t) => new Va({
    innerType: e,
    typeName: Ee.ZodReadonly,
    ...je(t)
});
function ix(e, t) {
    const n = typeof e == "function" ? e(t) : typeof e == "string" ? {
        message: e
    } : e;
    return typeof n == "string" ? {
        message: n
    } : n
}
function Xb(e, t={}, n) {
    return e ? no.create().superRefine( (s, o) => {
        var a, u;
        const c = e(s);
        if (c instanceof Promise)
            return c.then(f => {
                var h, m;
                if (!f) {
                    const v = ix(t, s)
                      , x = (m = (h = v.fatal) !== null && h !== void 0 ? h : n) !== null && m !== void 0 ? m : !0;
                    o.addIssue({
                        code: "custom",
                        ...v,
                        fatal: x
                    })
                }
            }
            );
        if (!c) {
            const f = ix(t, s)
              , h = (u = (a = f.fatal) !== null && a !== void 0 ? a : n) !== null && u !== void 0 ? u : !0;
            o.addIssue({
                code: "custom",
                ...f,
                fatal: h
            })
        }
    }
    ) : no.create()
}
const NR = {
    object: ct.lazycreate
};
var Ee;
(function(e) {
    e.ZodString = "ZodString",
    e.ZodNumber = "ZodNumber",
    e.ZodNaN = "ZodNaN",
    e.ZodBigInt = "ZodBigInt",
    e.ZodBoolean = "ZodBoolean",
    e.ZodDate = "ZodDate",
    e.ZodSymbol = "ZodSymbol",
    e.ZodUndefined = "ZodUndefined",
    e.ZodNull = "ZodNull",
    e.ZodAny = "ZodAny",
    e.ZodUnknown = "ZodUnknown",
    e.ZodNever = "ZodNever",
    e.ZodVoid = "ZodVoid",
    e.ZodArray = "ZodArray",
    e.ZodObject = "ZodObject",
    e.ZodUnion = "ZodUnion",
    e.ZodDiscriminatedUnion = "ZodDiscriminatedUnion",
    e.ZodIntersection = "ZodIntersection",
    e.ZodTuple = "ZodTuple",
    e.ZodRecord = "ZodRecord",
    e.ZodMap = "ZodMap",
    e.ZodSet = "ZodSet",
    e.ZodFunction = "ZodFunction",
    e.ZodLazy = "ZodLazy",
    e.ZodLiteral = "ZodLiteral",
    e.ZodEnum = "ZodEnum",
    e.ZodEffects = "ZodEffects",
    e.ZodNativeEnum = "ZodNativeEnum",
    e.ZodOptional = "ZodOptional",
    e.ZodNullable = "ZodNullable",
    e.ZodDefault = "ZodDefault",
    e.ZodCatch = "ZodCatch",
    e.ZodPromise = "ZodPromise",
    e.ZodBranded = "ZodBranded",
    e.ZodPipeline = "ZodPipeline",
    e.ZodReadonly = "ZodReadonly"
}
)(Ee || (Ee = {}));
const AR = (e, t={
    message: `Input not instance of ${e.name}`
}) => Xb(n => n instanceof e, t)
  , Jb = zn.create
  , eS = ps.create
  , RR = Qu.create
  , jR = ms.create
  , tS = ka.create
  , DR = Zs.create
  , OR = Wu.create
  , MR = Na.create
  , IR = Aa.create
  , FR = no.create
  , LR = Ws.create
  , VR = Ir.create
  , BR = Hu.create
  , zR = Un.create
  , UR = ct.create
  , $R = ct.strictCreate
  , WR = Ra.create
  , HR = Pc.create
  , qR = ja.create
  , QR = fr.create
  , KR = Da.create
  , GR = qu.create
  , ZR = Ys.create
  , YR = Gi.create
  , XR = Oa.create
  , JR = Ma.create
  , ej = gs.create
  , tj = Ia.create
  , nj = ro.create
  , ox = Hn.create
  , rj = ar.create
  , sj = ys.create
  , ij = Hn.createWithPreprocess
  , oj = Ga.create
  , aj = () => Jb().optional()
  , lj = () => eS().optional()
  , uj = () => tS().optional()
  , cj = {
    string: (e => zn.create({
        ...e,
        coerce: !0
    })),
    number: (e => ps.create({
        ...e,
        coerce: !0
    })),
    boolean: (e => ka.create({
        ...e,
        coerce: !0
    })),
    bigint: (e => ms.create({
        ...e,
        coerce: !0
    })),
    date: (e => Zs.create({
        ...e,
        coerce: !0
    }))
}
  , dj = _e;
var Ae = Object.freeze({
    __proto__: null,
    defaultErrorMap: to,
    setErrorMap: iR,
    getErrorMap: zu,
    makeIssue: Uu,
    EMPTY_PATH: oR,
    addIssueToContext: le,
    ParseStatus: Qt,
    INVALID: _e,
    DIRTY: Bi,
    OK: Xt,
    isAborted: Fh,
    isDirty: Lh,
    isValid: Gs,
    isAsync: _a,
    get util() {
        return Ue
    },
    get objectUtil() {
        return Ih
    },
    ZodParsedType: he,
    getParsedType: _r,
    ZodType: Me,
    datetimeRegex: Zb,
    ZodString: zn,
    ZodNumber: ps,
    ZodBigInt: ms,
    ZodBoolean: ka,
    ZodDate: Zs,
    ZodSymbol: Wu,
    ZodUndefined: Na,
    ZodNull: Aa,
    ZodAny: no,
    ZodUnknown: Ws,
    ZodNever: Ir,
    ZodVoid: Hu,
    ZodArray: Un,
    ZodObject: ct,
    ZodUnion: Ra,
    ZodDiscriminatedUnion: Pc,
    ZodIntersection: ja,
    ZodTuple: fr,
    ZodRecord: Da,
    ZodMap: qu,
    ZodSet: Ys,
    ZodFunction: Gi,
    ZodLazy: Oa,
    ZodLiteral: Ma,
    ZodEnum: gs,
    ZodNativeEnum: Ia,
    ZodPromise: ro,
    ZodEffects: Hn,
    ZodTransformer: Hn,
    ZodOptional: ar,
    ZodNullable: ys,
    ZodDefault: Fa,
    ZodCatch: La,
    ZodNaN: Qu,
    BRAND: kR,
    ZodBranded: jp,
    ZodPipeline: Ga,
    ZodReadonly: Va,
    custom: Xb,
    Schema: Me,
    ZodSchema: Me,
    late: NR,
    get ZodFirstPartyTypeKind() {
        return Ee
    },
    coerce: cj,
    any: FR,
    array: zR,
    bigint: jR,
    boolean: tS,
    date: DR,
    discriminatedUnion: HR,
    effect: ox,
    enum: ej,
    function: YR,
    instanceof: AR,
    intersection: qR,
    lazy: XR,
    literal: JR,
    map: GR,
    nan: RR,
    nativeEnum: tj,
    never: VR,
    null: IR,
    nullable: sj,
    number: eS,
    object: UR,
    oboolean: uj,
    onumber: lj,
    optional: rj,
    ostring: aj,
    pipeline: oj,
    preprocess: ij,
    promise: nj,
    record: KR,
    set: ZR,
    strictObject: $R,
    string: Jb,
    symbol: OR,
    transformer: ox,
    tuple: QR,
    undefined: MR,
    union: WR,
    unknown: LR,
    void: BR,
    NEVER: dj,
    ZodIssueCode: Y,
    quotelessJson: sR,
    ZodError: mn
});
const q = Symbol.for("drizzle:entityKind");
function St(e, t) {
    if (!e || typeof e != "object")
        return !1;
    if (e instanceof t)
        return !0;
    if (!Object.prototype.hasOwnProperty.call(t, q))
        throw new Error(`Class "${t.name ?? "<unknown>"}" doesn't look like a Drizzle entity. If this is incorrect and the class is provided by Drizzle, please report this as a bug.`);
    let n = Object.getPrototypeOf(e).constructor;
    if (n)
        for (; n; ) {
            if (q in n && n[q] === t[q])
                return !0;
            n = Object.getPrototypeOf(n)
        }
    return !1
}
class Ba {
    constructor(t, n) {
        this.table = t,
        this.config = n,
        this.name = n.name,
        this.keyAsName = n.keyAsName,
        this.notNull = n.notNull,
        this.default = n.default,
        this.defaultFn = n.defaultFn,
        this.onUpdateFn = n.onUpdateFn,
        this.hasDefault = n.hasDefault,
        this.primary = n.primaryKey,
        this.isUnique = n.isUnique,
        this.uniqueName = n.uniqueName,
        this.uniqueType = n.uniqueType,
        this.dataType = n.dataType,
        this.columnType = n.columnType,
        this.generated = n.generated,
        this.generatedIdentity = n.generatedIdentity
    }
    static[q] = "Column";
    name;
    keyAsName;
    primary;
    notNull;
    default;
    defaultFn;
    onUpdateFn;
    hasDefault;
    isUnique;
    uniqueName;
    uniqueType;
    dataType;
    columnType;
    enumValues = void 0;
    generated = void 0;
    generatedIdentity = void 0;
    config;
    mapFromDriverValue(t) {
        return t
    }
    mapToDriverValue(t) {
        return t
    }
    shouldDisableInsert() {
        return this.config.generated !== void 0 && this.config.generated.type !== "byDefault"
    }
}
class fj {
    static[q] = "ColumnBuilder";
    config;
    constructor(t, n, s) {
        this.config = {
            name: t,
            keyAsName: t === "",
            notNull: !1,
            default: void 0,
            hasDefault: !1,
            primaryKey: !1,
            isUnique: !1,
            uniqueName: void 0,
            uniqueType: void 0,
            dataType: n,
            columnType: s,
            generated: void 0
        }
    }
    $type() {
        return this
    }
    notNull() {
        return this.config.notNull = !0,
        this
    }
    default(t) {
        return this.config.default = t,
        this.config.hasDefault = !0,
        this
    }
    $defaultFn(t) {
        return this.config.defaultFn = t,
        this.config.hasDefault = !0,
        this
    }
    $default = this.$defaultFn;
    $onUpdateFn(t) {
        return this.config.onUpdateFn = t,
        this.config.hasDefault = !0,
        this
    }
    $onUpdate = this.$onUpdateFn;
    primaryKey() {
        return this.config.primaryKey = !0,
        this.config.notNull = !0,
        this
    }
    setName(t) {
        this.config.name === "" && (this.config.name = t)
    }
}
const Zi = Symbol.for("drizzle:Name");
class hj {
    static[q] = "PgForeignKeyBuilder";
    reference;
    _onUpdate = "no action";
    _onDelete = "no action";
    constructor(t, n) {
        this.reference = () => {
            const {name: s, columns: o, foreignColumns: a} = t();
            return {
                name: s,
                columns: o,
                foreignTable: a[0].table,
                foreignColumns: a
            }
        }
        ,
        n && (this._onUpdate = n.onUpdate,
        this._onDelete = n.onDelete)
    }
    onUpdate(t) {
        return this._onUpdate = t === void 0 ? "no action" : t,
        this
    }
    onDelete(t) {
        return this._onDelete = t === void 0 ? "no action" : t,
        this
    }
    build(t) {
        return new pj(t,this)
    }
}
class pj {
    constructor(t, n) {
        this.table = t,
        this.reference = n.reference,
        this.onUpdate = n._onUpdate,
        this.onDelete = n._onDelete
    }
    static[q] = "PgForeignKey";
    reference;
    onUpdate;
    onDelete;
    getName() {
        const {name: t, columns: n, foreignColumns: s} = this.reference()
          , o = n.map(c => c.name)
          , a = s.map(c => c.name)
          , u = [this.table[Zi], ...o, s[0].table[Zi], ...a];
        return t ?? `${u.join("_")}_fk`
    }
}
function mj(e, ...t) {
    return e(...t)
}
function gj(e, t) {
    return `${e[Zi]}_${t.join("_")}_unique`
}
function ax(e, t, n) {
    for (let s = t; s < e.length; s++) {
        const o = e[s];
        if (o === "\\") {
            s++;
            continue
        }
        if (o === '"')
            return [e.slice(t, s).replace(/\\/g, ""), s + 1];
        if (!n && (o === "," || o === "}"))
            return [e.slice(t, s).replace(/\\/g, ""), s]
    }
    return [e.slice(t).replace(/\\/g, ""), e.length]
}
function nS(e, t=0) {
    const n = [];
    let s = t
      , o = !1;
    for (; s < e.length; ) {
        const a = e[s];
        if (a === ",") {
            (o || s === t) && n.push(""),
            o = !0,
            s++;
            continue
        }
        if (o = !1,
        a === "\\") {
            s += 2;
            continue
        }
        if (a === '"') {
            const [f,h] = ax(e, s + 1, !0);
            n.push(f),
            s = h;
            continue
        }
        if (a === "}")
            return [n, s + 1];
        if (a === "{") {
            const [f,h] = nS(e, s + 1);
            n.push(f),
            s = h;
            continue
        }
        const [u,c] = ax(e, s, !1);
        n.push(u),
        s = c
    }
    return [n, s]
}
function yj(e) {
    const [t] = nS(e, 1);
    return t
}
function rS(e) {
    return `{${e.map(t => Array.isArray(t) ? rS(t) : typeof t == "string" ? `"${t.replace(/\\/g, "\\\\").replace(/"/g, '\\"')}"` : `${t}`).join(",")}}`
}
class He extends fj {
    foreignKeyConfigs = [];
    static[q] = "PgColumnBuilder";
    array(t) {
        return new xj(this.config.name,this,t)
    }
    references(t, n={}) {
        return this.foreignKeyConfigs.push({
            ref: t,
            actions: n
        }),
        this
    }
    unique(t, n) {
        return this.config.isUnique = !0,
        this.config.uniqueName = t,
        this.config.uniqueType = n?.nulls,
        this
    }
    generatedAlwaysAs(t) {
        return this.config.generated = {
            as: t,
            type: "always",
            mode: "stored"
        },
        this
    }
    buildForeignKeys(t, n) {
        return this.foreignKeyConfigs.map( ({ref: s, actions: o}) => mj( (a, u) => {
            const c = new hj( () => {
                const f = a();
                return {
                    columns: [t],
                    foreignColumns: [f]
                }
            }
            );
            return u.onUpdate && c.onUpdate(u.onUpdate),
            u.onDelete && c.onDelete(u.onDelete),
            c.build(n)
        }
        , s, o))
    }
    buildExtraConfigColumn(t) {
        return new vj(t,this.config)
    }
}
class Oe extends Ba {
    constructor(t, n) {
        n.uniqueName || (n.uniqueName = gj(t, [n.name])),
        super(t, n),
        this.table = t
    }
    static[q] = "PgColumn"
}
class vj extends Oe {
    static[q] = "ExtraConfigColumn";
    getSQLType() {
        return this.getSQLType()
    }
    indexConfig = {
        order: this.config.order ?? "asc",
        nulls: this.config.nulls ?? "last",
        opClass: this.config.opClass
    };
    defaultConfig = {
        order: "asc",
        nulls: "last",
        opClass: void 0
    };
    asc() {
        return this.indexConfig.order = "asc",
        this
    }
    desc() {
        return this.indexConfig.order = "desc",
        this
    }
    nullsFirst() {
        return this.indexConfig.nulls = "first",
        this
    }
    nullsLast() {
        return this.indexConfig.nulls = "last",
        this
    }
    op(t) {
        return this.indexConfig.opClass = t,
        this
    }
}
class Wf {
    static[q] = "IndexedColumn";
    constructor(t, n, s, o) {
        this.name = t,
        this.keyAsName = n,
        this.type = s,
        this.indexConfig = o
    }
    name;
    keyAsName;
    type;
    indexConfig
}
class xj extends He {
    static[q] = "PgArrayBuilder";
    constructor(t, n, s) {
        super(t, "array", "PgArray"),
        this.config.baseBuilder = n,
        this.config.size = s
    }
    build(t) {
        const n = this.config.baseBuilder.build(t);
        return new Dp(t,this.config,n)
    }
}
class Dp extends Oe {
    constructor(t, n, s, o) {
        super(t, n),
        this.baseColumn = s,
        this.range = o,
        this.size = n.size
    }
    size;
    static[q] = "PgArray";
    getSQLType() {
        return `${this.baseColumn.getSQLType()}[${typeof this.size == "number" ? this.size : ""}]`
    }
    mapFromDriverValue(t) {
        return typeof t == "string" && (t = yj(t)),
        t.map(n => this.baseColumn.mapFromDriverValue(n))
    }
    mapToDriverValue(t, n=!1) {
        const s = t.map(o => o === null ? null : St(this.baseColumn, Dp) ? this.baseColumn.mapToDriverValue(o, !0) : this.baseColumn.mapToDriverValue(o));
        return n ? s : rS(s)
    }
}
const lx = Symbol.for("drizzle:isPgEnum");
function wj(e) {
    return !!e && typeof e == "function" && lx in e && e[lx] === !0
}
class sS {
    static[q] = "Subquery";
    constructor(t, n, s, o=!1) {
        this._ = {
            brand: "Subquery",
            sql: t,
            selectedFields: n,
            alias: s,
            isWith: o
        }
    }
}
const bj = {
    startActiveSpan(e, t) {
        return t()
    }
}
  , Yi = Symbol.for("drizzle:ViewBaseConfig")
  , Hf = Symbol.for("drizzle:Schema")
  , ux = Symbol.for("drizzle:Columns")
  , cx = Symbol.for("drizzle:ExtraConfigColumns")
  , qf = Symbol.for("drizzle:OriginalName")
  , Qf = Symbol.for("drizzle:BaseName")
  , Ku = Symbol.for("drizzle:IsAlias")
  , dx = Symbol.for("drizzle:ExtraConfigBuilder")
  , iS = Symbol.for("drizzle:IsDrizzleTable");
class hn {
    static[q] = "Table";
    static Symbol = {
        Name: Zi,
        Schema: Hf,
        OriginalName: qf,
        Columns: ux,
        ExtraConfigColumns: cx,
        BaseName: Qf,
        IsAlias: Ku,
        ExtraConfigBuilder: dx
    };
    [Zi];
    [qf];
    [Hf];
    [ux];
    [cx];
    [Qf];
    [Ku] = !1;
    [iS] = !0;
    [dx] = void 0;
    constructor(t, n, s) {
        this[Zi] = this[qf] = t,
        this[Hf] = n,
        this[Qf] = s
    }
}
function oS(e) {
    return typeof e == "object" && e !== null && iS in e
}
function Sj(e) {
    return e != null && typeof e.getSQL == "function"
}
function Tj(e) {
    const t = {
        sql: "",
        params: []
    };
    for (const n of e)
        t.sql += n.sql,
        t.params.push(...n.params),
        n.typings?.length && (t.typings || (t.typings = []),
        t.typings.push(...n.typings));
    return t
}
class Fn {
    static[q] = "StringChunk";
    value;
    constructor(t) {
        this.value = Array.isArray(t) ? t : [t]
    }
    getSQL() {
        return new st([this])
    }
}
class st {
    constructor(t) {
        this.queryChunks = t
    }
    static[q] = "SQL";
    decoder = aS;
    shouldInlineParams = !1;
    append(t) {
        return this.queryChunks.push(...t.queryChunks),
        this
    }
    toQuery(t) {
        return bj.startActiveSpan("drizzle.buildSQL", n => {
            const s = this.buildQueryFromSourceParams(this.queryChunks, t);
            return n?.setAttributes({
                "drizzle.query.text": s.sql,
                "drizzle.query.params": JSON.stringify(s.params)
            }),
            s
        }
        )
    }
    buildQueryFromSourceParams(t, n) {
        const s = Object.assign({}, n, {
            inlineParams: n.inlineParams || this.shouldInlineParams,
            paramStartIndex: n.paramStartIndex || {
                value: 0
            }
        })
          , {casing: o, escapeName: a, escapeParam: u, prepareTyping: c, inlineParams: f, paramStartIndex: h} = s;
        return Tj(t.map(m => {
            if (St(m, Fn))
                return {
                    sql: m.value.join(""),
                    params: []
                };
            if (St(m, Bh))
                return {
                    sql: a(m.value),
                    params: []
                };
            if (m === void 0)
                return {
                    sql: "",
                    params: []
                };
            if (Array.isArray(m)) {
                const v = [new Fn("(")];
                for (const [x,T] of m.entries())
                    v.push(T),
                    x < m.length - 1 && v.push(new Fn(", "));
                return v.push(new Fn(")")),
                this.buildQueryFromSourceParams(v, s)
            }
            if (St(m, st))
                return this.buildQueryFromSourceParams(m.queryChunks, {
                    ...s,
                    inlineParams: f || m.shouldInlineParams
                });
            if (St(m, hn)) {
                const v = m[hn.Symbol.Schema]
                  , x = m[hn.Symbol.Name];
                return {
                    sql: v === void 0 || m[Ku] ? a(x) : a(v) + "." + a(x),
                    params: []
                }
            }
            if (St(m, Ba)) {
                const v = o.getColumnCasing(m);
                if (n.invokeSource === "indexes")
                    return {
                        sql: a(v),
                        params: []
                    };
                const x = m.table[hn.Symbol.Schema];
                return {
                    sql: m.table[Ku] || x === void 0 ? a(m.table[hn.Symbol.Name]) + "." + a(v) : a(x) + "." + a(m.table[hn.Symbol.Name]) + "." + a(v),
                    params: []
                }
            }
            if (St(m, Pj)) {
                const v = m[Yi].schema
                  , x = m[Yi].name;
                return {
                    sql: v === void 0 || m[Yi].isAlias ? a(x) : a(v) + "." + a(x),
                    params: []
                }
            }
            if (St(m, uS)) {
                if (St(m.value, zh))
                    return {
                        sql: u(h.value++, m),
                        params: [m],
                        typings: ["none"]
                    };
                const v = m.value === null ? null : m.encoder.mapToDriverValue(m.value);
                if (St(v, st))
                    return this.buildQueryFromSourceParams([v], s);
                if (f)
                    return {
                        sql: this.mapInlineParam(v, s),
                        params: []
                    };
                let x = ["none"];
                return c && (x = [c(m.encoder)]),
                {
                    sql: u(h.value++, v),
                    params: [v],
                    typings: x
                }
            }
            return St(m, zh) ? {
                sql: u(h.value++, m),
                params: [m],
                typings: ["none"]
            } : St(m, st.Aliased) && m.fieldAlias !== void 0 ? {
                sql: a(m.fieldAlias),
                params: []
            } : St(m, sS) ? m._.isWith ? {
                sql: a(m._.alias),
                params: []
            } : this.buildQueryFromSourceParams([new Fn("("), m._.sql, new Fn(") "), new Bh(m._.alias)], s) : wj(m) ? m.schema ? {
                sql: a(m.schema) + "." + a(m.enumName),
                params: []
            } : {
                sql: a(m.enumName),
                params: []
            } : Sj(m) ? m.shouldOmitSQLParens?.() ? this.buildQueryFromSourceParams([m.getSQL()], s) : this.buildQueryFromSourceParams([new Fn("("), m.getSQL(), new Fn(")")], s) : f ? {
                sql: this.mapInlineParam(m, s),
                params: []
            } : {
                sql: u(h.value++, m),
                params: [m],
                typings: ["none"]
            }
        }
        ))
    }
    mapInlineParam(t, {escapeString: n}) {
        if (t === null)
            return "null";
        if (typeof t == "number" || typeof t == "boolean")
            return t.toString();
        if (typeof t == "string")
            return n(t);
        if (typeof t == "object") {
            const s = t.toString();
            return n(s === "[object Object]" ? JSON.stringify(t) : s)
        }
        throw new Error("Unexpected param value: " + t)
    }
    getSQL() {
        return this
    }
    as(t) {
        return t === void 0 ? this : new st.Aliased(this,t)
    }
    mapWith(t) {
        return this.decoder = typeof t == "function" ? {
            mapFromDriverValue: t
        } : t,
        this
    }
    inlineParams() {
        return this.shouldInlineParams = !0,
        this
    }
    if(t) {
        return t ? this : void 0
    }
}
class Bh {
    constructor(t) {
        this.value = t
    }
    static[q] = "Name";
    brand;
    getSQL() {
        return new st([this])
    }
}
const aS = {
    mapFromDriverValue: e => e
}
  , lS = {
    mapToDriverValue: e => e
};
({
    ...aS,
    ...lS
});
class uS {
    constructor(t, n=lS) {
        this.value = t,
        this.encoder = n
    }
    static[q] = "Param";
    brand;
    getSQL() {
        return new st([this])
    }
}
function za(e, ...t) {
    const n = [];
    (t.length > 0 || e.length > 0 && e[0] !== "") && n.push(new Fn(e[0]));
    for (const [s,o] of t.entries())
        n.push(o, new Fn(e[s + 1]));
    return new st(n)
}
(e => {
    function t() {
        return new st([])
    }
    e.empty = t;
    function n(f) {
        return new st(f)
    }
    e.fromList = n;
    function s(f) {
        return new st([new Fn(f)])
    }
    e.raw = s;
    function o(f, h) {
        const m = [];
        for (const [v,x] of f.entries())
            v > 0 && h !== void 0 && m.push(h),
            m.push(x);
        return new st(m)
    }
    e.join = o;
    function a(f) {
        return new Bh(f)
    }
    e.identifier = a;
    function u(f) {
        return new zh(f)
    }
    e.placeholder = u;
    function c(f, h) {
        return new uS(f,h)
    }
    e.param = c
}
)(za || (za = {}));
(e => {
    class t {
        constructor(s, o) {
            this.sql = s,
            this.fieldAlias = o
        }
        static[q] = "SQL.Aliased";
        isSelectionField = !1;
        getSQL() {
            return this.sql
        }
        clone() {
            return new t(this.sql,this.fieldAlias)
        }
    }
    e.Aliased = t
}
)(st || (st = {}));
class zh {
    constructor(t) {
        this.name = t
    }
    static[q] = "Placeholder";
    getSQL() {
        return new st([this])
    }
}
const cS = Symbol.for("drizzle:IsDrizzleView");
class Pj {
    static[q] = "View";
    [Yi];
    [cS] = !0;
    constructor({name: t, schema: n, selectedFields: s, query: o}) {
        this[Yi] = {
            name: t,
            originalName: t,
            schema: n,
            selectedFields: s,
            query: o,
            isExisting: !o,
            isAlias: !1
        }
    }
    getSQL() {
        return new st([this])
    }
}
function Cj(e) {
    return typeof e == "object" && e !== null && cS in e
}
Ba.prototype.getSQL = function() {
    return new st([this])
}
;
hn.prototype.getSQL = function() {
    return new st([this])
}
;
sS.prototype.getSQL = function() {
    return new st([this])
}
;
function Ej(e) {
    return e[hn.Symbol.Columns]
}
function _j(e) {
    return e[Yi].selectedFields
}
function Dt(e, t) {
    return {
        name: typeof e == "string" && e.length > 0 ? e : "",
        config: typeof e == "object" ? e : t
    }
}
class Cc extends He {
    static[q] = "PgIntColumnBaseBuilder";
    generatedAlwaysAsIdentity(t) {
        if (t) {
            const {name: n, ...s} = t;
            this.config.generatedIdentity = {
                type: "always",
                sequenceName: n,
                sequenceOptions: s
            }
        } else
            this.config.generatedIdentity = {
                type: "always"
            };
        return this.config.hasDefault = !0,
        this.config.notNull = !0,
        this
    }
    generatedByDefaultAsIdentity(t) {
        if (t) {
            const {name: n, ...s} = t;
            this.config.generatedIdentity = {
                type: "byDefault",
                sequenceName: n,
                sequenceOptions: s
            }
        } else
            this.config.generatedIdentity = {
                type: "byDefault"
            };
        return this.config.hasDefault = !0,
        this.config.notNull = !0,
        this
    }
}
class kj extends Cc {
    static[q] = "PgBigInt53Builder";
    constructor(t) {
        super(t, "number", "PgBigInt53")
    }
    build(t) {
        return new Nj(t,this.config)
    }
}
class Nj extends Oe {
    static[q] = "PgBigInt53";
    getSQLType() {
        return "bigint"
    }
    mapFromDriverValue(t) {
        return typeof t == "number" ? t : Number(t)
    }
}
class Aj extends Cc {
    static[q] = "PgBigInt64Builder";
    constructor(t) {
        super(t, "bigint", "PgBigInt64")
    }
    build(t) {
        return new Rj(t,this.config)
    }
}
class Rj extends Oe {
    static[q] = "PgBigInt64";
    getSQLType() {
        return "bigint"
    }
    mapFromDriverValue(t) {
        return BigInt(t)
    }
}
function jj(e, t) {
    const {name: n, config: s} = Dt(e, t);
    return s.mode === "number" ? new kj(n) : new Aj(n)
}
class Dj extends He {
    static[q] = "PgBigSerial53Builder";
    constructor(t) {
        super(t, "number", "PgBigSerial53"),
        this.config.hasDefault = !0,
        this.config.notNull = !0
    }
    build(t) {
        return new Oj(t,this.config)
    }
}
class Oj extends Oe {
    static[q] = "PgBigSerial53";
    getSQLType() {
        return "bigserial"
    }
    mapFromDriverValue(t) {
        return typeof t == "number" ? t : Number(t)
    }
}
class Mj extends He {
    static[q] = "PgBigSerial64Builder";
    constructor(t) {
        super(t, "bigint", "PgBigSerial64"),
        this.config.hasDefault = !0
    }
    build(t) {
        return new Ij(t,this.config)
    }
}
class Ij extends Oe {
    static[q] = "PgBigSerial64";
    getSQLType() {
        return "bigserial"
    }
    mapFromDriverValue(t) {
        return BigInt(t)
    }
}
function Fj(e, t) {
    const {name: n, config: s} = Dt(e, t);
    return s.mode === "number" ? new Dj(n) : new Mj(n)
}
class Lj extends He {
    static[q] = "PgBooleanBuilder";
    constructor(t) {
        super(t, "boolean", "PgBoolean")
    }
    build(t) {
        return new Vj(t,this.config)
    }
}
class Vj extends Oe {
    static[q] = "PgBoolean";
    getSQLType() {
        return "boolean"
    }
}
function dS(e) {
    return new Lj(e ?? "")
}
class Bj extends He {
    static[q] = "PgCharBuilder";
    constructor(t, n) {
        super(t, "string", "PgChar"),
        this.config.length = n.length,
        this.config.enumValues = n.enum
    }
    build(t) {
        return new zj(t,this.config)
    }
}
class zj extends Oe {
    static[q] = "PgChar";
    length = this.config.length;
    enumValues = this.config.enumValues;
    getSQLType() {
        return this.length === void 0 ? "char" : `char(${this.length})`
    }
}
function Uj(e, t={}) {
    const {name: n, config: s} = Dt(e, t);
    return new Bj(n,s)
}
class $j extends He {
    static[q] = "PgCidrBuilder";
    constructor(t) {
        super(t, "string", "PgCidr")
    }
    build(t) {
        return new Wj(t,this.config)
    }
}
class Wj extends Oe {
    static[q] = "PgCidr";
    getSQLType() {
        return "cidr"
    }
}
function Hj(e) {
    return new $j(e ?? "")
}
class qj extends He {
    static[q] = "PgCustomColumnBuilder";
    constructor(t, n, s) {
        super(t, "custom", "PgCustomColumn"),
        this.config.fieldConfig = n,
        this.config.customTypeParams = s
    }
    build(t) {
        return new Qj(t,this.config)
    }
}
class Qj extends Oe {
    static[q] = "PgCustomColumn";
    sqlName;
    mapTo;
    mapFrom;
    constructor(t, n) {
        super(t, n),
        this.sqlName = n.customTypeParams.dataType(n.fieldConfig),
        this.mapTo = n.customTypeParams.toDriver,
        this.mapFrom = n.customTypeParams.fromDriver
    }
    getSQLType() {
        return this.sqlName
    }
    mapFromDriverValue(t) {
        return typeof this.mapFrom == "function" ? this.mapFrom(t) : t
    }
    mapToDriverValue(t) {
        return typeof this.mapTo == "function" ? this.mapTo(t) : t
    }
}
function Kj(e) {
    return (t, n) => {
        const {name: s, config: o} = Dt(t, n);
        return new qj(s,o,e)
    }
}
class Za extends He {
    static[q] = "PgDateColumnBaseBuilder";
    defaultNow() {
        return this.default(za`now()`)
    }
}
class Gj extends Za {
    static[q] = "PgDateBuilder";
    constructor(t) {
        super(t, "date", "PgDate")
    }
    build(t) {
        return new Zj(t,this.config)
    }
}
class Zj extends Oe {
    static[q] = "PgDate";
    getSQLType() {
        return "date"
    }
    mapFromDriverValue(t) {
        return new Date(t)
    }
    mapToDriverValue(t) {
        return t.toISOString()
    }
}
class Yj extends Za {
    static[q] = "PgDateStringBuilder";
    constructor(t) {
        super(t, "string", "PgDateString")
    }
    build(t) {
        return new Xj(t,this.config)
    }
}
class Xj extends Oe {
    static[q] = "PgDateString";
    getSQLType() {
        return "date"
    }
}
function Jj(e, t) {
    const {name: n, config: s} = Dt(e, t);
    return s?.mode === "date" ? new Gj(n) : new Yj(n)
}
class eD extends He {
    static[q] = "PgDoublePrecisionBuilder";
    constructor(t) {
        super(t, "number", "PgDoublePrecision")
    }
    build(t) {
        return new tD(t,this.config)
    }
}
class tD extends Oe {
    static[q] = "PgDoublePrecision";
    getSQLType() {
        return "double precision"
    }
    mapFromDriverValue(t) {
        return typeof t == "string" ? Number.parseFloat(t) : t
    }
}
function nD(e) {
    return new eD(e ?? "")
}
class rD extends He {
    static[q] = "PgInetBuilder";
    constructor(t) {
        super(t, "string", "PgInet")
    }
    build(t) {
        return new sD(t,this.config)
    }
}
class sD extends Oe {
    static[q] = "PgInet";
    getSQLType() {
        return "inet"
    }
}
function iD(e) {
    return new rD(e ?? "")
}
class oD extends Cc {
    static[q] = "PgIntegerBuilder";
    constructor(t) {
        super(t, "number", "PgInteger")
    }
    build(t) {
        return new aD(t,this.config)
    }
}
class aD extends Oe {
    static[q] = "PgInteger";
    getSQLType() {
        return "integer"
    }
    mapFromDriverValue(t) {
        return typeof t == "string" ? Number.parseInt(t) : t
    }
}
function Op(e) {
    return new oD(e ?? "")
}
class lD extends He {
    static[q] = "PgIntervalBuilder";
    constructor(t, n) {
        super(t, "string", "PgInterval"),
        this.config.intervalConfig = n
    }
    build(t) {
        return new uD(t,this.config)
    }
}
class uD extends Oe {
    static[q] = "PgInterval";
    fields = this.config.intervalConfig.fields;
    precision = this.config.intervalConfig.precision;
    getSQLType() {
        const t = this.fields ? ` ${this.fields}` : ""
          , n = this.precision ? `(${this.precision})` : "";
        return `interval${t}${n}`
    }
}
function cD(e, t={}) {
    const {name: n, config: s} = Dt(e, t);
    return new lD(n,s)
}
class dD extends He {
    static[q] = "PgJsonBuilder";
    constructor(t) {
        super(t, "json", "PgJson")
    }
    build(t) {
        return new fD(t,this.config)
    }
}
class fD extends Oe {
    static[q] = "PgJson";
    constructor(t, n) {
        super(t, n)
    }
    getSQLType() {
        return "json"
    }
    mapToDriverValue(t) {
        return JSON.stringify(t)
    }
    mapFromDriverValue(t) {
        if (typeof t == "string")
            try {
                return JSON.parse(t)
            } catch {
                return t
            }
        return t
    }
}
function hD(e) {
    return new dD(e ?? "")
}
class pD extends He {
    static[q] = "PgJsonbBuilder";
    constructor(t) {
        super(t, "json", "PgJsonb")
    }
    build(t) {
        return new mD(t,this.config)
    }
}
class mD extends Oe {
    static[q] = "PgJsonb";
    constructor(t, n) {
        super(t, n)
    }
    getSQLType() {
        return "jsonb"
    }
    mapToDriverValue(t) {
        return JSON.stringify(t)
    }
    mapFromDriverValue(t) {
        if (typeof t == "string")
            try {
                return JSON.parse(t)
            } catch {
                return t
            }
        return t
    }
}
function Mp(e) {
    return new pD(e ?? "")
}
class gD extends He {
    static[q] = "PgLineBuilder";
    constructor(t) {
        super(t, "array", "PgLine")
    }
    build(t) {
        return new yD(t,this.config)
    }
}
class yD extends Oe {
    static[q] = "PgLine";
    getSQLType() {
        return "line"
    }
    mapFromDriverValue(t) {
        const [n,s,o] = t.slice(1, -1).split(",");
        return [Number.parseFloat(n), Number.parseFloat(s), Number.parseFloat(o)]
    }
    mapToDriverValue(t) {
        return `{${t[0]},${t[1]},${t[2]}}`
    }
}
class vD extends He {
    static[q] = "PgLineABCBuilder";
    constructor(t) {
        super(t, "json", "PgLineABC")
    }
    build(t) {
        return new xD(t,this.config)
    }
}
class xD extends Oe {
    static[q] = "PgLineABC";
    getSQLType() {
        return "line"
    }
    mapFromDriverValue(t) {
        const [n,s,o] = t.slice(1, -1).split(",");
        return {
            a: Number.parseFloat(n),
            b: Number.parseFloat(s),
            c: Number.parseFloat(o)
        }
    }
    mapToDriverValue(t) {
        return `{${t.a},${t.b},${t.c}}`
    }
}
function wD(e, t) {
    const {name: n, config: s} = Dt(e, t);
    return !s?.mode || s.mode === "tuple" ? new gD(n) : new vD(n)
}
class bD extends He {
    static[q] = "PgMacaddrBuilder";
    constructor(t) {
        super(t, "string", "PgMacaddr")
    }
    build(t) {
        return new SD(t,this.config)
    }
}
class SD extends Oe {
    static[q] = "PgMacaddr";
    getSQLType() {
        return "macaddr"
    }
}
function TD(e) {
    return new bD(e ?? "")
}
class PD extends He {
    static[q] = "PgMacaddr8Builder";
    constructor(t) {
        super(t, "string", "PgMacaddr8")
    }
    build(t) {
        return new CD(t,this.config)
    }
}
class CD extends Oe {
    static[q] = "PgMacaddr8";
    getSQLType() {
        return "macaddr8"
    }
}
function ED(e) {
    return new PD(e ?? "")
}
class _D extends He {
    static[q] = "PgNumericBuilder";
    constructor(t, n, s) {
        super(t, "string", "PgNumeric"),
        this.config.precision = n,
        this.config.scale = s
    }
    build(t) {
        return new kD(t,this.config)
    }
}
class kD extends Oe {
    static[q] = "PgNumeric";
    precision;
    scale;
    constructor(t, n) {
        super(t, n),
        this.precision = n.precision,
        this.scale = n.scale
    }
    getSQLType() {
        return this.precision !== void 0 && this.scale !== void 0 ? `numeric(${this.precision}, ${this.scale})` : this.precision === void 0 ? "numeric" : `numeric(${this.precision})`
    }
}
function ND(e, t) {
    const {name: n, config: s} = Dt(e, t);
    return new _D(n,s?.precision,s?.scale)
}
class AD extends He {
    static[q] = "PgPointTupleBuilder";
    constructor(t) {
        super(t, "array", "PgPointTuple")
    }
    build(t) {
        return new RD(t,this.config)
    }
}
class RD extends Oe {
    static[q] = "PgPointTuple";
    getSQLType() {
        return "point"
    }
    mapFromDriverValue(t) {
        if (typeof t == "string") {
            const [n,s] = t.slice(1, -1).split(",");
            return [Number.parseFloat(n), Number.parseFloat(s)]
        }
        return [t.x, t.y]
    }
    mapToDriverValue(t) {
        return `(${t[0]},${t[1]})`
    }
}
class jD extends He {
    static[q] = "PgPointObjectBuilder";
    constructor(t) {
        super(t, "json", "PgPointObject")
    }
    build(t) {
        return new DD(t,this.config)
    }
}
class DD extends Oe {
    static[q] = "PgPointObject";
    getSQLType() {
        return "point"
    }
    mapFromDriverValue(t) {
        if (typeof t == "string") {
            const [n,s] = t.slice(1, -1).split(",");
            return {
                x: Number.parseFloat(n),
                y: Number.parseFloat(s)
            }
        }
        return t
    }
    mapToDriverValue(t) {
        return `(${t.x},${t.y})`
    }
}
function OD(e, t) {
    const {name: n, config: s} = Dt(e, t);
    return !s?.mode || s.mode === "tuple" ? new AD(n) : new jD(n)
}
function MD(e) {
    const t = [];
    for (let n = 0; n < e.length; n += 2)
        t.push(Number.parseInt(e.slice(n, n + 2), 16));
    return new Uint8Array(t)
}
function fx(e, t) {
    const n = new ArrayBuffer(8)
      , s = new DataView(n);
    for (let o = 0; o < 8; o++)
        s.setUint8(o, e[t + o]);
    return s.getFloat64(0, !0)
}
function fS(e) {
    const t = MD(e);
    let n = 0;
    const s = t[n];
    n += 1;
    const o = new DataView(t.buffer)
      , a = o.getUint32(n, s === 1);
    if (n += 4,
    a & 536870912 && (o.getUint32(n, s === 1),
    n += 4),
    (a & 65535) === 1) {
        const u = fx(t, n);
        n += 8;
        const c = fx(t, n);
        return n += 8,
        [u, c]
    }
    throw new Error("Unsupported geometry type")
}
class ID extends He {
    static[q] = "PgGeometryBuilder";
    constructor(t) {
        super(t, "array", "PgGeometry")
    }
    build(t) {
        return new FD(t,this.config)
    }
}
class FD extends Oe {
    static[q] = "PgGeometry";
    getSQLType() {
        return "geometry(point)"
    }
    mapFromDriverValue(t) {
        return fS(t)
    }
    mapToDriverValue(t) {
        return `point(${t[0]} ${t[1]})`
    }
}
class LD extends He {
    static[q] = "PgGeometryObjectBuilder";
    constructor(t) {
        super(t, "json", "PgGeometryObject")
    }
    build(t) {
        return new VD(t,this.config)
    }
}
class VD extends Oe {
    static[q] = "PgGeometryObject";
    getSQLType() {
        return "geometry(point)"
    }
    mapFromDriverValue(t) {
        const n = fS(t);
        return {
            x: n[0],
            y: n[1]
        }
    }
    mapToDriverValue(t) {
        return `point(${t.x} ${t.y})`
    }
}
function BD(e, t) {
    const {name: n, config: s} = Dt(e, t);
    return !s?.mode || s.mode === "tuple" ? new ID(n) : new LD(n)
}
class zD extends He {
    static[q] = "PgRealBuilder";
    constructor(t, n) {
        super(t, "number", "PgReal"),
        this.config.length = n
    }
    build(t) {
        return new UD(t,this.config)
    }
}
class UD extends Oe {
    static[q] = "PgReal";
    constructor(t, n) {
        super(t, n)
    }
    getSQLType() {
        return "real"
    }
    mapFromDriverValue = t => typeof t == "string" ? Number.parseFloat(t) : t
}
function $D(e) {
    return new zD(e ?? "")
}
class WD extends He {
    static[q] = "PgSerialBuilder";
    constructor(t) {
        super(t, "number", "PgSerial"),
        this.config.hasDefault = !0,
        this.config.notNull = !0
    }
    build(t) {
        return new HD(t,this.config)
    }
}
class HD extends Oe {
    static[q] = "PgSerial";
    getSQLType() {
        return "serial"
    }
}
function Ec(e) {
    return new WD(e ?? "")
}
class qD extends Cc {
    static[q] = "PgSmallIntBuilder";
    constructor(t) {
        super(t, "number", "PgSmallInt")
    }
    build(t) {
        return new QD(t,this.config)
    }
}
class QD extends Oe {
    static[q] = "PgSmallInt";
    getSQLType() {
        return "smallint"
    }
    mapFromDriverValue = t => typeof t == "string" ? Number(t) : t
}
function KD(e) {
    return new qD(e ?? "")
}
class GD extends He {
    static[q] = "PgSmallSerialBuilder";
    constructor(t) {
        super(t, "number", "PgSmallSerial"),
        this.config.hasDefault = !0,
        this.config.notNull = !0
    }
    build(t) {
        return new ZD(t,this.config)
    }
}
class ZD extends Oe {
    static[q] = "PgSmallSerial";
    getSQLType() {
        return "smallserial"
    }
}
function YD(e) {
    return new GD(e ?? "")
}
class XD extends He {
    static[q] = "PgTextBuilder";
    constructor(t, n) {
        super(t, "string", "PgText"),
        this.config.enumValues = n.enum
    }
    build(t) {
        return new JD(t,this.config)
    }
}
class JD extends Oe {
    static[q] = "PgText";
    enumValues = this.config.enumValues;
    getSQLType() {
        return "text"
    }
}
function $t(e, t={}) {
    const {name: n, config: s} = Dt(e, t);
    return new XD(n,s)
}
class eO extends Za {
    constructor(t, n, s) {
        super(t, "string", "PgTime"),
        this.withTimezone = n,
        this.precision = s,
        this.config.withTimezone = n,
        this.config.precision = s
    }
    static[q] = "PgTimeBuilder";
    build(t) {
        return new tO(t,this.config)
    }
}
class tO extends Oe {
    static[q] = "PgTime";
    withTimezone;
    precision;
    constructor(t, n) {
        super(t, n),
        this.withTimezone = n.withTimezone,
        this.precision = n.precision
    }
    getSQLType() {
        return `time${this.precision === void 0 ? "" : `(${this.precision})`}${this.withTimezone ? " with time zone" : ""}`
    }
}
function nO(e, t={}) {
    const {name: n, config: s} = Dt(e, t);
    return new eO(n,s.withTimezone ?? !1,s.precision)
}
class rO extends Za {
    static[q] = "PgTimestampBuilder";
    constructor(t, n, s) {
        super(t, "date", "PgTimestamp"),
        this.config.withTimezone = n,
        this.config.precision = s
    }
    build(t) {
        return new sO(t,this.config)
    }
}
class sO extends Oe {
    static[q] = "PgTimestamp";
    withTimezone;
    precision;
    constructor(t, n) {
        super(t, n),
        this.withTimezone = n.withTimezone,
        this.precision = n.precision
    }
    getSQLType() {
        return `timestamp${this.precision === void 0 ? "" : ` (${this.precision})`}${this.withTimezone ? " with time zone" : ""}`
    }
    mapFromDriverValue = t => new Date(this.withTimezone ? t : t + "+0000");
    mapToDriverValue = t => t.toISOString()
}
class iO extends Za {
    static[q] = "PgTimestampStringBuilder";
    constructor(t, n, s) {
        super(t, "string", "PgTimestampString"),
        this.config.withTimezone = n,
        this.config.precision = s
    }
    build(t) {
        return new oO(t,this.config)
    }
}
class oO extends Oe {
    static[q] = "PgTimestampString";
    withTimezone;
    precision;
    constructor(t, n) {
        super(t, n),
        this.withTimezone = n.withTimezone,
        this.precision = n.precision
    }
    getSQLType() {
        return `timestamp${this.precision === void 0 ? "" : `(${this.precision})`}${this.withTimezone ? " with time zone" : ""}`
    }
}
function vs(e, t={}) {
    const {name: n, config: s} = Dt(e, t);
    return s?.mode === "string" ? new iO(n,s.withTimezone ?? !1,s.precision) : new rO(n,s?.withTimezone ?? !1,s?.precision)
}
class aO extends He {
    static[q] = "PgUUIDBuilder";
    constructor(t) {
        super(t, "string", "PgUUID")
    }
    defaultRandom() {
        return this.default(za`gen_random_uuid()`)
    }
    build(t) {
        return new lO(t,this.config)
    }
}
class lO extends Oe {
    static[q] = "PgUUID";
    getSQLType() {
        return "uuid"
    }
}
function uO(e) {
    return new aO(e ?? "")
}
class cO extends He {
    static[q] = "PgVarcharBuilder";
    constructor(t, n) {
        super(t, "string", "PgVarchar"),
        this.config.length = n.length,
        this.config.enumValues = n.enum
    }
    build(t) {
        return new dO(t,this.config)
    }
}
class dO extends Oe {
    static[q] = "PgVarchar";
    length = this.config.length;
    enumValues = this.config.enumValues;
    getSQLType() {
        return this.length === void 0 ? "varchar" : `varchar(${this.length})`
    }
}
function zs(e, t={}) {
    const {name: n, config: s} = Dt(e, t);
    return new cO(n,s)
}
class fO extends He {
    static[q] = "PgBinaryVectorBuilder";
    constructor(t, n) {
        super(t, "string", "PgBinaryVector"),
        this.config.dimensions = n.dimensions
    }
    build(t) {
        return new hO(t,this.config)
    }
}
class hO extends Oe {
    static[q] = "PgBinaryVector";
    dimensions = this.config.dimensions;
    getSQLType() {
        return `bit(${this.dimensions})`
    }
}
function pO(e, t) {
    const {name: n, config: s} = Dt(e, t);
    return new fO(n,s)
}
class mO extends He {
    static[q] = "PgHalfVectorBuilder";
    constructor(t, n) {
        super(t, "array", "PgHalfVector"),
        this.config.dimensions = n.dimensions
    }
    build(t) {
        return new gO(t,this.config)
    }
}
class gO extends Oe {
    static[q] = "PgHalfVector";
    dimensions = this.config.dimensions;
    getSQLType() {
        return `halfvec(${this.dimensions})`
    }
    mapToDriverValue(t) {
        return JSON.stringify(t)
    }
    mapFromDriverValue(t) {
        return t.slice(1, -1).split(",").map(n => Number.parseFloat(n))
    }
}
function yO(e, t) {
    const {name: n, config: s} = Dt(e, t);
    return new mO(n,s)
}
class vO extends He {
    static[q] = "PgSparseVectorBuilder";
    constructor(t, n) {
        super(t, "string", "PgSparseVector"),
        this.config.dimensions = n.dimensions
    }
    build(t) {
        return new xO(t,this.config)
    }
}
class xO extends Oe {
    static[q] = "PgSparseVector";
    dimensions = this.config.dimensions;
    getSQLType() {
        return `sparsevec(${this.dimensions})`
    }
}
function wO(e, t) {
    const {name: n, config: s} = Dt(e, t);
    return new vO(n,s)
}
class bO extends He {
    static[q] = "PgVectorBuilder";
    constructor(t, n) {
        super(t, "array", "PgVector"),
        this.config.dimensions = n.dimensions
    }
    build(t) {
        return new SO(t,this.config)
    }
}
class SO extends Oe {
    static[q] = "PgVector";
    dimensions = this.config.dimensions;
    getSQLType() {
        return `vector(${this.dimensions})`
    }
    mapToDriverValue(t) {
        return JSON.stringify(t)
    }
    mapFromDriverValue(t) {
        return t.slice(1, -1).split(",").map(n => Number.parseFloat(n))
    }
}
function TO(e, t) {
    const {name: n, config: s} = Dt(e, t);
    return new bO(n,s)
}
function PO() {
    return {
        bigint: jj,
        bigserial: Fj,
        boolean: dS,
        char: Uj,
        cidr: Hj,
        customType: Kj,
        date: Jj,
        doublePrecision: nD,
        inet: iD,
        integer: Op,
        interval: cD,
        json: hD,
        jsonb: Mp,
        line: wD,
        macaddr: TD,
        macaddr8: ED,
        numeric: ND,
        point: OD,
        geometry: BD,
        real: $D,
        serial: Ec,
        smallint: KD,
        smallserial: YD,
        text: $t,
        time: nO,
        timestamp: vs,
        uuid: uO,
        varchar: zs,
        bit: pO,
        halfvec: yO,
        sparsevec: wO,
        vector: TO
    }
}
const Uh = Symbol.for("drizzle:PgInlineForeignKeys")
  , hx = Symbol.for("drizzle:EnableRLS");
class Kf extends hn {
    static[q] = "PgTable";
    static Symbol = Object.assign({}, hn.Symbol, {
        InlineForeignKeys: Uh,
        EnableRLS: hx
    });
    [Uh] = [];
    [hx] = !1;
    [hn.Symbol.ExtraConfigBuilder] = void 0
}
function CO(e, t, n, s, o=e) {
    const a = new Kf(e,s,o)
      , u = typeof t == "function" ? t(PO()) : t
      , c = Object.fromEntries(Object.entries(u).map( ([m,v]) => {
        const x = v;
        x.setName(m);
        const T = x.build(a);
        return a[Uh].push(...x.buildForeignKeys(T, a)),
        [m, T]
    }
    ))
      , f = Object.fromEntries(Object.entries(u).map( ([m,v]) => {
        const x = v;
        x.setName(m);
        const T = x.buildExtraConfigColumn(a);
        return [m, T]
    }
    ))
      , h = Object.assign(a, c);
    return h[hn.Symbol.Columns] = c,
    h[hn.Symbol.ExtraConfigColumns] = f,
    n && (h[Kf.Symbol.ExtraConfigBuilder] = n),
    Object.assign(h, {
        enableRLS: () => (h[Kf.Symbol.EnableRLS] = !0,
        h)
    })
}
const Ya = (e, t, n) => CO(e, t, n, void 0);
class EO {
    constructor(t, n) {
        this.unique = t,
        this.name = n
    }
    static[q] = "PgIndexBuilderOn";
    on(...t) {
        return new Gf(t.map(n => {
            if (St(n, st))
                return n;
            n = n;
            const s = new Wf(n.name,!!n.keyAsName,n.columnType,n.indexConfig);
            return n.indexConfig = JSON.parse(JSON.stringify(n.defaultConfig)),
            s
        }
        ),this.unique,!1,this.name)
    }
    onOnly(...t) {
        return new Gf(t.map(n => {
            if (St(n, st))
                return n;
            n = n;
            const s = new Wf(n.name,!!n.keyAsName,n.columnType,n.indexConfig);
            return n.indexConfig = n.defaultConfig,
            s
        }
        ),this.unique,!0,this.name)
    }
    using(t, ...n) {
        return new Gf(n.map(s => {
            if (St(s, st))
                return s;
            s = s;
            const o = new Wf(s.name,!!s.keyAsName,s.columnType,s.indexConfig);
            return s.indexConfig = JSON.parse(JSON.stringify(s.defaultConfig)),
            o
        }
        ),this.unique,!0,this.name,t)
    }
}
class Gf {
    static[q] = "PgIndexBuilder";
    config;
    constructor(t, n, s, o, a="btree") {
        this.config = {
            name: o,
            columns: t,
            unique: n,
            only: s,
            method: a
        }
    }
    concurrently() {
        return this.config.concurrently = !0,
        this
    }
    with(t) {
        return this.config.with = t,
        this
    }
    where(t) {
        return this.config.where = t,
        this
    }
    build(t) {
        return new _O(this.config,t)
    }
}
class _O {
    static[q] = "PgIndex";
    config;
    constructor(t, n) {
        this.config = {
            ...t,
            table: n
        }
    }
}
function kO(e) {
    return new EO(!1,e)
}
const ut = {
    INT8_MIN: -128,
    INT8_MAX: 127,
    INT8_UNSIGNED_MAX: 255,
    INT16_MIN: -32768,
    INT16_MAX: 32767,
    INT16_UNSIGNED_MAX: 65535,
    INT24_MIN: -8388608,
    INT24_MAX: 8388607,
    INT24_UNSIGNED_MAX: 16777215,
    INT32_MIN: -2147483648,
    INT32_MAX: 2147483647,
    INT32_UNSIGNED_MAX: 4294967295,
    INT48_MIN: -0x800000000000,
    INT48_MAX: 0x7fffffffffff,
    INT48_UNSIGNED_MAX: 0xffffffffffff,
    INT64_MIN: -9223372036854775808n,
    INT64_MAX: 9223372036854775807n,
    INT64_UNSIGNED_MAX: 18446744073709551615n
};
function vt(e, t) {
    return t.includes(e.columnType)
}
function NO(e) {
    return "enumValues"in e && Array.isArray(e.enumValues) && e.enumValues.length > 0
}
const AO = Ae.union([Ae.string(), Ae.number(), Ae.boolean(), Ae.null()])
  , RO = Ae.union([AO, Ae.record(Ae.any()), Ae.array(Ae.any())])
  , jO = Ae.custom(e => e instanceof Buffer);
function hS(e, t) {
    const n = t?.zodInstance ?? Ae
      , s = t?.coerce ?? {};
    let o;
    return NO(e) && (o = e.enumValues.length ? n.enum(e.enumValues) : n.string()),
    o || (vt(e, ["PgGeometry", "PgPointTuple"]) ? o = n.tuple([n.number(), n.number()]) : vt(e, ["PgGeometryObject", "PgPointObject"]) ? o = n.object({
        x: n.number(),
        y: n.number()
    }) : vt(e, ["PgHalfVector", "PgVector"]) ? (o = n.array(n.number()),
    o = e.dimensions ? o.length(e.dimensions) : o) : vt(e, ["PgLine"]) ? o = n.tuple([n.number(), n.number(), n.number()]) : vt(e, ["PgLineABC"]) ? o = n.object({
        a: n.number(),
        b: n.number(),
        c: n.number()
    }) : vt(e, ["PgArray"]) ? (o = n.array(hS(e.baseColumn, n)),
    o = e.size ? o.length(e.size) : o) : e.dataType === "array" ? o = n.array(n.any()) : e.dataType === "number" ? o = DO(e, n, s) : e.dataType === "bigint" ? o = OO(e, n, s) : e.dataType === "boolean" ? o = s === !0 || s.boolean ? n.coerce.boolean() : n.boolean() : e.dataType === "date" ? o = s === !0 || s.date ? n.coerce.date() : n.date() : e.dataType === "string" ? o = MO(e, n, s) : e.dataType === "json" ? o = RO : e.dataType === "custom" ? o = n.any() : e.dataType === "buffer" && (o = jO)),
    o || (o = n.any()),
    o
}
function DO(e, t, n) {
    let s = e.getSQLType().includes("unsigned"), o, a, u = !1;
    vt(e, ["MySqlTinyInt", "SingleStoreTinyInt"]) ? (o = s ? 0 : ut.INT8_MIN,
    a = s ? ut.INT8_UNSIGNED_MAX : ut.INT8_MAX,
    u = !0) : vt(e, ["PgSmallInt", "PgSmallSerial", "MySqlSmallInt", "SingleStoreSmallInt"]) ? (o = s ? 0 : ut.INT16_MIN,
    a = s ? ut.INT16_UNSIGNED_MAX : ut.INT16_MAX,
    u = !0) : vt(e, ["PgReal", "MySqlFloat", "MySqlMediumInt", "SingleStoreMediumInt", "SingleStoreFloat"]) ? (o = s ? 0 : ut.INT24_MIN,
    a = s ? ut.INT24_UNSIGNED_MAX : ut.INT24_MAX,
    u = vt(e, ["MySqlMediumInt", "SingleStoreMediumInt"])) : vt(e, ["PgInteger", "PgSerial", "MySqlInt", "SingleStoreInt"]) ? (o = s ? 0 : ut.INT32_MIN,
    a = s ? ut.INT32_UNSIGNED_MAX : ut.INT32_MAX,
    u = !0) : vt(e, ["PgDoublePrecision", "MySqlReal", "MySqlDouble", "SingleStoreReal", "SingleStoreDouble", "SQLiteReal"]) ? (o = s ? 0 : ut.INT48_MIN,
    a = s ? ut.INT48_UNSIGNED_MAX : ut.INT48_MAX) : vt(e, ["PgBigInt53", "PgBigSerial53", "MySqlBigInt53", "MySqlSerial", "SingleStoreBigInt53", "SingleStoreSerial", "SQLiteInteger"]) ? (s = s || vt(e, ["MySqlSerial", "SingleStoreSerial"]),
    o = s ? 0 : Number.MIN_SAFE_INTEGER,
    a = Number.MAX_SAFE_INTEGER,
    u = !0) : vt(e, ["MySqlYear", "SingleStoreYear"]) ? (o = 1901,
    a = 2155,
    u = !0) : (o = Number.MIN_SAFE_INTEGER,
    a = Number.MAX_SAFE_INTEGER);
    let c = n === !0 || n?.number ? t.coerce.number() : t.number();
    return c = c.min(o).max(a),
    u ? c.int() : c
}
function OO(e, t, n) {
    const s = e.getSQLType().includes("unsigned")
      , o = s ? 0n : ut.INT64_MIN
      , a = s ? ut.INT64_UNSIGNED_MAX : ut.INT64_MAX;
    return (n === !0 || n?.bigint ? t.coerce.bigint() : t.bigint()).min(o).max(a)
}
function MO(e, t, n) {
    if (vt(e, ["PgUUID"]))
        return t.string().uuid();
    let s, o, a = !1;
    vt(e, ["PgVarchar", "SQLiteText"]) ? s = e.length : vt(e, ["MySqlVarChar", "SingleStoreVarChar"]) ? s = e.length ?? ut.INT16_UNSIGNED_MAX : vt(e, ["MySqlText", "SingleStoreText"]) && (e.textType === "longtext" ? s = ut.INT32_UNSIGNED_MAX : e.textType === "mediumtext" ? s = ut.INT24_UNSIGNED_MAX : e.textType === "text" ? s = ut.INT16_UNSIGNED_MAX : s = ut.INT8_UNSIGNED_MAX),
    vt(e, ["PgChar", "MySqlChar", "SingleStoreChar"]) && (s = e.length,
    a = !0),
    vt(e, ["PgBinaryVector"]) && (o = /^[01]+$/,
    s = e.dimensions);
    let u = n === !0 || n?.string ? t.coerce.string() : t.string();
    return u = o ? u.regex(o) : u,
    s && a ? u.length(s) : s ? u.max(s) : u
}
function pS(e) {
    return oS(e) ? Ej(e) : _j(e)
}
function mS(e, t, n, s) {
    const o = {};
    for (const [a,u] of Object.entries(e)) {
        if (!St(u, Ba) && !St(u, st) && !St(u, st.Aliased) && typeof u == "object") {
            const v = oS(u) || Cj(u) ? pS(u) : u;
            o[a] = mS(v, t[a] ?? {}, n, s);
            continue
        }
        const c = t[a];
        if (c !== void 0 && typeof c != "function") {
            o[a] = c;
            continue
        }
        const f = St(u, Ba) ? u : void 0
          , h = f ? hS(f, s) : Ae.any()
          , m = typeof c == "function" ? c(h) : h;
        n.never(f) || (o[a] = m,
        f && (n.nullable(f) && (o[a] = o[a].nullable()),
        n.optional(f) && (o[a] = o[a].optional())))
    }
    return Ae.object(o)
}
const IO = {
    never: e => e?.generated?.type === "always" || e?.generatedIdentity?.type === "always",
    optional: e => !e.notNull || e.notNull && e.hasDefault,
    nullable: e => !e.notNull
}
  , _c = (e, t) => {
    const n = pS(e);
    return mS(n, {}, IO)
}
;
Ya("sessions", {
    sid: zs("sid").primaryKey(),
    sess: Mp("sess").notNull(),
    expire: vs("expire").notNull()
}, e => [kO("IDX_session_expire").on(e.expire)]);
const FO = Ya("users", {
    id: zs("id").primaryKey().default(za`gen_random_uuid()`),
    email: zs("email").unique(),
    firstName: zs("first_name"),
    lastName: zs("last_name"),
    profileImageUrl: zs("profile_image_url"),
    isAdmin: dS("is_admin").default(!1),
    createdAt: vs("created_at").defaultNow(),
    updatedAt: vs("updated_at").defaultNow()
})
  , gS = Ya("tournaments", {
    id: Ec("id").primaryKey(),
    title: $t("title").notNull(),
    description: $t("description").notNull(),
    game: $t("game").default("Brawl Stars"),
    date: vs("date").notNull(),
    prizePool: $t("prize_pool").notNull(),
    status: $t("status", {
        enum: ["upcoming", "ongoing", "completed"]
    }).default("upcoming"),
    maxTeams: Op("max_teams").default(32),
    imageUrl: $t("image_url"),
    bracketUrl: $t("bracket_url"),
    rules: $t("rules"),
    createdAt: vs("created_at").defaultNow()
})
  , LO = Ya("teams", {
    id: Ec("id").primaryKey(),
    tournamentId: Op("tournament_id").references( () => gS.id),
    name: $t("name").notNull(),
    captainDiscord: $t("captain_discord").notNull(),
    captainEmail: $t("captain_email"),
    status: $t("status", {
        enum: ["pending", "approved", "rejected"]
    }).default("pending"),
    players: Mp("players").$type(),
    createdAt: vs("created_at").defaultNow()
})
  , VO = Ya("partners", {
    id: Ec("id").primaryKey(),
    name: $t("name").notNull(),
    logoUrl: $t("logo_url"),
    websiteUrl: $t("website_url"),
    createdAt: vs("created_at").defaultNow()
});
_c(FO).omit({
    id: !0,
    createdAt: !0,
    updatedAt: !0
});
const yS = _c(gS).omit({
    id: !0,
    createdAt: !0
})
  , BO = _c(LO).omit({
    id: !0,
    createdAt: !0,
    status: !0
});
_c(VO).omit({
    id: !0,
    createdAt: !0
});
Ae.object({
    message: Ae.string(),
    field: Ae.string().optional()
}),
Ae.object({
    message: Ae.string()
}),
Ae.object({
    message: Ae.string()
}),
Ae.object({
    message: Ae.string()
});
const Ht = {
    tournaments: {
        list: {
            path: "/api/tournaments",
            input: Ae.object({
                status: Ae.enum(["upcoming", "ongoing", "completed"]).optional()
            }).optional(),
            responses: {
                200: Ae.array(Ae.custom())
            }
        },
        get: {
            path: "/api/tournaments/:id",
            responses: {
                200: Ae.custom()
            }
        },
        create: {
            method: "POST",
            path: "/api/tournaments",
            responses: {
                201: Ae.custom()
            }
        },
        update: {
            input: yS.partial(),
            responses: {
                200: Ae.custom()
            }
        },
        delete: {
            method: "DELETE",
            path: "/api/tournaments/:id",
            responses: {
                204: Ae.void()
            }
        }
    },
    teams: {
        create: {
            method: "POST",
            path: "/api/tournaments/:tournamentId/teams",
            input: BO.omit({
                tournamentId: !0
            }),
            responses: {
                201: Ae.custom()
            }
        },
        list: {
            path: "/api/tournaments/:tournamentId/teams",
            responses: {
                200: Ae.array(Ae.custom())
            }
        }
    },
    partners: {
        list: {
            responses: {
                200: Ae.array(Ae.custom())
            }
        }
    }
};
function kc(e, t) {
    let n = e;
    return t && Object.entries(t).forEach( ([s,o]) => {
        n.includes(`:${s}`) && (n = n.replace(`:${s}`, String(o)))
    }
    ),
    n
}
function Ip(e) {
    return cc({
        queryKey: [Ht.tournaments.list.path, e],
        queryFn: async () => {
            const t = e ? `${Ht.tournaments.list.path}?status=${e}` : Ht.tournaments.list.path
              , n = await fetch(t, {
                credentials: "include"
            });
            if (!n.ok)
                throw new Error("Failed to fetch tournaments");
            return await n.json()
        }
    })
}
function zO(e) {
    return cc({
        queryKey: [Ht.tournaments.get.path, e],
        queryFn: async () => {
            const t = kc(Ht.tournaments.get.path, {
                id: e
            })
              , n = await fetch(t, {
                credentials: "include"
            });
            if (n.status === 404)
                return null;
            if (!n.ok)
                throw new Error("Failed to fetch tournament");
            return await n.json()
        }
        ,
        enabled: !isNaN(e)
    })
}
function UO() {
    const e = uo();
    return dc({
        mutationFn: async t => {
            const n = await fetch(Ht.tournaments.create.path, {
                method: Ht.tournaments.create.method,
                headers: {
                    "Content-Type": "application/json"
                },
                body: JSON.stringify(t),
                credentials: "include"
            });
            if (!n.ok)
                throw n.status === 401 ? new Error("Unauthorized") : new Error("Failed to create tournament");
            return await n.json()
        }
        ,
        onSuccess: () => {
            e.invalidateQueries({
                queryKey: [Ht.tournaments.list.path]
            })
        }
    })
}
function $O() {
    const e = uo();
    return dc({
        mutationFn: async t => {
            const n = kc(Ht.tournaments.delete.path, {
                id: t
            });
            if (!(await fetch(n, {
                method: Ht.tournaments.delete.method,
                credentials: "include"
            })).ok)
                throw new Error("Failed to delete tournament")
        }
        ,
        onSuccess: () => {
            e.invalidateQueries({
                queryKey: [Ht.tournaments.list.path]
            })
        }
    })
}
function WO(e) {
    return cc({
        queryKey: [Ht.teams.list.path, e],
        queryFn: async () => {
            const t = kc(Ht.teams.list.path, {
                tournamentId: e
            })
              , n = await fetch(t, {
                credentials: "include"
            });
            if (!n.ok)
                throw new Error("Failed to fetch teams");
            return await n.json()
        }
        ,
        enabled: !isNaN(e)
    })
}
function HO(e) {
    const t = uo();
    return dc({
        mutationFn: async n => {
            const s = kc(Ht.teams.create.path, {
                tournamentId: e
            })
              , o = await fetch(s, {
                method: Ht.teams.create.method,
                headers: {
                    "Content-Type": "application/json"
                },
                body: JSON.stringify(n),
                credentials: "include"
            });
            if (!o.ok)
                throw new Error("Failed to register team");
            return await o.json()
        }
        ,
        onSuccess: () => {
            t.invalidateQueries({
                queryKey: [Ht.teams.list.path, e]
            })
        }
    })
}
function qn(e) {
    const t = Object.prototype.toString.call(e);
    return e instanceof Date || typeof e == "object" && t === "[object Date]" ? new e.constructor(+e) : typeof e == "number" || t === "[object Number]" || typeof e == "string" || t === "[object String]" ? new Date(e) : new Date(NaN)
}
function Xs(e, t) {
    return e instanceof Date ? new e.constructor(t) : new Date(t)
}
const vS = 6048e5
  , qO = 864e5;
let QO = {};
function Nc() {
    return QO
}
function Ua(e, t) {
    const n = Nc()
      , s = t?.weekStartsOn ?? t?.locale?.options?.weekStartsOn ?? n.weekStartsOn ?? n.locale?.options?.weekStartsOn ?? 0
      , o = qn(e)
      , a = o.getDay()
      , u = (a < s ? 7 : 0) + a - s;
    return o.setDate(o.getDate() - u),
    o.setHours(0, 0, 0, 0),
    o
}
function Gu(e) {
    return Ua(e, {
        weekStartsOn: 1
    })
}
function xS(e) {
    const t = qn(e)
      , n = t.getFullYear()
      , s = Xs(e, 0);
    s.setFullYear(n + 1, 0, 4),
    s.setHours(0, 0, 0, 0);
    const o = Gu(s)
      , a = Xs(e, 0);
    a.setFullYear(n, 0, 4),
    a.setHours(0, 0, 0, 0);
    const u = Gu(a);
    return t.getTime() >= o.getTime() ? n + 1 : t.getTime() >= u.getTime() ? n : n - 1
}
function px(e) {
    const t = qn(e);
    return t.setHours(0, 0, 0, 0),
    t
}
function mx(e) {
    const t = qn(e)
      , n = new Date(Date.UTC(t.getFullYear(), t.getMonth(), t.getDate(), t.getHours(), t.getMinutes(), t.getSeconds(), t.getMilliseconds()));
    return n.setUTCFullYear(t.getFullYear()),
    +e - +n
}
function KO(e, t) {
    const n = px(e)
      , s = px(t)
      , o = +n - mx(n)
      , a = +s - mx(s);
    return Math.round((o - a) / qO)
}
function GO(e) {
    const t = xS(e)
      , n = Xs(e, 0);
    return n.setFullYear(t, 0, 4),
    n.setHours(0, 0, 0, 0),
    Gu(n)
}
function ZO(e) {
    return e instanceof Date || typeof e == "object" && Object.prototype.toString.call(e) === "[object Date]"
}
function YO(e) {
    if (!ZO(e) && typeof e != "number")
        return !1;
    const t = qn(e);
    return !isNaN(Number(t))
}
function XO(e) {
    const t = qn(e)
      , n = Xs(e, 0);
    return n.setFullYear(t.getFullYear(), 0, 1),
    n.setHours(0, 0, 0, 0),
    n
}
const JO = {
    lessThanXSeconds: {
        one: "less than a second",
        other: "less than {{count}} seconds"
    },
    xSeconds: {
        one: "1 second",
        other: "{{count}} seconds"
    },
    halfAMinute: "half a minute",
    lessThanXMinutes: {
        one: "less than a minute",
        other: "less than {{count}} minutes"
    },
    xMinutes: {
        one: "1 minute",
        other: "{{count}} minutes"
    },
    aboutXHours: {
        one: "about 1 hour",
        other: "about {{count}} hours"
    },
    xHours: {
        one: "1 hour",
        other: "{{count}} hours"
    },
    xDays: {
        one: "1 day",
        other: "{{count}} days"
    },
    aboutXWeeks: {
        one: "about 1 week",
        other: "about {{count}} weeks"
    },
    xWeeks: {
        one: "1 week",
        other: "{{count}} weeks"
    },
    aboutXMonths: {
        one: "about 1 month",
        other: "about {{count}} months"
    },
    xMonths: {
        one: "1 month",
        other: "{{count}} months"
    },
    aboutXYears: {
        one: "about 1 year",
        other: "about {{count}} years"
    },
    xYears: {
        one: "1 year",
        other: "{{count}} years"
    },
    overXYears: {
        one: "over 1 year",
        other: "over {{count}} years"
    },
    almostXYears: {
        one: "almost 1 year",
        other: "almost {{count}} years"
    }
}
  , eM = (e, t, n) => {
    let s;
    const o = JO[e];
    return typeof o == "string" ? s = o : t === 1 ? s = o.one : s = o.other.replace("{{count}}", t.toString()),
    n?.addSuffix ? n.comparison && n.comparison > 0 ? "in " + s : s + " ago" : s
}
;
function Zf(e) {
    return (t={}) => {
        const n = t.width ? String(t.width) : e.defaultWidth;
        return e.formats[n] || e.formats[e.defaultWidth]
    }
}
const tM = {
    full: "EEEE, MMMM do, y",
    long: "MMMM do, y",
    medium: "MMM d, y",
    short: "MM/dd/yyyy"
}
  , nM = {
    full: "h:mm:ss a zzzz",
    long: "h:mm:ss a z",
    medium: "h:mm:ss a",
    short: "h:mm a"
}
  , rM = {
    full: "{{date}} 'at' {{time}}",
    long: "{{date}} 'at' {{time}}",
    medium: "{{date}}, {{time}}",
    short: "{{date}}, {{time}}"
}
  , sM = {
    date: Zf({
        formats: tM,
        defaultWidth: "full"
    }),
    time: Zf({
        formats: nM,
        defaultWidth: "full"
    }),
    dateTime: Zf({
        formats: rM,
        defaultWidth: "full"
    })
}
  , iM = {
    lastWeek: "'last' eeee 'at' p",
    yesterday: "'yesterday at' p",
    today: "'today at' p",
    tomorrow: "'tomorrow at' p",
    nextWeek: "eeee 'at' p",
    other: "P"
}
  , oM = (e, t, n, s) => iM[e];
function sa(e) {
    return (t, n) => {
        const s = n?.context ? String(n.context) : "standalone";
        let o;
        if (s === "formatting" && e.formattingValues) {
            const u = e.defaultFormattingWidth || e.defaultWidth
              , c = n?.width ? String(n.width) : u;
            o = e.formattingValues[c] || e.formattingValues[u]
        } else {
            const u = e.defaultWidth
              , c = n?.width ? String(n.width) : e.defaultWidth;
            o = e.values[c] || e.values[u]
        }
        const a = e.argumentCallback ? e.argumentCallback(t) : t;
        return o[a]
    }
}
const aM = {
    narrow: ["B", "A"],
    abbreviated: ["BC", "AD"],
    wide: ["Before Christ", "Anno Domini"]
}
  , lM = {
    narrow: ["1", "2", "3", "4"],
    abbreviated: ["Q1", "Q2", "Q3", "Q4"],
    wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]
}
  , uM = {
    narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
    abbreviated: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
    wide: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
}
  , cM = {
    narrow: ["S", "M", "T", "W", "T", "F", "S"],
    short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
    abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    wide: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
}
  , dM = {
    narrow: {
        am: "a",
        pm: "p",
        midnight: "mi",
        noon: "n",
        morning: "morning",
        afternoon: "afternoon",
        evening: "evening",
        night: "night"
    },
    abbreviated: {
        am: "AM",
        pm: "PM",
        midnight: "midnight",
        noon: "noon",
        morning: "morning",
        afternoon: "afternoon",
        evening: "evening",
        night: "night"
    },
    wide: {
        am: "a.m.",
        pm: "p.m.",
        midnight: "midnight",
        noon: "noon",
        morning: "morning",
        afternoon: "afternoon",
        evening: "evening",
        night: "night"
    }
}
  , fM = {
    narrow: {
        am: "a",
        pm: "p",
        midnight: "mi",
        noon: "n",
        morning: "in the morning",
        afternoon: "in the afternoon",
        evening: "in the evening",
        night: "at night"
    },
    abbreviated: {
        am: "AM",
        pm: "PM",
        midnight: "midnight",
        noon: "noon",
        morning: "in the morning",
        afternoon: "in the afternoon",
        evening: "in the evening",
        night: "at night"
    },
    wide: {
        am: "a.m.",
        pm: "p.m.",
        midnight: "midnight",
        noon: "noon",
        morning: "in the morning",
        afternoon: "in the afternoon",
        evening: "in the evening",
        night: "at night"
    }
}
  , hM = (e, t) => {
    const n = Number(e)
      , s = n % 100;
    if (s > 20 || s < 10)
        switch (s % 10) {
        case 1:
            return n + "st";
        case 2:
            return n + "nd";
        case 3:
            return n + "rd"
        }
    return n + "th"
}
  , pM = {
    ordinalNumber: hM,
    era: sa({
        values: aM,
        defaultWidth: "wide"
    }),
    quarter: sa({
        values: lM,
        defaultWidth: "wide",
        argumentCallback: e => e - 1
    }),
    month: sa({
        values: uM,
        defaultWidth: "wide"
    }),
    day: sa({
        values: cM,
        defaultWidth: "wide"
    }),
    dayPeriod: sa({
        values: dM,
        defaultWidth: "wide",
        formattingValues: fM,
        defaultFormattingWidth: "wide"
    })
};
function ia(e) {
    return (t, n={}) => {
        const s = n.width
          , o = s && e.matchPatterns[s] || e.matchPatterns[e.defaultMatchWidth]
          , a = t.match(o);
        if (!a)
            return null;
        const u = a[0]
          , c = s && e.parsePatterns[s] || e.parsePatterns[e.defaultParseWidth]
          , f = Array.isArray(c) ? gM(c, v => v.test(u)) : mM(c, v => v.test(u));
        let h;
        h = e.valueCallback ? e.valueCallback(f) : f,
        h = n.valueCallback ? n.valueCallback(h) : h;
        const m = t.slice(u.length);
        return {
            value: h,
            rest: m
        }
    }
}
function mM(e, t) {
    for (const n in e)
        if (Object.prototype.hasOwnProperty.call(e, n) && t(e[n]))
            return n
}
function gM(e, t) {
    for (let n = 0; n < e.length; n++)
        if (t(e[n]))
            return n
}
function yM(e) {
    return (t, n={}) => {
        const s = t.match(e.matchPattern);
        if (!s)
            return null;
        const o = s[0]
          , a = t.match(e.parsePattern);
        if (!a)
            return null;
        let u = e.valueCallback ? e.valueCallback(a[0]) : a[0];
        u = n.valueCallback ? n.valueCallback(u) : u;
        const c = t.slice(o.length);
        return {
            value: u,
            rest: c
        }
    }
}
const vM = /^(\d+)(th|st|nd|rd)?/i
  , xM = /\d+/i
  , wM = {
    narrow: /^(b|a)/i,
    abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
    wide: /^(before christ|before common era|anno domini|common era)/i
}
  , bM = {
    any: [/^b/i, /^(a|c)/i]
}
  , SM = {
    narrow: /^[1234]/i,
    abbreviated: /^q[1234]/i,
    wide: /^[1234](th|st|nd|rd)? quarter/i
}
  , TM = {
    any: [/1/i, /2/i, /3/i, /4/i]
}
  , PM = {
    narrow: /^[jfmasond]/i,
    abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
    wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
}
  , CM = {
    narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
    any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^may/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i]
}
  , EM = {
    narrow: /^[smtwf]/i,
    short: /^(su|mo|tu|we|th|fr|sa)/i,
    abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
    wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
}
  , _M = {
    narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
    any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
}
  , kM = {
    narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
    any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
}
  , NM = {
    any: {
        am: /^a/i,
        pm: /^p/i,
        midnight: /^mi/i,
        noon: /^no/i,
        morning: /morning/i,
        afternoon: /afternoon/i,
        evening: /evening/i,
        night: /night/i
    }
}
  , AM = {
    ordinalNumber: yM({
        matchPattern: vM,
        parsePattern: xM,
        valueCallback: e => parseInt(e, 10)
    }),
    era: ia({
        matchPatterns: wM,
        defaultMatchWidth: "wide",
        parsePatterns: bM,
        defaultParseWidth: "any"
    }),
    quarter: ia({
        matchPatterns: SM,
        defaultMatchWidth: "wide",
        parsePatterns: TM,
        defaultParseWidth: "any",
        valueCallback: e => e + 1
    }),
    month: ia({
        matchPatterns: PM,
        defaultMatchWidth: "wide",
        parsePatterns: CM,
        defaultParseWidth: "any"
    }),
    day: ia({
        matchPatterns: EM,
        defaultMatchWidth: "wide",
        parsePatterns: _M,
        defaultParseWidth: "any"
    }),
    dayPeriod: ia({
        matchPatterns: kM,
        defaultMatchWidth: "any",
        parsePatterns: NM,
        defaultParseWidth: "any"
    })
}
  , RM = {
    code: "en-US",
    formatDistance: eM,
    formatLong: sM,
    formatRelative: oM,
    localize: pM,
    match: AM,
    options: {
        weekStartsOn: 0,
        firstWeekContainsDate: 1
    }
};
function jM(e) {
    const t = qn(e);
    return KO(t, XO(t)) + 1
}
function DM(e) {
    const t = qn(e)
      , n = +Gu(t) - +GO(t);
    return Math.round(n / vS) + 1
}
function wS(e, t) {
    const n = qn(e)
      , s = n.getFullYear()
      , o = Nc()
      , a = t?.firstWeekContainsDate ?? t?.locale?.options?.firstWeekContainsDate ?? o.firstWeekContainsDate ?? o.locale?.options?.firstWeekContainsDate ?? 1
      , u = Xs(e, 0);
    u.setFullYear(s + 1, 0, a),
    u.setHours(0, 0, 0, 0);
    const c = Ua(u, t)
      , f = Xs(e, 0);
    f.setFullYear(s, 0, a),
    f.setHours(0, 0, 0, 0);
    const h = Ua(f, t);
    return n.getTime() >= c.getTime() ? s + 1 : n.getTime() >= h.getTime() ? s : s - 1
}
function OM(e, t) {
    const n = Nc()
      , s = t?.firstWeekContainsDate ?? t?.locale?.options?.firstWeekContainsDate ?? n.firstWeekContainsDate ?? n.locale?.options?.firstWeekContainsDate ?? 1
      , o = wS(e, t)
      , a = Xs(e, 0);
    return a.setFullYear(o, 0, s),
    a.setHours(0, 0, 0, 0),
    Ua(a, t)
}
function MM(e, t) {
    const n = qn(e)
      , s = +Ua(n, t) - +OM(n, t);
    return Math.round(s / vS) + 1
}
function Ye(e, t) {
    const n = e < 0 ? "-" : ""
      , s = Math.abs(e).toString().padStart(t, "0");
    return n + s
}
const is = {
    y(e, t) {
        const n = e.getFullYear()
          , s = n > 0 ? n : 1 - n;
        return Ye(t === "yy" ? s % 100 : s, t.length)
    },
    M(e, t) {
        const n = e.getMonth();
        return t === "M" ? String(n + 1) : Ye(n + 1, 2)
    },
    d(e, t) {
        return Ye(e.getDate(), t.length)
    },
    a(e, t) {
        const n = e.getHours() / 12 >= 1 ? "pm" : "am";
        switch (t) {
        case "a":
        case "aa":
            return n.toUpperCase();
        case "aaa":
            return n;
        case "aaaaa":
            return n[0];
        default:
            return n === "am" ? "a.m." : "p.m."
        }
    },
    h(e, t) {
        return Ye(e.getHours() % 12 || 12, t.length)
    },
    H(e, t) {
        return Ye(e.getHours(), t.length)
    },
    m(e, t) {
        return Ye(e.getMinutes(), t.length)
    },
    s(e, t) {
        return Ye(e.getSeconds(), t.length)
    },
    S(e, t) {
        const n = t.length
          , s = e.getMilliseconds()
          , o = Math.trunc(s * Math.pow(10, n - 3));
        return Ye(o, t.length)
    }
}
  , Oi = {
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
}
  , gx = {
    G: function(e, t, n) {
        const s = e.getFullYear() > 0 ? 1 : 0;
        switch (t) {
        case "G":
        case "GG":
        case "GGG":
            return n.era(s, {
                width: "abbreviated"
            });
        case "GGGGG":
            return n.era(s, {
                width: "narrow"
            });
        default:
            return n.era(s, {
                width: "wide"
            })
        }
    },
    y: function(e, t, n) {
        if (t === "yo") {
            const s = e.getFullYear()
              , o = s > 0 ? s : 1 - s;
            return n.ordinalNumber(o, {
                unit: "year"
            })
        }
        return is.y(e, t)
    },
    Y: function(e, t, n, s) {
        const o = wS(e, s)
          , a = o > 0 ? o : 1 - o;
        if (t === "YY") {
            const u = a % 100;
            return Ye(u, 2)
        }
        return t === "Yo" ? n.ordinalNumber(a, {
            unit: "year"
        }) : Ye(a, t.length)
    },
    R: function(e, t) {
        const n = xS(e);
        return Ye(n, t.length)
    },
    u: function(e, t) {
        const n = e.getFullYear();
        return Ye(n, t.length)
    },
    Q: function(e, t, n) {
        const s = Math.ceil((e.getMonth() + 1) / 3);
        switch (t) {
        case "Q":
            return String(s);
        case "QQ":
            return Ye(s, 2);
        case "Qo":
            return n.ordinalNumber(s, {
                unit: "quarter"
            });
        case "QQQ":
            return n.quarter(s, {
                width: "abbreviated",
                context: "formatting"
            });
        case "QQQQQ":
            return n.quarter(s, {
                width: "narrow",
                context: "formatting"
            });
        default:
            return n.quarter(s, {
                width: "wide",
                context: "formatting"
            })
        }
    },
    q: function(e, t, n) {
        const s = Math.ceil((e.getMonth() + 1) / 3);
        switch (t) {
        case "q":
            return String(s);
        case "qq":
            return Ye(s, 2);
        case "qo":
            return n.ordinalNumber(s, {
                unit: "quarter"
            });
        case "qqq":
            return n.quarter(s, {
                width: "abbreviated",
                context: "standalone"
            });
        case "qqqqq":
            return n.quarter(s, {
                width: "narrow",
                context: "standalone"
            });
        default:
            return n.quarter(s, {
                width: "wide",
                context: "standalone"
            })
        }
    },
    M: function(e, t, n) {
        const s = e.getMonth();
        switch (t) {
        case "M":
        case "MM":
            return is.M(e, t);
        case "Mo":
            return n.ordinalNumber(s + 1, {
                unit: "month"
            });
        case "MMM":
            return n.month(s, {
                width: "abbreviated",
                context: "formatting"
            });
        case "MMMMM":
            return n.month(s, {
                width: "narrow",
                context: "formatting"
            });
        default:
            return n.month(s, {
                width: "wide",
                context: "formatting"
            })
        }
    },
    L: function(e, t, n) {
        const s = e.getMonth();
        switch (t) {
        case "L":
            return String(s + 1);
        case "LL":
            return Ye(s + 1, 2);
        case "Lo":
            return n.ordinalNumber(s + 1, {
                unit: "month"
            });
        case "LLL":
            return n.month(s, {
                width: "abbreviated",
                context: "standalone"
            });
        case "LLLLL":
            return n.month(s, {
                width: "narrow",
                context: "standalone"
            });
        default:
            return n.month(s, {
                width: "wide",
                context: "standalone"
            })
        }
    },
    w: function(e, t, n, s) {
        const o = MM(e, s);
        return t === "wo" ? n.ordinalNumber(o, {
            unit: "week"
        }) : Ye(o, t.length)
    },
    I: function(e, t, n) {
        const s = DM(e);
        return t === "Io" ? n.ordinalNumber(s, {
            unit: "week"
        }) : Ye(s, t.length)
    },
    d: function(e, t, n) {
        return t === "do" ? n.ordinalNumber(e.getDate(), {
            unit: "date"
        }) : is.d(e, t)
    },
    D: function(e, t, n) {
        const s = jM(e);
        return t === "Do" ? n.ordinalNumber(s, {
            unit: "dayOfYear"
        }) : Ye(s, t.length)
    },
    E: function(e, t, n) {
        const s = e.getDay();
        switch (t) {
        case "E":
        case "EE":
        case "EEE":
            return n.day(s, {
                width: "abbreviated",
                context: "formatting"
            });
        case "EEEEE":
            return n.day(s, {
                width: "narrow",
                context: "formatting"
            });
        case "EEEEEE":
            return n.day(s, {
                width: "short",
                context: "formatting"
            });
        default:
            return n.day(s, {
                width: "wide",
                context: "formatting"
            })
        }
    },
    e: function(e, t, n, s) {
        const o = e.getDay()
          , a = (o - s.weekStartsOn + 8) % 7 || 7;
        switch (t) {
        case "e":
            return String(a);
        case "ee":
            return Ye(a, 2);
        case "eo":
            return n.ordinalNumber(a, {
                unit: "day"
            });
        case "eee":
            return n.day(o, {
                width: "abbreviated",
                context: "formatting"
            });
        case "eeeee":
            return n.day(o, {
                width: "narrow",
                context: "formatting"
            });
        case "eeeeee":
            return n.day(o, {
                width: "short",
                context: "formatting"
            });
        default:
            return n.day(o, {
                width: "wide",
                context: "formatting"
            })
        }
    },
    c: function(e, t, n, s) {
        const o = e.getDay()
          , a = (o - s.weekStartsOn + 8) % 7 || 7;
        switch (t) {
        case "c":
            return String(a);
        case "cc":
            return Ye(a, t.length);
        case "co":
            return n.ordinalNumber(a, {
                unit: "day"
            });
        case "ccc":
            return n.day(o, {
                width: "abbreviated",
                context: "standalone"
            });
        case "ccccc":
            return n.day(o, {
                width: "narrow",
                context: "standalone"
            });
        case "cccccc":
            return n.day(o, {
                width: "short",
                context: "standalone"
            });
        default:
            return n.day(o, {
                width: "wide",
                context: "standalone"
            })
        }
    },
    i: function(e, t, n) {
        const s = e.getDay()
          , o = s === 0 ? 7 : s;
        switch (t) {
        case "i":
            return String(o);
        case "ii":
            return Ye(o, t.length);
        case "io":
            return n.ordinalNumber(o, {
                unit: "day"
            });
        case "iii":
            return n.day(s, {
                width: "abbreviated",
                context: "formatting"
            });
        case "iiiii":
            return n.day(s, {
                width: "narrow",
                context: "formatting"
            });
        case "iiiiii":
            return n.day(s, {
                width: "short",
                context: "formatting"
            });
        default:
            return n.day(s, {
                width: "wide",
                context: "formatting"
            })
        }
    },
    a: function(e, t, n) {
        const o = e.getHours() / 12 >= 1 ? "pm" : "am";
        switch (t) {
        case "a":
        case "aa":
            return n.dayPeriod(o, {
                width: "abbreviated",
                context: "formatting"
            });
        case "aaa":
            return n.dayPeriod(o, {
                width: "abbreviated",
                context: "formatting"
            }).toLowerCase();
        case "aaaaa":
            return n.dayPeriod(o, {
                width: "narrow",
                context: "formatting"
            });
        default:
            return n.dayPeriod(o, {
                width: "wide",
                context: "formatting"
            })
        }
    },
    b: function(e, t, n) {
        const s = e.getHours();
        let o;
        switch (s === 12 ? o = Oi.noon : s === 0 ? o = Oi.midnight : o = s / 12 >= 1 ? "pm" : "am",
        t) {
        case "b":
        case "bb":
            return n.dayPeriod(o, {
                width: "abbreviated",
                context: "formatting"
            });
        case "bbb":
            return n.dayPeriod(o, {
                width: "abbreviated",
                context: "formatting"
            }).toLowerCase();
        case "bbbbb":
            return n.dayPeriod(o, {
                width: "narrow",
                context: "formatting"
            });
        default:
            return n.dayPeriod(o, {
                width: "wide",
                context: "formatting"
            })
        }
    },
    B: function(e, t, n) {
        const s = e.getHours();
        let o;
        switch (s >= 17 ? o = Oi.evening : s >= 12 ? o = Oi.afternoon : s >= 4 ? o = Oi.morning : o = Oi.night,
        t) {
        case "B":
        case "BB":
        case "BBB":
            return n.dayPeriod(o, {
                width: "abbreviated",
                context: "formatting"
            });
        case "BBBBB":
            return n.dayPeriod(o, {
                width: "narrow",
                context: "formatting"
            });
        default:
            return n.dayPeriod(o, {
                width: "wide",
                context: "formatting"
            })
        }
    },
    h: function(e, t, n) {
        if (t === "ho") {
            let s = e.getHours() % 12;
            return s === 0 && (s = 12),
            n.ordinalNumber(s, {
                unit: "hour"
            })
        }
        return is.h(e, t)
    },
    H: function(e, t, n) {
        return t === "Ho" ? n.ordinalNumber(e.getHours(), {
            unit: "hour"
        }) : is.H(e, t)
    },
    K: function(e, t, n) {
        const s = e.getHours() % 12;
        return t === "Ko" ? n.ordinalNumber(s, {
            unit: "hour"
        }) : Ye(s, t.length)
    },
    k: function(e, t, n) {
        let s = e.getHours();
        return s === 0 && (s = 24),
        t === "ko" ? n.ordinalNumber(s, {
            unit: "hour"
        }) : Ye(s, t.length)
    },
    m: function(e, t, n) {
        return t === "mo" ? n.ordinalNumber(e.getMinutes(), {
            unit: "minute"
        }) : is.m(e, t)
    },
    s: function(e, t, n) {
        return t === "so" ? n.ordinalNumber(e.getSeconds(), {
            unit: "second"
        }) : is.s(e, t)
    },
    S: function(e, t) {
        return is.S(e, t)
    },
    X: function(e, t, n) {
        const s = e.getTimezoneOffset();
        if (s === 0)
            return "Z";
        switch (t) {
        case "X":
            return vx(s);
        case "XXXX":
        case "XX":
            return Ls(s);
        default:
            return Ls(s, ":")
        }
    },
    x: function(e, t, n) {
        const s = e.getTimezoneOffset();
        switch (t) {
        case "x":
            return vx(s);
        case "xxxx":
        case "xx":
            return Ls(s);
        default:
            return Ls(s, ":")
        }
    },
    O: function(e, t, n) {
        const s = e.getTimezoneOffset();
        switch (t) {
        case "O":
        case "OO":
        case "OOO":
            return "GMT" + yx(s, ":");
        default:
            return "GMT" + Ls(s, ":")
        }
    },
    z: function(e, t, n) {
        const s = e.getTimezoneOffset();
        switch (t) {
        case "z":
        case "zz":
        case "zzz":
            return "GMT" + yx(s, ":");
        default:
            return "GMT" + Ls(s, ":")
        }
    },
    t: function(e, t, n) {
        const s = Math.trunc(e.getTime() / 1e3);
        return Ye(s, t.length)
    },
    T: function(e, t, n) {
        const s = e.getTime();
        return Ye(s, t.length)
    }
};
function yx(e, t="") {
    const n = e > 0 ? "-" : "+"
      , s = Math.abs(e)
      , o = Math.trunc(s / 60)
      , a = s % 60;
    return a === 0 ? n + String(o) : n + String(o) + t + Ye(a, 2)
}
function vx(e, t) {
    return e % 60 === 0 ? (e > 0 ? "-" : "+") + Ye(Math.abs(e) / 60, 2) : Ls(e, t)
}
function Ls(e, t="") {
    const n = e > 0 ? "-" : "+"
      , s = Math.abs(e)
      , o = Ye(Math.trunc(s / 60), 2)
      , a = Ye(s % 60, 2);
    return n + o + t + a
}
const xx = (e, t) => {
    switch (e) {
    case "P":
        return t.date({
            width: "short"
        });
    case "PP":
        return t.date({
            width: "medium"
        });
    case "PPP":
        return t.date({
            width: "long"
        });
    default:
        return t.date({
            width: "full"
        })
    }
}
  , bS = (e, t) => {
    switch (e) {
    case "p":
        return t.time({
            width: "short"
        });
    case "pp":
        return t.time({
            width: "medium"
        });
    case "ppp":
        return t.time({
            width: "long"
        });
    default:
        return t.time({
            width: "full"
        })
    }
}
  , IM = (e, t) => {
    const n = e.match(/(P+)(p+)?/) || []
      , s = n[1]
      , o = n[2];
    if (!o)
        return xx(e, t);
    let a;
    switch (s) {
    case "P":
        a = t.dateTime({
            width: "short"
        });
        break;
    case "PP":
        a = t.dateTime({
            width: "medium"
        });
        break;
    case "PPP":
        a = t.dateTime({
            width: "long"
        });
        break;
    default:
        a = t.dateTime({
            width: "full"
        });
        break
    }
    return a.replace("{{date}}", xx(s, t)).replace("{{time}}", bS(o, t))
}
  , FM = {
    p: bS,
    P: IM
}
  , LM = /^D+$/
  , VM = /^Y+$/
  , BM = ["D", "DD", "YY", "YYYY"];
function zM(e) {
    return LM.test(e)
}
function UM(e) {
    return VM.test(e)
}
function $M(e, t, n) {
    const s = WM(e, t, n);
    if (console.warn(s),
    BM.includes(e))
        throw new RangeError(s)
}
function WM(e, t, n) {
    const s = e[0] === "Y" ? "years" : "days of the month";
    return `Use \`${e.toLowerCase()}\` instead of \`${e}\` (in \`${t}\`) for formatting ${s} to the input \`${n}\`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md`
}
const HM = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g
  , qM = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g
  , QM = /^'([^]*?)'?$/
  , KM = /''/g
  , GM = /[a-zA-Z]/;
function SS(e, t, n) {
    const s = Nc()
      , o = s.locale ?? RM
      , a = s.firstWeekContainsDate ?? s.locale?.options?.firstWeekContainsDate ?? 1
      , u = s.weekStartsOn ?? s.locale?.options?.weekStartsOn ?? 0
      , c = qn(e);
    if (!YO(c))
        throw new RangeError("Invalid time value");
    let f = t.match(qM).map(m => {
        const v = m[0];
        if (v === "p" || v === "P") {
            const x = FM[v];
            return x(m, o.formatLong)
        }
        return m
    }
    ).join("").match(HM).map(m => {
        if (m === "''")
            return {
                isToken: !1,
                value: "'"
            };
        const v = m[0];
        if (v === "'")
            return {
                isToken: !1,
                value: ZM(m)
            };
        if (gx[v])
            return {
                isToken: !0,
                value: m
            };
        if (v.match(GM))
            throw new RangeError("Format string contains an unescaped latin alphabet character `" + v + "`");
        return {
            isToken: !1,
            value: m
        }
    }
    );
    o.localize.preprocessor && (f = o.localize.preprocessor(c, f));
    const h = {
        firstWeekContainsDate: a,
        weekStartsOn: u,
        locale: o
    };
    return f.map(m => {
        if (!m.isToken)
            return m.value;
        const v = m.value;
        (UM(v) || zM(v)) && $M(v, t, String(e));
        const x = gx[v[0]];
        return x(c, v, o.localize, h)
    }
    ).join("")
}
function ZM(e) {
    const t = e.match(QM);
    return t ? t[1].replace(KM, "'") : e
}
const Fp = w.createContext({});
function Lp(e) {
    const t = w.useRef(null);
    return t.current === null && (t.current = e()),
    t.current
}
const Ac = w.createContext(null)
  , Vp = w.createContext({
    transformPagePoint: e => e,
    isStatic: !1,
    reducedMotion: "never"
});
class YM extends w.Component {
    getSnapshotBeforeUpdate(t) {
        const n = this.props.childRef.current;
        if (n && t.isPresent && !this.props.isPresent) {
            const s = this.props.sizeRef.current;
            s.height = n.offsetHeight || 0,
            s.width = n.offsetWidth || 0,
            s.top = n.offsetTop,
            s.left = n.offsetLeft
        }
        return null
    }
    componentDidUpdate() {}
    render() {
        return this.props.children
    }
}
function XM({children: e, isPresent: t}) {
    const n = w.useId()
      , s = w.useRef(null)
      , o = w.useRef({
        width: 0,
        height: 0,
        top: 0,
        left: 0
    })
      , {nonce: a} = w.useContext(Vp);
    return w.useInsertionEffect( () => {
        const {width: u, height: c, top: f, left: h} = o.current;
        if (t || !s.current || !u || !c)
            return;
        s.current.dataset.motionPopId = n;
        const m = document.createElement("style");
        return a && (m.nonce = a),
        document.head.appendChild(m),
        m.sheet && m.sheet.insertRule(`
          [data-motion-pop-id="${n}"] {
            position: absolute !important;
            width: ${u}px !important;
            height: ${c}px !important;
            top: ${f}px !important;
            left: ${h}px !important;
          }
        `),
        () => {
            document.head.removeChild(m)
        }
    }
    , [t]),
    y.jsx(YM, {
        isPresent: t,
        childRef: s,
        sizeRef: o,
        children: w.cloneElement(e, {
            ref: s
        })
    })
}
const JM = ({children: e, initial: t, isPresent: n, onExitComplete: s, custom: o, presenceAffectsLayout: a, mode: u}) => {
    const c = Lp(e2)
      , f = w.useId()
      , h = w.useCallback(v => {
        c.set(v, !0);
        for (const x of c.values())
            if (!x)
                return;
        s && s()
    }
    , [c, s])
      , m = w.useMemo( () => ({
        id: f,
        initial: t,
        isPresent: n,
        custom: o,
        onExitComplete: h,
        register: v => (c.set(v, !1),
        () => c.delete(v))
    }), a ? [Math.random(), h] : [n, h]);
    return w.useMemo( () => {
        c.forEach( (v, x) => c.set(x, !1))
    }
    , [n]),
    w.useEffect( () => {
        !n && !c.size && s && s()
    }
    , [n]),
    u === "popLayout" && (e = y.jsx(XM, {
        isPresent: n,
        children: e
    })),
    y.jsx(Ac.Provider, {
        value: m,
        children: e
    })
}
;
function e2() {
    return new Map
}
function TS(e=!0) {
    const t = w.useContext(Ac);
    if (t === null)
        return [!0, null];
    const {isPresent: n, onExitComplete: s, register: o} = t
      , a = w.useId();
    w.useEffect( () => {
        e && o(a)
    }
    , [e]);
    const u = w.useCallback( () => e && s && s(a), [a, s, e]);
    return !n && s ? [!1, u] : [!0]
}
const yu = e => e.key || "";
function wx(e) {
    const t = [];
    return w.Children.forEach(e, n => {
        w.isValidElement(n) && t.push(n)
    }
    ),
    t
}
const Bp = typeof window < "u"
  , PS = Bp ? w.useLayoutEffect : w.useEffect
  , t2 = ({children: e, custom: t, initial: n=!0, onExitComplete: s, presenceAffectsLayout: o=!0, mode: a="sync", propagate: u=!1}) => {
    const [c,f] = TS(u)
      , h = w.useMemo( () => wx(e), [e])
      , m = u && !c ? [] : h.map(yu)
      , v = w.useRef(!0)
      , x = w.useRef(h)
      , T = Lp( () => new Map)
      , [C,S] = w.useState(h)
      , [P,_] = w.useState(h);
    PS( () => {
        v.current = !1,
        x.current = h;
        for (let M = 0; M < P.length; M++) {
            const O = yu(P[M]);
            m.includes(O) ? T.delete(O) : T.get(O) !== !0 && T.set(O, !1)
        }
    }
    , [P, m.length, m.join("-")]);
    const k = [];
    if (h !== C) {
        let M = [...h];
        for (let O = 0; O < P.length; O++) {
            const z = P[O]
              , U = yu(z);
            m.includes(U) || (M.splice(O, 0, z),
            k.push(z))
        }
        a === "wait" && k.length && (M = k),
        _(wx(M)),
        S(h);
        return
    }
    const {forceRender: j} = w.useContext(Fp);
    return y.jsx(y.Fragment, {
        children: P.map(M => {
            const O = yu(M)
              , z = u && !c ? !1 : h === P || m.includes(O)
              , U = () => {
                if (T.has(O))
                    T.set(O, !0);
                else
                    return;
                let W = !0;
                T.forEach(oe => {
                    oe || (W = !1)
                }
                ),
                W && (j?.(),
                _(x.current),
                u && f?.(),
                s && s())
            }
            ;
            return y.jsx(JM, {
                isPresent: z,
                initial: !v.current || n ? void 0 : !1,
                custom: z ? void 0 : t,
                presenceAffectsLayout: o,
                mode: a,
                onExitComplete: z ? void 0 : U,
                children: M
            }, O)
        }
        )
    })
}
  , gn = e => e;
let CS = gn;
function zp(e) {
    let t;
    return () => (t === void 0 && (t = e()),
    t)
}
const so = (e, t, n) => {
    const s = t - e;
    return s === 0 ? 1 : (n - e) / s
}
  , jr = e => e * 1e3
  , Dr = e => e / 1e3
  , n2 = {
    useManualTiming: !1
};
function r2(e) {
    let t = new Set
      , n = new Set
      , s = !1
      , o = !1;
    const a = new WeakSet;
    let u = {
        delta: 0,
        timestamp: 0,
        isProcessing: !1
    };
    function c(h) {
        a.has(h) && (f.schedule(h),
        e()),
        h(u)
    }
    const f = {
        schedule: (h, m=!1, v=!1) => {
            const T = v && s ? t : n;
            return m && a.add(h),
            T.has(h) || T.add(h),
            h
        }
        ,
        cancel: h => {
            n.delete(h),
            a.delete(h)
        }
        ,
        process: h => {
            if (u = h,
            s) {
                o = !0;
                return
            }
            s = !0,
            [t,n] = [n, t],
            t.forEach(c),
            t.clear(),
            s = !1,
            o && (o = !1,
            f.process(h))
        }
    };
    return f
}
const vu = ["read", "resolveKeyframes", "update", "preRender", "render", "postRender"]
  , s2 = 40;
function ES(e, t) {
    let n = !1
      , s = !0;
    const o = {
        delta: 0,
        timestamp: 0,
        isProcessing: !1
    }
      , a = () => n = !0
      , u = vu.reduce( (_, k) => (_[k] = r2(a),
    _), {})
      , {read: c, resolveKeyframes: f, update: h, preRender: m, render: v, postRender: x} = u
      , T = () => {
        const _ = performance.now();
        n = !1,
        o.delta = s ? 1e3 / 60 : Math.max(Math.min(_ - o.timestamp, s2), 1),
        o.timestamp = _,
        o.isProcessing = !0,
        c.process(o),
        f.process(o),
        h.process(o),
        m.process(o),
        v.process(o),
        x.process(o),
        o.isProcessing = !1,
        n && t && (s = !1,
        e(T))
    }
      , C = () => {
        n = !0,
        s = !0,
        o.isProcessing || e(T)
    }
    ;
    return {
        schedule: vu.reduce( (_, k) => {
            const j = u[k];
            return _[k] = (M, O=!1, z=!1) => (n || C(),
            j.schedule(M, O, z)),
            _
        }
        , {}),
        cancel: _ => {
            for (let k = 0; k < vu.length; k++)
                u[vu[k]].cancel(_)
        }
        ,
        state: o,
        steps: u
    }
}
const {schedule: it, cancel: xs, state: Ft, steps: Yf} = ES(typeof requestAnimationFrame < "u" ? requestAnimationFrame : gn, !0)
  , _S = w.createContext({
    strict: !1
})
  , bx = {
    animation: ["animate", "variants", "whileHover", "whileTap", "exit", "whileInView", "whileFocus", "whileDrag"],
    exit: ["exit"],
    drag: ["drag", "dragControls"],
    focus: ["whileFocus"],
    hover: ["whileHover", "onHoverStart", "onHoverEnd"],
    tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"],
    pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],
    inView: ["whileInView", "onViewportEnter", "onViewportLeave"],
    layout: ["layout", "layoutId"]
}
  , io = {};
for (const e in bx)
    io[e] = {
        isEnabled: t => bx[e].some(n => !!t[n])
    };
function i2(e) {
    for (const t in e)
        io[t] = {
            ...io[t],
            ...e[t]
        }
}
const o2 = new Set(["animate", "exit", "variants", "initial", "style", "values", "variants", "transition", "transformTemplate", "custom", "inherit", "onBeforeLayoutMeasure", "onAnimationStart", "onAnimationComplete", "onUpdate", "onDragStart", "onDrag", "onDragEnd", "onMeasureDragConstraints", "onDirectionLock", "onDragTransitionEnd", "_dragX", "_dragY", "onHoverStart", "onHoverEnd", "onViewportEnter", "onViewportLeave", "globalTapTarget", "ignoreStrict", "viewport"]);
function Zu(e) {
    return e.startsWith("while") || e.startsWith("drag") && e !== "draggable" || e.startsWith("layout") || e.startsWith("onTap") || e.startsWith("onPan") || e.startsWith("onLayout") || o2.has(e)
}
let kS = e => !Zu(e);
function a2(e) {
    e && (kS = t => t.startsWith("on") ? !Zu(t) : e(t))
}
try {
    a2(require("@emotion/is-prop-valid").default)
} catch {}
function l2(e, t, n) {
    const s = {};
    for (const o in e)
        o === "values" && typeof e.values == "object" || (kS(o) || n === !0 && Zu(o) || !t && !Zu(o) || e.draggable && o.startsWith("onDrag")) && (s[o] = e[o]);
    return s
}
function u2(e) {
    if (typeof Proxy > "u")
        return e;
    const t = new Map
      , n = (...s) => e(...s);
    return new Proxy(n,{
        get: (s, o) => o === "create" ? e : (t.has(o) || t.set(o, e(o)),
        t.get(o))
    })
}
const Rc = w.createContext({});
function $a(e) {
    return typeof e == "string" || Array.isArray(e)
}
function jc(e) {
    return e !== null && typeof e == "object" && typeof e.start == "function"
}
const Up = ["animate", "whileInView", "whileFocus", "whileHover", "whileTap", "whileDrag", "exit"]
  , $p = ["initial", ...Up];
function Dc(e) {
    return jc(e.animate) || $p.some(t => $a(e[t]))
}
function NS(e) {
    return !!(Dc(e) || e.variants)
}
function c2(e, t) {
    if (Dc(e)) {
        const {initial: n, animate: s} = e;
        return {
            initial: n === !1 || $a(n) ? n : void 0,
            animate: $a(s) ? s : void 0
        }
    }
    return e.inherit !== !1 ? t : {}
}
function d2(e) {
    const {initial: t, animate: n} = c2(e, w.useContext(Rc));
    return w.useMemo( () => ({
        initial: t,
        animate: n
    }), [Sx(t), Sx(n)])
}
function Sx(e) {
    return Array.isArray(e) ? e.join(" ") : e
}
const f2 = Symbol.for("motionComponentSymbol");
function zi(e) {
    return e && typeof e == "object" && Object.prototype.hasOwnProperty.call(e, "current")
}
function h2(e, t, n) {
    return w.useCallback(s => {
        s && e.onMount && e.onMount(s),
        t && (s ? t.mount(s) : t.unmount()),
        n && (typeof n == "function" ? n(s) : zi(n) && (n.current = s))
    }
    , [t])
}
const Wp = e => e.replace(/([a-z])([A-Z])/gu, "$1-$2").toLowerCase()
  , p2 = "framerAppearId"
  , AS = "data-" + Wp(p2)
  , {schedule: Hp} = ES(queueMicrotask, !1)
  , RS = w.createContext({});
function m2(e, t, n, s, o) {
    var a, u;
    const {visualElement: c} = w.useContext(Rc)
      , f = w.useContext(_S)
      , h = w.useContext(Ac)
      , m = w.useContext(Vp).reducedMotion
      , v = w.useRef(null);
    s = s || f.renderer,
    !v.current && s && (v.current = s(e, {
        visualState: t,
        parent: c,
        props: n,
        presenceContext: h,
        blockInitialAnimation: h ? h.initial === !1 : !1,
        reducedMotionConfig: m
    }));
    const x = v.current
      , T = w.useContext(RS);
    x && !x.projection && o && (x.type === "html" || x.type === "svg") && g2(v.current, n, o, T);
    const C = w.useRef(!1);
    w.useInsertionEffect( () => {
        x && C.current && x.update(n, h)
    }
    );
    const S = n[AS]
      , P = w.useRef(!!S && !(!((a = window.MotionHandoffIsComplete) === null || a === void 0) && a.call(window, S)) && ((u = window.MotionHasOptimisedAnimation) === null || u === void 0 ? void 0 : u.call(window, S)));
    return PS( () => {
        x && (C.current = !0,
        window.MotionIsMounted = !0,
        x.updateFeatures(),
        Hp.render(x.render),
        P.current && x.animationState && x.animationState.animateChanges())
    }
    ),
    w.useEffect( () => {
        x && (!P.current && x.animationState && x.animationState.animateChanges(),
        P.current && (queueMicrotask( () => {
            var _;
            (_ = window.MotionHandoffMarkAsComplete) === null || _ === void 0 || _.call(window, S)
        }
        ),
        P.current = !1))
    }
    ),
    x
}
function g2(e, t, n, s) {
    const {layoutId: o, layout: a, drag: u, dragConstraints: c, layoutScroll: f, layoutRoot: h} = t;
    e.projection = new n(e.latestValues,t["data-framer-portal-id"] ? void 0 : jS(e.parent)),
    e.projection.setOptions({
        layoutId: o,
        layout: a,
        alwaysMeasureLayout: !!u || c && zi(c),
        visualElement: e,
        animationType: typeof a == "string" ? a : "both",
        initialPromotionConfig: s,
        layoutScroll: f,
        layoutRoot: h
    })
}
function jS(e) {
    if (e)
        return e.options.allowProjection !== !1 ? e.projection : jS(e.parent)
}
function y2({preloadedFeatures: e, createVisualElement: t, useRender: n, useVisualState: s, Component: o}) {
    var a, u;
    e && i2(e);
    function c(h, m) {
        let v;
        const x = {
            ...w.useContext(Vp),
            ...h,
            layoutId: v2(h)
        }
          , {isStatic: T} = x
          , C = d2(h)
          , S = s(h, T);
        if (!T && Bp) {
            x2();
            const P = w2(x);
            v = P.MeasureLayout,
            C.visualElement = m2(o, S, x, t, P.ProjectionNode)
        }
        return y.jsxs(Rc.Provider, {
            value: C,
            children: [v && C.visualElement ? y.jsx(v, {
                visualElement: C.visualElement,
                ...x
            }) : null, n(o, h, h2(S, C.visualElement, m), S, T, C.visualElement)]
        })
    }
    c.displayName = `motion.${typeof o == "string" ? o : `create(${(u = (a = o.displayName) !== null && a !== void 0 ? a : o.name) !== null && u !== void 0 ? u : ""})`}`;
    const f = w.forwardRef(c);
    return f[f2] = o,
    f
}
function v2({layoutId: e}) {
    const t = w.useContext(Fp).id;
    return t && e !== void 0 ? t + "-" + e : e
}
function x2(e, t) {
    w.useContext(_S).strict
}
function w2(e) {
    const {drag: t, layout: n} = io;
    if (!t && !n)
        return {};
    const s = {
        ...t,
        ...n
    };
    return {
        MeasureLayout: t?.isEnabled(e) || n?.isEnabled(e) ? s.MeasureLayout : void 0,
        ProjectionNode: s.ProjectionNode
    }
}
const b2 = ["animate", "circle", "defs", "desc", "ellipse", "g", "image", "line", "filter", "marker", "mask", "metadata", "path", "pattern", "polygon", "polyline", "rect", "stop", "switch", "symbol", "svg", "text", "tspan", "use", "view"];
function qp(e) {
    return typeof e != "string" || e.includes("-") ? !1 : !!(b2.indexOf(e) > -1 || /[A-Z]/u.test(e))
}
function Tx(e) {
    const t = [{}, {}];
    return e?.values.forEach( (n, s) => {
        t[0][s] = n.get(),
        t[1][s] = n.getVelocity()
    }
    ),
    t
}
function Qp(e, t, n, s) {
    if (typeof t == "function") {
        const [o,a] = Tx(s);
        t = t(n !== void 0 ? n : e.custom, o, a)
    }
    if (typeof t == "string" && (t = e.variants && e.variants[t]),
    typeof t == "function") {
        const [o,a] = Tx(s);
        t = t(n !== void 0 ? n : e.custom, o, a)
    }
    return t
}
const $h = e => Array.isArray(e)
  , S2 = e => !!(e && typeof e == "object" && e.mix && e.toValue)
  , T2 = e => $h(e) ? e[e.length - 1] || 0 : e
  , Wt = e => !!(e && e.getVelocity);
function ku(e) {
    const t = Wt(e) ? e.get() : e;
    return S2(t) ? t.toValue() : t
}
function P2({scrapeMotionValuesFromProps: e, createRenderState: t, onUpdate: n}, s, o, a) {
    const u = {
        latestValues: C2(s, o, a, e),
        renderState: t()
    };
    return n && (u.onMount = c => n({
        props: s,
        current: c,
        ...u
    }),
    u.onUpdate = c => n(c)),
    u
}
const DS = e => (t, n) => {
    const s = w.useContext(Rc)
      , o = w.useContext(Ac)
      , a = () => P2(e, t, s, o);
    return n ? a() : Lp(a)
}
;
function C2(e, t, n, s) {
    const o = {}
      , a = s(e, {});
    for (const x in a)
        o[x] = ku(a[x]);
    let {initial: u, animate: c} = e;
    const f = Dc(e)
      , h = NS(e);
    t && h && !f && e.inherit !== !1 && (u === void 0 && (u = t.initial),
    c === void 0 && (c = t.animate));
    let m = n ? n.initial === !1 : !1;
    m = m || u === !1;
    const v = m ? c : u;
    if (v && typeof v != "boolean" && !jc(v)) {
        const x = Array.isArray(v) ? v : [v];
        for (let T = 0; T < x.length; T++) {
            const C = Qp(e, x[T]);
            if (C) {
                const {transitionEnd: S, transition: P, ..._} = C;
                for (const k in _) {
                    let j = _[k];
                    if (Array.isArray(j)) {
                        const M = m ? j.length - 1 : 0;
                        j = j[M]
                    }
                    j !== null && (o[k] = j)
                }
                for (const k in S)
                    o[k] = S[k]
            }
        }
    }
    return o
}
const po = ["transformPerspective", "x", "y", "z", "translateX", "translateY", "translateZ", "scale", "scaleX", "scaleY", "rotate", "rotateX", "rotateY", "rotateZ", "skew", "skewX", "skewY"]
  , ni = new Set(po)
  , OS = e => t => typeof t == "string" && t.startsWith(e)
  , MS = OS("--")
  , E2 = OS("var(--")
  , Kp = e => E2(e) ? _2.test(e.split("/*")[0].trim()) : !1
  , _2 = /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu
  , IS = (e, t) => t && typeof e == "number" ? t.transform(e) : e
  , Fr = (e, t, n) => n > t ? t : n < e ? e : n
  , mo = {
    test: e => typeof e == "number",
    parse: parseFloat,
    transform: e => e
}
  , Wa = {
    ...mo,
    transform: e => Fr(0, 1, e)
}
  , xu = {
    ...mo,
    default: 1
}
  , Xa = e => ({
    test: t => typeof t == "string" && t.endsWith(e) && t.split(" ").length === 1,
    parse: parseFloat,
    transform: t => `${t}${e}`
})
  , os = Xa("deg")
  , lr = Xa("%")
  , Pe = Xa("px")
  , k2 = Xa("vh")
  , N2 = Xa("vw")
  , Px = {
    ...lr,
    parse: e => lr.parse(e) / 100,
    transform: e => lr.transform(e * 100)
}
  , A2 = {
    borderWidth: Pe,
    borderTopWidth: Pe,
    borderRightWidth: Pe,
    borderBottomWidth: Pe,
    borderLeftWidth: Pe,
    borderRadius: Pe,
    radius: Pe,
    borderTopLeftRadius: Pe,
    borderTopRightRadius: Pe,
    borderBottomRightRadius: Pe,
    borderBottomLeftRadius: Pe,
    width: Pe,
    maxWidth: Pe,
    height: Pe,
    maxHeight: Pe,
    top: Pe,
    right: Pe,
    bottom: Pe,
    left: Pe,
    padding: Pe,
    paddingTop: Pe,
    paddingRight: Pe,
    paddingBottom: Pe,
    paddingLeft: Pe,
    margin: Pe,
    marginTop: Pe,
    marginRight: Pe,
    marginBottom: Pe,
    marginLeft: Pe,
    backgroundPositionX: Pe,
    backgroundPositionY: Pe
}
  , R2 = {
    rotate: os,
    rotateX: os,
    rotateY: os,
    rotateZ: os,
    scale: xu,
    scaleX: xu,
    scaleY: xu,
    scaleZ: xu,
    skew: os,
    skewX: os,
    skewY: os,
    distance: Pe,
    translateX: Pe,
    translateY: Pe,
    translateZ: Pe,
    x: Pe,
    y: Pe,
    z: Pe,
    perspective: Pe,
    transformPerspective: Pe,
    opacity: Wa,
    originX: Px,
    originY: Px,
    originZ: Pe
}
  , Cx = {
    ...mo,
    transform: Math.round
}
  , Gp = {
    ...A2,
    ...R2,
    zIndex: Cx,
    size: Pe,
    fillOpacity: Wa,
    strokeOpacity: Wa,
    numOctaves: Cx
}
  , j2 = {
    x: "translateX",
    y: "translateY",
    z: "translateZ",
    transformPerspective: "perspective"
}
  , D2 = po.length;
function O2(e, t, n) {
    let s = ""
      , o = !0;
    for (let a = 0; a < D2; a++) {
        const u = po[a]
          , c = e[u];
        if (c === void 0)
            continue;
        let f = !0;
        if (typeof c == "number" ? f = c === (u.startsWith("scale") ? 1 : 0) : f = parseFloat(c) === 0,
        !f || n) {
            const h = IS(c, Gp[u]);
            if (!f) {
                o = !1;
                const m = j2[u] || u;
                s += `${m}(${h}) `
            }
            n && (t[u] = h)
        }
    }
    return s = s.trim(),
    n ? s = n(t, o ? "" : s) : o && (s = "none"),
    s
}
function Zp(e, t, n) {
    const {style: s, vars: o, transformOrigin: a} = e;
    let u = !1
      , c = !1;
    for (const f in t) {
        const h = t[f];
        if (ni.has(f)) {
            u = !0;
            continue
        } else if (MS(f)) {
            o[f] = h;
            continue
        } else {
            const m = IS(h, Gp[f]);
            f.startsWith("origin") ? (c = !0,
            a[f] = m) : s[f] = m
        }
    }
    if (t.transform || (u || n ? s.transform = O2(t, e.transform, n) : s.transform && (s.transform = "none")),
    c) {
        const {originX: f="50%", originY: h="50%", originZ: m=0} = a;
        s.transformOrigin = `${f} ${h} ${m}`
    }
}
const M2 = {
    offset: "stroke-dashoffset",
    array: "stroke-dasharray"
}
  , I2 = {
    offset: "strokeDashoffset",
    array: "strokeDasharray"
};
function F2(e, t, n=1, s=0, o=!0) {
    e.pathLength = 1;
    const a = o ? M2 : I2;
    e[a.offset] = Pe.transform(-s);
    const u = Pe.transform(t)
      , c = Pe.transform(n);
    e[a.array] = `${u} ${c}`
}
function Ex(e, t, n) {
    return typeof e == "string" ? e : Pe.transform(t + n * e)
}
function L2(e, t, n) {
    const s = Ex(t, e.x, e.width)
      , o = Ex(n, e.y, e.height);
    return `${s} ${o}`
}
function Yp(e, {attrX: t, attrY: n, attrScale: s, originX: o, originY: a, pathLength: u, pathSpacing: c=1, pathOffset: f=0, ...h}, m, v) {
    if (Zp(e, h, v),
    m) {
        e.style.viewBox && (e.attrs.viewBox = e.style.viewBox);
        return
    }
    e.attrs = e.style,
    e.style = {};
    const {attrs: x, style: T, dimensions: C} = e;
    x.transform && (C && (T.transform = x.transform),
    delete x.transform),
    C && (o !== void 0 || a !== void 0 || T.transform) && (T.transformOrigin = L2(C, o !== void 0 ? o : .5, a !== void 0 ? a : .5)),
    t !== void 0 && (x.x = t),
    n !== void 0 && (x.y = n),
    s !== void 0 && (x.scale = s),
    u !== void 0 && F2(x, u, c, f, !1)
}
const Xp = () => ({
    style: {},
    transform: {},
    transformOrigin: {},
    vars: {}
})
  , FS = () => ({
    ...Xp(),
    attrs: {}
})
  , Jp = e => typeof e == "string" && e.toLowerCase() === "svg";
function LS(e, {style: t, vars: n}, s, o) {
    Object.assign(e.style, t, o && o.getProjectionStyles(s));
    for (const a in n)
        e.style.setProperty(a, n[a])
}
const VS = new Set(["baseFrequency", "diffuseConstant", "kernelMatrix", "kernelUnitLength", "keySplines", "keyTimes", "limitingConeAngle", "markerHeight", "markerWidth", "numOctaves", "targetX", "targetY", "surfaceScale", "specularConstant", "specularExponent", "stdDeviation", "tableValues", "viewBox", "gradientTransform", "pathLength", "startOffset", "textLength", "lengthAdjust"]);
function BS(e, t, n, s) {
    LS(e, t, void 0, s);
    for (const o in t.attrs)
        e.setAttribute(VS.has(o) ? o : Wp(o), t.attrs[o])
}
const Yu = {};
function V2(e) {
    Object.assign(Yu, e)
}
function zS(e, {layout: t, layoutId: n}) {
    return ni.has(e) || e.startsWith("origin") || (t || n !== void 0) && (!!Yu[e] || e === "opacity")
}
function em(e, t, n) {
    var s;
    const {style: o} = e
      , a = {};
    for (const u in o)
        (Wt(o[u]) || t.style && Wt(t.style[u]) || zS(u, e) || ((s = n?.getValue(u)) === null || s === void 0 ? void 0 : s.liveStyle) !== void 0) && (a[u] = o[u]);
    return a
}
function US(e, t, n) {
    const s = em(e, t, n);
    for (const o in e)
        if (Wt(e[o]) || Wt(t[o])) {
            const a = po.indexOf(o) !== -1 ? "attr" + o.charAt(0).toUpperCase() + o.substring(1) : o;
            s[a] = e[o]
        }
    return s
}
function B2(e, t) {
    try {
        t.dimensions = typeof e.getBBox == "function" ? e.getBBox() : e.getBoundingClientRect()
    } catch {
        t.dimensions = {
            x: 0,
            y: 0,
            width: 0,
            height: 0
        }
    }
}
const _x = ["x", "y", "width", "height", "cx", "cy", "r"]
  , z2 = {
    useVisualState: DS({
        scrapeMotionValuesFromProps: US,
        createRenderState: FS,
        onUpdate: ({props: e, prevProps: t, current: n, renderState: s, latestValues: o}) => {
            if (!n)
                return;
            let a = !!e.drag;
            if (!a) {
                for (const c in o)
                    if (ni.has(c)) {
                        a = !0;
                        break
                    }
            }
            if (!a)
                return;
            let u = !t;
            if (t)
                for (let c = 0; c < _x.length; c++) {
                    const f = _x[c];
                    e[f] !== t[f] && (u = !0)
                }
            u && it.read( () => {
                B2(n, s),
                it.render( () => {
                    Yp(s, o, Jp(n.tagName), e.transformTemplate),
                    BS(n, s)
                }
                )
            }
            )
        }
    })
}
  , U2 = {
    useVisualState: DS({
        scrapeMotionValuesFromProps: em,
        createRenderState: Xp
    })
};
function $S(e, t, n) {
    for (const s in t)
        !Wt(t[s]) && !zS(s, n) && (e[s] = t[s])
}
function $2({transformTemplate: e}, t) {
    return w.useMemo( () => {
        const n = Xp();
        return Zp(n, t, e),
        Object.assign({}, n.vars, n.style)
    }
    , [t])
}
function W2(e, t) {
    const n = e.style || {}
      , s = {};
    return $S(s, n, e),
    Object.assign(s, $2(e, t)),
    s
}
function H2(e, t) {
    const n = {}
      , s = W2(e, t);
    return e.drag && e.dragListener !== !1 && (n.draggable = !1,
    s.userSelect = s.WebkitUserSelect = s.WebkitTouchCallout = "none",
    s.touchAction = e.drag === !0 ? "none" : `pan-${e.drag === "x" ? "y" : "x"}`),
    e.tabIndex === void 0 && (e.onTap || e.onTapStart || e.whileTap) && (n.tabIndex = 0),
    n.style = s,
    n
}
function q2(e, t, n, s) {
    const o = w.useMemo( () => {
        const a = FS();
        return Yp(a, t, Jp(s), e.transformTemplate),
        {
            ...a.attrs,
            style: {
                ...a.style
            }
        }
    }
    , [t]);
    if (e.style) {
        const a = {};
        $S(a, e.style, e),
        o.style = {
            ...a,
            ...o.style
        }
    }
    return o
}
function Q2(e=!1) {
    return (n, s, o, {latestValues: a}, u) => {
        const f = (qp(n) ? q2 : H2)(s, a, u, n)
          , h = l2(s, typeof n == "string", e)
          , m = n !== w.Fragment ? {
            ...h,
            ...f,
            ref: o
        } : {}
          , {children: v} = s
          , x = w.useMemo( () => Wt(v) ? v.get() : v, [v]);
        return w.createElement(n, {
            ...m,
            children: x
        })
    }
}
function K2(e, t) {
    return function(s, {forwardMotionProps: o}={
        forwardMotionProps: !1
    }) {
        const u = {
            ...qp(s) ? z2 : U2,
            preloadedFeatures: e,
            useRender: Q2(o),
            createVisualElement: t,
            Component: s
        };
        return y2(u)
    }
}
function WS(e, t) {
    if (!Array.isArray(t))
        return !1;
    const n = t.length;
    if (n !== e.length)
        return !1;
    for (let s = 0; s < n; s++)
        if (t[s] !== e[s])
            return !1;
    return !0
}
function Oc(e, t, n) {
    const s = e.getProps();
    return Qp(s, t, n !== void 0 ? n : s.custom, e)
}
const G2 = zp( () => window.ScrollTimeline !== void 0);
class Z2 {
    constructor(t) {
        this.stop = () => this.runAll("stop"),
        this.animations = t.filter(Boolean)
    }
    get finished() {
        return Promise.all(this.animations.map(t => "finished"in t ? t.finished : t))
    }
    getAll(t) {
        return this.animations[0][t]
    }
    setAll(t, n) {
        for (let s = 0; s < this.animations.length; s++)
            this.animations[s][t] = n
    }
    attachTimeline(t, n) {
        const s = this.animations.map(o => {
            if (G2() && o.attachTimeline)
                return o.attachTimeline(t);
            if (typeof n == "function")
                return n(o)
        }
        );
        return () => {
            s.forEach( (o, a) => {
                o && o(),
                this.animations[a].stop()
            }
            )
        }
    }
    get time() {
        return this.getAll("time")
    }
    set time(t) {
        this.setAll("time", t)
    }
    get speed() {
        return this.getAll("speed")
    }
    set speed(t) {
        this.setAll("speed", t)
    }
    get startTime() {
        return this.getAll("startTime")
    }
    get duration() {
        let t = 0;
        for (let n = 0; n < this.animations.length; n++)
            t = Math.max(t, this.animations[n].duration);
        return t
    }
    runAll(t) {
        this.animations.forEach(n => n[t]())
    }
    flatten() {
        this.runAll("flatten")
    }
    play() {
        this.runAll("play")
    }
    pause() {
        this.runAll("pause")
    }
    cancel() {
        this.runAll("cancel")
    }
    complete() {
        this.runAll("complete")
    }
}
class Y2 extends Z2 {
    then(t, n) {
        return Promise.all(this.animations).then(t).catch(n)
    }
}
function tm(e, t) {
    return e ? e[t] || e.default || e : void 0
}
const Wh = 2e4;
function HS(e) {
    let t = 0;
    const n = 50;
    let s = e.next(t);
    for (; !s.done && t < Wh; )
        t += n,
        s = e.next(t);
    return t >= Wh ? 1 / 0 : t
}
function nm(e) {
    return typeof e == "function"
}
function kx(e, t) {
    e.timeline = t,
    e.onfinish = null
}
const rm = e => Array.isArray(e) && typeof e[0] == "number"
  , X2 = {
    linearEasing: void 0
};
function J2(e, t) {
    const n = zp(e);
    return () => {
        var s;
        return (s = X2[t]) !== null && s !== void 0 ? s : n()
    }
}
const Xu = J2( () => {
    try {
        document.createElement("div").animate({
            opacity: 0
        }, {
            easing: "linear(0, 1)"
        })
    } catch {
        return !1
    }
    return !0
}
, "linearEasing")
  , qS = (e, t, n=10) => {
    let s = "";
    const o = Math.max(Math.round(t / n), 2);
    for (let a = 0; a < o; a++)
        s += e(so(0, o - 1, a)) + ", ";
    return `linear(${s.substring(0, s.length - 2)})`
}
;
function QS(e) {
    return !!(typeof e == "function" && Xu() || !e || typeof e == "string" && (e in Hh || Xu()) || rm(e) || Array.isArray(e) && e.every(QS))
}
const da = ([e,t,n,s]) => `cubic-bezier(${e}, ${t}, ${n}, ${s})`
  , Hh = {
    linear: "linear",
    ease: "ease",
    easeIn: "ease-in",
    easeOut: "ease-out",
    easeInOut: "ease-in-out",
    circIn: da([0, .65, .55, 1]),
    circOut: da([.55, 0, 1, .45]),
    backIn: da([.31, .01, .66, -.59]),
    backOut: da([.33, 1.53, .69, .99])
};
function KS(e, t) {
    if (e)
        return typeof e == "function" && Xu() ? qS(e, t) : rm(e) ? da(e) : Array.isArray(e) ? e.map(n => KS(n, t) || Hh.easeOut) : Hh[e]
}
const In = {
    x: !1,
    y: !1
};
function GS() {
    return In.x || In.y
}
function eI(e, t, n) {
    var s;
    if (e instanceof Element)
        return [e];
    if (typeof e == "string") {
        let o = document;
        const a = (s = void 0) !== null && s !== void 0 ? s : o.querySelectorAll(e);
        return a ? Array.from(a) : []
    }
    return Array.from(e)
}
function ZS(e, t) {
    const n = eI(e)
      , s = new AbortController
      , o = {
        passive: !0,
        ...t,
        signal: s.signal
    };
    return [n, o, () => s.abort()]
}
function Nx(e) {
    return t => {
        t.pointerType === "touch" || GS() || e(t)
    }
}
function tI(e, t, n={}) {
    const [s,o,a] = ZS(e, n)
      , u = Nx(c => {
        const {target: f} = c
          , h = t(c);
        if (typeof h != "function" || !f)
            return;
        const m = Nx(v => {
            h(v),
            f.removeEventListener("pointerleave", m)
        }
        );
        f.addEventListener("pointerleave", m, o)
    }
    );
    return s.forEach(c => {
        c.addEventListener("pointerenter", u, o)
    }
    ),
    a
}
const YS = (e, t) => t ? e === t ? !0 : YS(e, t.parentElement) : !1
  , sm = e => e.pointerType === "mouse" ? typeof e.button != "number" || e.button <= 0 : e.isPrimary !== !1
  , nI = new Set(["BUTTON", "INPUT", "SELECT", "TEXTAREA", "A"]);
function rI(e) {
    return nI.has(e.tagName) || e.tabIndex !== -1
}
const fa = new WeakSet;
function Ax(e) {
    return t => {
        t.key === "Enter" && e(t)
    }
}
function Xf(e, t) {
    e.dispatchEvent(new PointerEvent("pointer" + t,{
        isPrimary: !0,
        bubbles: !0
    }))
}
const sI = (e, t) => {
    const n = e.currentTarget;
    if (!n)
        return;
    const s = Ax( () => {
        if (fa.has(n))
            return;
        Xf(n, "down");
        const o = Ax( () => {
            Xf(n, "up")
        }
        )
          , a = () => Xf(n, "cancel");
        n.addEventListener("keyup", o, t),
        n.addEventListener("blur", a, t)
    }
    );
    n.addEventListener("keydown", s, t),
    n.addEventListener("blur", () => n.removeEventListener("keydown", s), t)
}
;
function Rx(e) {
    return sm(e) && !GS()
}
function iI(e, t, n={}) {
    const [s,o,a] = ZS(e, n)
      , u = c => {
        const f = c.currentTarget;
        if (!Rx(c) || fa.has(f))
            return;
        fa.add(f);
        const h = t(c)
          , m = (T, C) => {
            window.removeEventListener("pointerup", v),
            window.removeEventListener("pointercancel", x),
            !(!Rx(T) || !fa.has(f)) && (fa.delete(f),
            typeof h == "function" && h(T, {
                success: C
            }))
        }
          , v = T => {
            m(T, n.useGlobalTarget || YS(f, T.target))
        }
          , x = T => {
            m(T, !1)
        }
        ;
        window.addEventListener("pointerup", v, o),
        window.addEventListener("pointercancel", x, o)
    }
    ;
    return s.forEach(c => {
        !rI(c) && c.getAttribute("tabindex") === null && (c.tabIndex = 0),
        (n.useGlobalTarget ? window : c).addEventListener("pointerdown", u, o),
        c.addEventListener("focus", h => sI(h, o), o)
    }
    ),
    a
}
function oI(e) {
    return e === "x" || e === "y" ? In[e] ? null : (In[e] = !0,
    () => {
        In[e] = !1
    }
    ) : In.x || In.y ? null : (In.x = In.y = !0,
    () => {
        In.x = In.y = !1
    }
    )
}
const XS = new Set(["width", "height", "top", "left", "right", "bottom", ...po]);
let Nu;
function aI() {
    Nu = void 0
}
const ur = {
    now: () => (Nu === void 0 && ur.set(Ft.isProcessing || n2.useManualTiming ? Ft.timestamp : performance.now()),
    Nu),
    set: e => {
        Nu = e,
        queueMicrotask(aI)
    }
};
function im(e, t) {
    e.indexOf(t) === -1 && e.push(t)
}
function om(e, t) {
    const n = e.indexOf(t);
    n > -1 && e.splice(n, 1)
}
class am {
    constructor() {
        this.subscriptions = []
    }
    add(t) {
        return im(this.subscriptions, t),
        () => om(this.subscriptions, t)
    }
    notify(t, n, s) {
        const o = this.subscriptions.length;
        if (o)
            if (o === 1)
                this.subscriptions[0](t, n, s);
            else
                for (let a = 0; a < o; a++) {
                    const u = this.subscriptions[a];
                    u && u(t, n, s)
                }
    }
    getSize() {
        return this.subscriptions.length
    }
    clear() {
        this.subscriptions.length = 0
    }
}
function JS(e, t) {
    return t ? e * (1e3 / t) : 0
}
const jx = 30
  , lI = e => !isNaN(parseFloat(e));
class uI {
    constructor(t, n={}) {
        this.version = "11.18.2",
        this.canTrackVelocity = null,
        this.events = {},
        this.updateAndNotify = (s, o=!0) => {
            const a = ur.now();
            this.updatedAt !== a && this.setPrevFrameValue(),
            this.prev = this.current,
            this.setCurrent(s),
            this.current !== this.prev && this.events.change && this.events.change.notify(this.current),
            o && this.events.renderRequest && this.events.renderRequest.notify(this.current)
        }
        ,
        this.hasAnimated = !1,
        this.setCurrent(t),
        this.owner = n.owner
    }
    setCurrent(t) {
        this.current = t,
        this.updatedAt = ur.now(),
        this.canTrackVelocity === null && t !== void 0 && (this.canTrackVelocity = lI(this.current))
    }
    setPrevFrameValue(t=this.current) {
        this.prevFrameValue = t,
        this.prevUpdatedAt = this.updatedAt
    }
    onChange(t) {
        return this.on("change", t)
    }
    on(t, n) {
        this.events[t] || (this.events[t] = new am);
        const s = this.events[t].add(n);
        return t === "change" ? () => {
            s(),
            it.read( () => {
                this.events.change.getSize() || this.stop()
            }
            )
        }
        : s
    }
    clearListeners() {
        for (const t in this.events)
            this.events[t].clear()
    }
    attach(t, n) {
        this.passiveEffect = t,
        this.stopPassiveEffect = n
    }
    set(t, n=!0) {
        !n || !this.passiveEffect ? this.updateAndNotify(t, n) : this.passiveEffect(t, this.updateAndNotify)
    }
    setWithVelocity(t, n, s) {
        this.set(n),
        this.prev = void 0,
        this.prevFrameValue = t,
        this.prevUpdatedAt = this.updatedAt - s
    }
    jump(t, n=!0) {
        this.updateAndNotify(t),
        this.prev = t,
        this.prevUpdatedAt = this.prevFrameValue = void 0,
        n && this.stop(),
        this.stopPassiveEffect && this.stopPassiveEffect()
    }
    get() {
        return this.current
    }
    getPrevious() {
        return this.prev
    }
    getVelocity() {
        const t = ur.now();
        if (!this.canTrackVelocity || this.prevFrameValue === void 0 || t - this.updatedAt > jx)
            return 0;
        const n = Math.min(this.updatedAt - this.prevUpdatedAt, jx);
        return JS(parseFloat(this.current) - parseFloat(this.prevFrameValue), n)
    }
    start(t) {
        return this.stop(),
        new Promise(n => {
            this.hasAnimated = !0,
            this.animation = t(n),
            this.events.animationStart && this.events.animationStart.notify()
        }
        ).then( () => {
            this.events.animationComplete && this.events.animationComplete.notify(),
            this.clearAnimation()
        }
        )
    }
    stop() {
        this.animation && (this.animation.stop(),
        this.events.animationCancel && this.events.animationCancel.notify()),
        this.clearAnimation()
    }
    isAnimating() {
        return !!this.animation
    }
    clearAnimation() {
        delete this.animation
    }
    destroy() {
        this.clearListeners(),
        this.stop(),
        this.stopPassiveEffect && this.stopPassiveEffect()
    }
}
function Ha(e, t) {
    return new uI(e,t)
}
function cI(e, t, n) {
    e.hasValue(t) ? e.getValue(t).set(n) : e.addValue(t, Ha(n))
}
function dI(e, t) {
    const n = Oc(e, t);
    let {transitionEnd: s={}, transition: o={}, ...a} = n || {};
    a = {
        ...a,
        ...s
    };
    for (const u in a) {
        const c = T2(a[u]);
        cI(e, u, c)
    }
}
function fI(e) {
    return !!(Wt(e) && e.add)
}
function qh(e, t) {
    const n = e.getValue("willChange");
    if (fI(n))
        return n.add(t)
}
function e1(e) {
    return e.props[AS]
}
const t1 = (e, t, n) => (((1 - 3 * n + 3 * t) * e + (3 * n - 6 * t)) * e + 3 * t) * e
  , hI = 1e-7
  , pI = 12;
function mI(e, t, n, s, o) {
    let a, u, c = 0;
    do
        u = t + (n - t) / 2,
        a = t1(u, s, o) - e,
        a > 0 ? n = u : t = u;
    while (Math.abs(a) > hI && ++c < pI);
    return u
}
function Ja(e, t, n, s) {
    if (e === t && n === s)
        return gn;
    const o = a => mI(a, 0, 1, e, n);
    return a => a === 0 || a === 1 ? a : t1(o(a), t, s)
}
const n1 = e => t => t <= .5 ? e(2 * t) / 2 : (2 - e(2 * (1 - t))) / 2
  , r1 = e => t => 1 - e(1 - t)
  , s1 = Ja(.33, 1.53, .69, .99)
  , lm = r1(s1)
  , i1 = n1(lm)
  , o1 = e => (e *= 2) < 1 ? .5 * lm(e) : .5 * (2 - Math.pow(2, -10 * (e - 1)))
  , um = e => 1 - Math.sin(Math.acos(e))
  , a1 = r1(um)
  , l1 = n1(um)
  , u1 = e => /^0[^.\s]+$/u.test(e);
function gI(e) {
    return typeof e == "number" ? e === 0 : e !== null ? e === "none" || e === "0" || u1(e) : !0
}
const ya = e => Math.round(e * 1e5) / 1e5
  , cm = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu;
function yI(e) {
    return e == null
}
const vI = /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu
  , dm = (e, t) => n => !!(typeof n == "string" && vI.test(n) && n.startsWith(e) || t && !yI(n) && Object.prototype.hasOwnProperty.call(n, t))
  , c1 = (e, t, n) => s => {
    if (typeof s != "string")
        return s;
    const [o,a,u,c] = s.match(cm);
    return {
        [e]: parseFloat(o),
        [t]: parseFloat(a),
        [n]: parseFloat(u),
        alpha: c !== void 0 ? parseFloat(c) : 1
    }
}
  , xI = e => Fr(0, 255, e)
  , Jf = {
    ...mo,
    transform: e => Math.round(xI(e))
}
  , Us = {
    test: dm("rgb", "red"),
    parse: c1("red", "green", "blue"),
    transform: ({red: e, green: t, blue: n, alpha: s=1}) => "rgba(" + Jf.transform(e) + ", " + Jf.transform(t) + ", " + Jf.transform(n) + ", " + ya(Wa.transform(s)) + ")"
};
function wI(e) {
    let t = ""
      , n = ""
      , s = ""
      , o = "";
    return e.length > 5 ? (t = e.substring(1, 3),
    n = e.substring(3, 5),
    s = e.substring(5, 7),
    o = e.substring(7, 9)) : (t = e.substring(1, 2),
    n = e.substring(2, 3),
    s = e.substring(3, 4),
    o = e.substring(4, 5),
    t += t,
    n += n,
    s += s,
    o += o),
    {
        red: parseInt(t, 16),
        green: parseInt(n, 16),
        blue: parseInt(s, 16),
        alpha: o ? parseInt(o, 16) / 255 : 1
    }
}
const Qh = {
    test: dm("#"),
    parse: wI,
    transform: Us.transform
}
  , Ui = {
    test: dm("hsl", "hue"),
    parse: c1("hue", "saturation", "lightness"),
    transform: ({hue: e, saturation: t, lightness: n, alpha: s=1}) => "hsla(" + Math.round(e) + ", " + lr.transform(ya(t)) + ", " + lr.transform(ya(n)) + ", " + ya(Wa.transform(s)) + ")"
}
  , Ut = {
    test: e => Us.test(e) || Qh.test(e) || Ui.test(e),
    parse: e => Us.test(e) ? Us.parse(e) : Ui.test(e) ? Ui.parse(e) : Qh.parse(e),
    transform: e => typeof e == "string" ? e : e.hasOwnProperty("red") ? Us.transform(e) : Ui.transform(e)
}
  , bI = /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu;
function SI(e) {
    var t, n;
    return isNaN(e) && typeof e == "string" && (((t = e.match(cm)) === null || t === void 0 ? void 0 : t.length) || 0) + (((n = e.match(bI)) === null || n === void 0 ? void 0 : n.length) || 0) > 0
}
const d1 = "number"
  , f1 = "color"
  , TI = "var"
  , PI = "var("
  , Dx = "${}"
  , CI = /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu;
function qa(e) {
    const t = e.toString()
      , n = []
      , s = {
        color: [],
        number: [],
        var: []
    }
      , o = [];
    let a = 0;
    const c = t.replace(CI, f => (Ut.test(f) ? (s.color.push(a),
    o.push(f1),
    n.push(Ut.parse(f))) : f.startsWith(PI) ? (s.var.push(a),
    o.push(TI),
    n.push(f)) : (s.number.push(a),
    o.push(d1),
    n.push(parseFloat(f))),
    ++a,
    Dx)).split(Dx);
    return {
        values: n,
        split: c,
        indexes: s,
        types: o
    }
}
function h1(e) {
    return qa(e).values
}
function p1(e) {
    const {split: t, types: n} = qa(e)
      , s = t.length;
    return o => {
        let a = "";
        for (let u = 0; u < s; u++)
            if (a += t[u],
            o[u] !== void 0) {
                const c = n[u];
                c === d1 ? a += ya(o[u]) : c === f1 ? a += Ut.transform(o[u]) : a += o[u]
            }
        return a
    }
}
const EI = e => typeof e == "number" ? 0 : e;
function _I(e) {
    const t = h1(e);
    return p1(e)(t.map(EI))
}
const ws = {
    test: SI,
    parse: h1,
    createTransformer: p1,
    getAnimatableNone: _I
}
  , kI = new Set(["brightness", "contrast", "saturate", "opacity"]);
function NI(e) {
    const [t,n] = e.slice(0, -1).split("(");
    if (t === "drop-shadow")
        return e;
    const [s] = n.match(cm) || [];
    if (!s)
        return e;
    const o = n.replace(s, "");
    let a = kI.has(t) ? 1 : 0;
    return s !== n && (a *= 100),
    t + "(" + a + o + ")"
}
const AI = /\b([a-z-]*)\(.*?\)/gu
  , Kh = {
    ...ws,
    getAnimatableNone: e => {
        const t = e.match(AI);
        return t ? t.map(NI).join(" ") : e
    }
}
  , RI = {
    ...Gp,
    color: Ut,
    backgroundColor: Ut,
    outlineColor: Ut,
    fill: Ut,
    stroke: Ut,
    borderColor: Ut,
    borderTopColor: Ut,
    borderRightColor: Ut,
    borderBottomColor: Ut,
    borderLeftColor: Ut,
    filter: Kh,
    WebkitFilter: Kh
}
  , fm = e => RI[e];
function m1(e, t) {
    let n = fm(e);
    return n !== Kh && (n = ws),
    n.getAnimatableNone ? n.getAnimatableNone(t) : void 0
}
const jI = new Set(["auto", "none", "0"]);
function DI(e, t, n) {
    let s = 0, o;
    for (; s < e.length && !o; ) {
        const a = e[s];
        typeof a == "string" && !jI.has(a) && qa(a).values.length && (o = e[s]),
        s++
    }
    if (o && n)
        for (const a of t)
            e[a] = m1(n, o)
}
const Ox = e => e === mo || e === Pe
  , Mx = (e, t) => parseFloat(e.split(", ")[t])
  , Ix = (e, t) => (n, {transform: s}) => {
    if (s === "none" || !s)
        return 0;
    const o = s.match(/^matrix3d\((.+)\)$/u);
    if (o)
        return Mx(o[1], t);
    {
        const a = s.match(/^matrix\((.+)\)$/u);
        return a ? Mx(a[1], e) : 0
    }
}
  , OI = new Set(["x", "y", "z"])
  , MI = po.filter(e => !OI.has(e));
function II(e) {
    const t = [];
    return MI.forEach(n => {
        const s = e.getValue(n);
        s !== void 0 && (t.push([n, s.get()]),
        s.set(n.startsWith("scale") ? 1 : 0))
    }
    ),
    t
}
const oo = {
    width: ({x: e}, {paddingLeft: t="0", paddingRight: n="0"}) => e.max - e.min - parseFloat(t) - parseFloat(n),
    height: ({y: e}, {paddingTop: t="0", paddingBottom: n="0"}) => e.max - e.min - parseFloat(t) - parseFloat(n),
    top: (e, {top: t}) => parseFloat(t),
    left: (e, {left: t}) => parseFloat(t),
    bottom: ({y: e}, {top: t}) => parseFloat(t) + (e.max - e.min),
    right: ({x: e}, {left: t}) => parseFloat(t) + (e.max - e.min),
    x: Ix(4, 13),
    y: Ix(5, 14)
};
oo.translateX = oo.x;
oo.translateY = oo.y;
const Hs = new Set;
let Gh = !1
  , Zh = !1;
function g1() {
    if (Zh) {
        const e = Array.from(Hs).filter(s => s.needsMeasurement)
          , t = new Set(e.map(s => s.element))
          , n = new Map;
        t.forEach(s => {
            const o = II(s);
            o.length && (n.set(s, o),
            s.render())
        }
        ),
        e.forEach(s => s.measureInitialState()),
        t.forEach(s => {
            s.render();
            const o = n.get(s);
            o && o.forEach( ([a,u]) => {
                var c;
                (c = s.getValue(a)) === null || c === void 0 || c.set(u)
            }
            )
        }
        ),
        e.forEach(s => s.measureEndState()),
        e.forEach(s => {
            s.suspendedScrollY !== void 0 && window.scrollTo(0, s.suspendedScrollY)
        }
        )
    }
    Zh = !1,
    Gh = !1,
    Hs.forEach(e => e.complete()),
    Hs.clear()
}
function y1() {
    Hs.forEach(e => {
        e.readKeyframes(),
        e.needsMeasurement && (Zh = !0)
    }
    )
}
function FI() {
    y1(),
    g1()
}
class hm {
    constructor(t, n, s, o, a, u=!1) {
        this.isComplete = !1,
        this.isAsync = !1,
        this.needsMeasurement = !1,
        this.isScheduled = !1,
        this.unresolvedKeyframes = [...t],
        this.onComplete = n,
        this.name = s,
        this.motionValue = o,
        this.element = a,
        this.isAsync = u
    }
    scheduleResolve() {
        this.isScheduled = !0,
        this.isAsync ? (Hs.add(this),
        Gh || (Gh = !0,
        it.read(y1),
        it.resolveKeyframes(g1))) : (this.readKeyframes(),
        this.complete())
    }
    readKeyframes() {
        const {unresolvedKeyframes: t, name: n, element: s, motionValue: o} = this;
        for (let a = 0; a < t.length; a++)
            if (t[a] === null)
                if (a === 0) {
                    const u = o?.get()
                      , c = t[t.length - 1];
                    if (u !== void 0)
                        t[0] = u;
                    else if (s && n) {
                        const f = s.readValue(n, c);
                        f != null && (t[0] = f)
                    }
                    t[0] === void 0 && (t[0] = c),
                    o && u === void 0 && o.set(t[0])
                } else
                    t[a] = t[a - 1]
    }
    setFinalKeyframe() {}
    measureInitialState() {}
    renderEndStyles() {}
    measureEndState() {}
    complete() {
        this.isComplete = !0,
        this.onComplete(this.unresolvedKeyframes, this.finalKeyframe),
        Hs.delete(this)
    }
    cancel() {
        this.isComplete || (this.isScheduled = !1,
        Hs.delete(this))
    }
    resume() {
        this.isComplete || this.scheduleResolve()
    }
}
const v1 = e => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(e)
  , LI = /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u;
function VI(e) {
    const t = LI.exec(e);
    if (!t)
        return [, ];
    const [,n,s,o] = t;
    return [`--${n ?? s}`, o]
}
function x1(e, t, n=1) {
    const [s,o] = VI(e);
    if (!s)
        return;
    const a = window.getComputedStyle(t).getPropertyValue(s);
    if (a) {
        const u = a.trim();
        return v1(u) ? parseFloat(u) : u
    }
    return Kp(o) ? x1(o, t, n + 1) : o
}
const w1 = e => t => t.test(e)
  , BI = {
    test: e => e === "auto",
    parse: e => e
}
  , b1 = [mo, Pe, lr, os, N2, k2, BI]
  , Fx = e => b1.find(w1(e));
class S1 extends hm {
    constructor(t, n, s, o, a) {
        super(t, n, s, o, a, !0)
    }
    readKeyframes() {
        const {unresolvedKeyframes: t, element: n, name: s} = this;
        if (!n || !n.current)
            return;
        super.readKeyframes();
        for (let f = 0; f < t.length; f++) {
            let h = t[f];
            if (typeof h == "string" && (h = h.trim(),
            Kp(h))) {
                const m = x1(h, n.current);
                m !== void 0 && (t[f] = m),
                f === t.length - 1 && (this.finalKeyframe = h)
            }
        }
        if (this.resolveNoneKeyframes(),
        !XS.has(s) || t.length !== 2)
            return;
        const [o,a] = t
          , u = Fx(o)
          , c = Fx(a);
        if (u !== c)
            if (Ox(u) && Ox(c))
                for (let f = 0; f < t.length; f++) {
                    const h = t[f];
                    typeof h == "string" && (t[f] = parseFloat(h))
                }
            else
                this.needsMeasurement = !0
    }
    resolveNoneKeyframes() {
        const {unresolvedKeyframes: t, name: n} = this
          , s = [];
        for (let o = 0; o < t.length; o++)
            gI(t[o]) && s.push(o);
        s.length && DI(t, s, n)
    }
    measureInitialState() {
        const {element: t, unresolvedKeyframes: n, name: s} = this;
        if (!t || !t.current)
            return;
        s === "height" && (this.suspendedScrollY = window.pageYOffset),
        this.measuredOrigin = oo[s](t.measureViewportBox(), window.getComputedStyle(t.current)),
        n[0] = this.measuredOrigin;
        const o = n[n.length - 1];
        o !== void 0 && t.getValue(s, o).jump(o, !1)
    }
    measureEndState() {
        var t;
        const {element: n, name: s, unresolvedKeyframes: o} = this;
        if (!n || !n.current)
            return;
        const a = n.getValue(s);
        a && a.jump(this.measuredOrigin, !1);
        const u = o.length - 1
          , c = o[u];
        o[u] = oo[s](n.measureViewportBox(), window.getComputedStyle(n.current)),
        c !== null && this.finalKeyframe === void 0 && (this.finalKeyframe = c),
        !((t = this.removedTransforms) === null || t === void 0) && t.length && this.removedTransforms.forEach( ([f,h]) => {
            n.getValue(f).set(h)
        }
        ),
        this.resolveNoneKeyframes()
    }
}
const Lx = (e, t) => t === "zIndex" ? !1 : !!(typeof e == "number" || Array.isArray(e) || typeof e == "string" && (ws.test(e) || e === "0") && !e.startsWith("url("));
function zI(e) {
    const t = e[0];
    if (e.length === 1)
        return !0;
    for (let n = 0; n < e.length; n++)
        if (e[n] !== t)
            return !0
}
function UI(e, t, n, s) {
    const o = e[0];
    if (o === null)
        return !1;
    if (t === "display" || t === "visibility")
        return !0;
    const a = e[e.length - 1]
      , u = Lx(o, t)
      , c = Lx(a, t);
    return !u || !c ? !1 : zI(e) || (n === "spring" || nm(n)) && s
}
const $I = e => e !== null;
function Mc(e, {repeat: t, repeatType: n="loop"}, s) {
    const o = e.filter($I)
      , a = t && n !== "loop" && t % 2 === 1 ? 0 : o.length - 1;
    return !a || s === void 0 ? o[a] : s
}
const WI = 40;
class T1 {
    constructor({autoplay: t=!0, delay: n=0, type: s="keyframes", repeat: o=0, repeatDelay: a=0, repeatType: u="loop", ...c}) {
        this.isStopped = !1,
        this.hasAttemptedResolve = !1,
        this.createdAt = ur.now(),
        this.options = {
            autoplay: t,
            delay: n,
            type: s,
            repeat: o,
            repeatDelay: a,
            repeatType: u,
            ...c
        },
        this.updateFinishedPromise()
    }
    calcStartTime() {
        return this.resolvedAt ? this.resolvedAt - this.createdAt > WI ? this.resolvedAt : this.createdAt : this.createdAt
    }
    get resolved() {
        return !this._resolved && !this.hasAttemptedResolve && FI(),
        this._resolved
    }
    onKeyframesResolved(t, n) {
        this.resolvedAt = ur.now(),
        this.hasAttemptedResolve = !0;
        const {name: s, type: o, velocity: a, delay: u, onComplete: c, onUpdate: f, isGenerator: h} = this.options;
        if (!h && !UI(t, s, o, a))
            if (u)
                this.options.duration = 0;
            else {
                f && f(Mc(t, this.options, n)),
                c && c(),
                this.resolveFinishedPromise();
                return
            }
        const m = this.initPlayback(t, n);
        m !== !1 && (this._resolved = {
            keyframes: t,
            finalKeyframe: n,
            ...m
        },
        this.onPostResolved())
    }
    onPostResolved() {}
    then(t, n) {
        return this.currentFinishedPromise.then(t, n)
    }
    flatten() {
        this.options.type = "keyframes",
        this.options.ease = "linear"
    }
    updateFinishedPromise() {
        this.currentFinishedPromise = new Promise(t => {
            this.resolveFinishedPromise = t
        }
        )
    }
}
const dt = (e, t, n) => e + (t - e) * n;
function eh(e, t, n) {
    return n < 0 && (n += 1),
    n > 1 && (n -= 1),
    n < 1 / 6 ? e + (t - e) * 6 * n : n < 1 / 2 ? t : n < 2 / 3 ? e + (t - e) * (2 / 3 - n) * 6 : e
}
function HI({hue: e, saturation: t, lightness: n, alpha: s}) {
    e /= 360,
    t /= 100,
    n /= 100;
    let o = 0
      , a = 0
      , u = 0;
    if (!t)
        o = a = u = n;
    else {
        const c = n < .5 ? n * (1 + t) : n + t - n * t
          , f = 2 * n - c;
        o = eh(f, c, e + 1 / 3),
        a = eh(f, c, e),
        u = eh(f, c, e - 1 / 3)
    }
    return {
        red: Math.round(o * 255),
        green: Math.round(a * 255),
        blue: Math.round(u * 255),
        alpha: s
    }
}
function Ju(e, t) {
    return n => n > 0 ? t : e
}
const th = (e, t, n) => {
    const s = e * e
      , o = n * (t * t - s) + s;
    return o < 0 ? 0 : Math.sqrt(o)
}
  , qI = [Qh, Us, Ui]
  , QI = e => qI.find(t => t.test(e));
function Vx(e) {
    const t = QI(e);
    if (!t)
        return !1;
    let n = t.parse(e);
    return t === Ui && (n = HI(n)),
    n
}
const Bx = (e, t) => {
    const n = Vx(e)
      , s = Vx(t);
    if (!n || !s)
        return Ju(e, t);
    const o = {
        ...n
    };
    return a => (o.red = th(n.red, s.red, a),
    o.green = th(n.green, s.green, a),
    o.blue = th(n.blue, s.blue, a),
    o.alpha = dt(n.alpha, s.alpha, a),
    Us.transform(o))
}
  , KI = (e, t) => n => t(e(n))
  , el = (...e) => e.reduce(KI)
  , Yh = new Set(["none", "hidden"]);
function GI(e, t) {
    return Yh.has(e) ? n => n <= 0 ? e : t : n => n >= 1 ? t : e
}
function ZI(e, t) {
    return n => dt(e, t, n)
}
function pm(e) {
    return typeof e == "number" ? ZI : typeof e == "string" ? Kp(e) ? Ju : Ut.test(e) ? Bx : JI : Array.isArray(e) ? P1 : typeof e == "object" ? Ut.test(e) ? Bx : YI : Ju
}
function P1(e, t) {
    const n = [...e]
      , s = n.length
      , o = e.map( (a, u) => pm(a)(a, t[u]));
    return a => {
        for (let u = 0; u < s; u++)
            n[u] = o[u](a);
        return n
    }
}
function YI(e, t) {
    const n = {
        ...e,
        ...t
    }
      , s = {};
    for (const o in n)
        e[o] !== void 0 && t[o] !== void 0 && (s[o] = pm(e[o])(e[o], t[o]));
    return o => {
        for (const a in s)
            n[a] = s[a](o);
        return n
    }
}
function XI(e, t) {
    var n;
    const s = []
      , o = {
        color: 0,
        var: 0,
        number: 0
    };
    for (let a = 0; a < t.values.length; a++) {
        const u = t.types[a]
          , c = e.indexes[u][o[u]]
          , f = (n = e.values[c]) !== null && n !== void 0 ? n : 0;
        s[a] = f,
        o[u]++
    }
    return s
}
const JI = (e, t) => {
    const n = ws.createTransformer(t)
      , s = qa(e)
      , o = qa(t);
    return s.indexes.var.length === o.indexes.var.length && s.indexes.color.length === o.indexes.color.length && s.indexes.number.length >= o.indexes.number.length ? Yh.has(e) && !o.values.length || Yh.has(t) && !s.values.length ? GI(e, t) : el(P1(XI(s, o), o.values), n) : Ju(e, t)
}
;
function C1(e, t, n) {
    return typeof e == "number" && typeof t == "number" && typeof n == "number" ? dt(e, t, n) : pm(e)(e, t)
}
const eF = 5;
function E1(e, t, n) {
    const s = Math.max(t - eF, 0);
    return JS(n - e(s), t - s)
}
const pt = {
    stiffness: 100,
    damping: 10,
    mass: 1,
    velocity: 0,
    duration: 800,
    bounce: .3,
    visualDuration: .3,
    restSpeed: {
        granular: .01,
        default: 2
    },
    restDelta: {
        granular: .005,
        default: .5
    },
    minDuration: .01,
    maxDuration: 10,
    minDamping: .05,
    maxDamping: 1
}
  , nh = .001;
function tF({duration: e=pt.duration, bounce: t=pt.bounce, velocity: n=pt.velocity, mass: s=pt.mass}) {
    let o, a, u = 1 - t;
    u = Fr(pt.minDamping, pt.maxDamping, u),
    e = Fr(pt.minDuration, pt.maxDuration, Dr(e)),
    u < 1 ? (o = h => {
        const m = h * u
          , v = m * e
          , x = m - n
          , T = Xh(h, u)
          , C = Math.exp(-v);
        return nh - x / T * C
    }
    ,
    a = h => {
        const v = h * u * e
          , x = v * n + n
          , T = Math.pow(u, 2) * Math.pow(h, 2) * e
          , C = Math.exp(-v)
          , S = Xh(Math.pow(h, 2), u);
        return (-o(h) + nh > 0 ? -1 : 1) * ((x - T) * C) / S
    }
    ) : (o = h => {
        const m = Math.exp(-h * e)
          , v = (h - n) * e + 1;
        return -nh + m * v
    }
    ,
    a = h => {
        const m = Math.exp(-h * e)
          , v = (n - h) * (e * e);
        return m * v
    }
    );
    const c = 5 / e
      , f = rF(o, a, c);
    if (e = jr(e),
    isNaN(f))
        return {
            stiffness: pt.stiffness,
            damping: pt.damping,
            duration: e
        };
    {
        const h = Math.pow(f, 2) * s;
        return {
            stiffness: h,
            damping: u * 2 * Math.sqrt(s * h),
            duration: e
        }
    }
}
const nF = 12;
function rF(e, t, n) {
    let s = n;
    for (let o = 1; o < nF; o++)
        s = s - e(s) / t(s);
    return s
}
function Xh(e, t) {
    return e * Math.sqrt(1 - t * t)
}
const sF = ["duration", "bounce"]
  , iF = ["stiffness", "damping", "mass"];
function zx(e, t) {
    return t.some(n => e[n] !== void 0)
}
function oF(e) {
    let t = {
        velocity: pt.velocity,
        stiffness: pt.stiffness,
        damping: pt.damping,
        mass: pt.mass,
        isResolvedFromDuration: !1,
        ...e
    };
    if (!zx(e, iF) && zx(e, sF))
        if (e.visualDuration) {
            const n = e.visualDuration
              , s = 2 * Math.PI / (n * 1.2)
              , o = s * s
              , a = 2 * Fr(.05, 1, 1 - (e.bounce || 0)) * Math.sqrt(o);
            t = {
                ...t,
                mass: pt.mass,
                stiffness: o,
                damping: a
            }
        } else {
            const n = tF(e);
            t = {
                ...t,
                ...n,
                mass: pt.mass
            },
            t.isResolvedFromDuration = !0
        }
    return t
}
function _1(e=pt.visualDuration, t=pt.bounce) {
    const n = typeof e != "object" ? {
        visualDuration: e,
        keyframes: [0, 1],
        bounce: t
    } : e;
    let {restSpeed: s, restDelta: o} = n;
    const a = n.keyframes[0]
      , u = n.keyframes[n.keyframes.length - 1]
      , c = {
        done: !1,
        value: a
    }
      , {stiffness: f, damping: h, mass: m, duration: v, velocity: x, isResolvedFromDuration: T} = oF({
        ...n,
        velocity: -Dr(n.velocity || 0)
    })
      , C = x || 0
      , S = h / (2 * Math.sqrt(f * m))
      , P = u - a
      , _ = Dr(Math.sqrt(f / m))
      , k = Math.abs(P) < 5;
    s || (s = k ? pt.restSpeed.granular : pt.restSpeed.default),
    o || (o = k ? pt.restDelta.granular : pt.restDelta.default);
    let j;
    if (S < 1) {
        const O = Xh(_, S);
        j = z => {
            const U = Math.exp(-S * _ * z);
            return u - U * ((C + S * _ * P) / O * Math.sin(O * z) + P * Math.cos(O * z))
        }
    } else if (S === 1)
        j = O => u - Math.exp(-_ * O) * (P + (C + _ * P) * O);
    else {
        const O = _ * Math.sqrt(S * S - 1);
        j = z => {
            const U = Math.exp(-S * _ * z)
              , W = Math.min(O * z, 300);
            return u - U * ((C + S * _ * P) * Math.sinh(W) + O * P * Math.cosh(W)) / O
        }
    }
    const M = {
        calculatedDuration: T && v || null,
        next: O => {
            const z = j(O);
            if (T)
                c.done = O >= v;
            else {
                let U = 0;
                S < 1 && (U = O === 0 ? jr(C) : E1(j, O, z));
                const W = Math.abs(U) <= s
                  , oe = Math.abs(u - z) <= o;
                c.done = W && oe
            }
            return c.value = c.done ? u : z,
            c
        }
        ,
        toString: () => {
            const O = Math.min(HS(M), Wh)
              , z = qS(U => M.next(O * U).value, O, 30);
            return O + "ms " + z
        }
    };
    return M
}
function Ux({keyframes: e, velocity: t=0, power: n=.8, timeConstant: s=325, bounceDamping: o=10, bounceStiffness: a=500, modifyTarget: u, min: c, max: f, restDelta: h=.5, restSpeed: m}) {
    const v = e[0]
      , x = {
        done: !1,
        value: v
    }
      , T = W => c !== void 0 && W < c || f !== void 0 && W > f
      , C = W => c === void 0 ? f : f === void 0 || Math.abs(c - W) < Math.abs(f - W) ? c : f;
    let S = n * t;
    const P = v + S
      , _ = u === void 0 ? P : u(P);
    _ !== P && (S = _ - v);
    const k = W => -S * Math.exp(-W / s)
      , j = W => _ + k(W)
      , M = W => {
        const oe = k(W)
          , fe = j(W);
        x.done = Math.abs(oe) <= h,
        x.value = x.done ? _ : fe
    }
    ;
    let O, z;
    const U = W => {
        T(x.value) && (O = W,
        z = _1({
            keyframes: [x.value, C(x.value)],
            velocity: E1(j, W, x.value),
            damping: o,
            stiffness: a,
            restDelta: h,
            restSpeed: m
        }))
    }
    ;
    return U(0),
    {
        calculatedDuration: null,
        next: W => {
            let oe = !1;
            return !z && O === void 0 && (oe = !0,
            M(W),
            U(W)),
            O !== void 0 && W >= O ? z.next(W - O) : (!oe && M(W),
            x)
        }
    }
}
const aF = Ja(.42, 0, 1, 1)
  , lF = Ja(0, 0, .58, 1)
  , k1 = Ja(.42, 0, .58, 1)
  , uF = e => Array.isArray(e) && typeof e[0] != "number"
  , cF = {
    linear: gn,
    easeIn: aF,
    easeInOut: k1,
    easeOut: lF,
    circIn: um,
    circInOut: l1,
    circOut: a1,
    backIn: lm,
    backInOut: i1,
    backOut: s1,
    anticipate: o1
}
  , $x = e => {
    if (rm(e)) {
        CS(e.length === 4);
        const [t,n,s,o] = e;
        return Ja(t, n, s, o)
    } else if (typeof e == "string")
        return cF[e];
    return e
}
;
function dF(e, t, n) {
    const s = []
      , o = n || C1
      , a = e.length - 1;
    for (let u = 0; u < a; u++) {
        let c = o(e[u], e[u + 1]);
        if (t) {
            const f = Array.isArray(t) ? t[u] || gn : t;
            c = el(f, c)
        }
        s.push(c)
    }
    return s
}
function fF(e, t, {clamp: n=!0, ease: s, mixer: o}={}) {
    const a = e.length;
    if (CS(a === t.length),
    a === 1)
        return () => t[0];
    if (a === 2 && t[0] === t[1])
        return () => t[1];
    const u = e[0] === e[1];
    e[0] > e[a - 1] && (e = [...e].reverse(),
    t = [...t].reverse());
    const c = dF(t, s, o)
      , f = c.length
      , h = m => {
        if (u && m < e[0])
            return t[0];
        let v = 0;
        if (f > 1)
            for (; v < e.length - 2 && !(m < e[v + 1]); v++)
                ;
        const x = so(e[v], e[v + 1], m);
        return c[v](x)
    }
    ;
    return n ? m => h(Fr(e[0], e[a - 1], m)) : h
}
function hF(e, t) {
    const n = e[e.length - 1];
    for (let s = 1; s <= t; s++) {
        const o = so(0, t, s);
        e.push(dt(n, 1, o))
    }
}
function pF(e) {
    const t = [0];
    return hF(t, e.length - 1),
    t
}
function mF(e, t) {
    return e.map(n => n * t)
}
function gF(e, t) {
    return e.map( () => t || k1).splice(0, e.length - 1)
}
function ec({duration: e=300, keyframes: t, times: n, ease: s="easeInOut"}) {
    const o = uF(s) ? s.map($x) : $x(s)
      , a = {
        done: !1,
        value: t[0]
    }
      , u = mF(n && n.length === t.length ? n : pF(t), e)
      , c = fF(u, t, {
        ease: Array.isArray(o) ? o : gF(t, o)
    });
    return {
        calculatedDuration: e,
        next: f => (a.value = c(f),
        a.done = f >= e,
        a)
    }
}
const yF = e => {
    const t = ({timestamp: n}) => e(n);
    return {
        start: () => it.update(t, !0),
        stop: () => xs(t),
        now: () => Ft.isProcessing ? Ft.timestamp : ur.now()
    }
}
  , vF = {
    decay: Ux,
    inertia: Ux,
    tween: ec,
    keyframes: ec,
    spring: _1
}
  , xF = e => e / 100;
class mm extends T1 {
    constructor(t) {
        super(t),
        this.holdTime = null,
        this.cancelTime = null,
        this.currentTime = 0,
        this.playbackSpeed = 1,
        this.pendingPlayState = "running",
        this.startTime = null,
        this.state = "idle",
        this.stop = () => {
            if (this.resolver.cancel(),
            this.isStopped = !0,
            this.state === "idle")
                return;
            this.teardown();
            const {onStop: f} = this.options;
            f && f()
        }
        ;
        const {name: n, motionValue: s, element: o, keyframes: a} = this.options
          , u = o?.KeyframeResolver || hm
          , c = (f, h) => this.onKeyframesResolved(f, h);
        this.resolver = new u(a,c,n,s,o),
        this.resolver.scheduleResolve()
    }
    flatten() {
        super.flatten(),
        this._resolved && Object.assign(this._resolved, this.initPlayback(this._resolved.keyframes))
    }
    initPlayback(t) {
        const {type: n="keyframes", repeat: s=0, repeatDelay: o=0, repeatType: a, velocity: u=0} = this.options
          , c = nm(n) ? n : vF[n] || ec;
        let f, h;
        c !== ec && typeof t[0] != "number" && (f = el(xF, C1(t[0], t[1])),
        t = [0, 100]);
        const m = c({
            ...this.options,
            keyframes: t
        });
        a === "mirror" && (h = c({
            ...this.options,
            keyframes: [...t].reverse(),
            velocity: -u
        })),
        m.calculatedDuration === null && (m.calculatedDuration = HS(m));
        const {calculatedDuration: v} = m
          , x = v + o
          , T = x * (s + 1) - o;
        return {
            generator: m,
            mirroredGenerator: h,
            mapPercentToKeyframes: f,
            calculatedDuration: v,
            resolvedDuration: x,
            totalDuration: T
        }
    }
    onPostResolved() {
        const {autoplay: t=!0} = this.options;
        this.play(),
        this.pendingPlayState === "paused" || !t ? this.pause() : this.state = this.pendingPlayState
    }
    tick(t, n=!1) {
        const {resolved: s} = this;
        if (!s) {
            const {keyframes: W} = this.options;
            return {
                done: !0,
                value: W[W.length - 1]
            }
        }
        const {finalKeyframe: o, generator: a, mirroredGenerator: u, mapPercentToKeyframes: c, keyframes: f, calculatedDuration: h, totalDuration: m, resolvedDuration: v} = s;
        if (this.startTime === null)
            return a.next(0);
        const {delay: x, repeat: T, repeatType: C, repeatDelay: S, onUpdate: P} = this.options;
        this.speed > 0 ? this.startTime = Math.min(this.startTime, t) : this.speed < 0 && (this.startTime = Math.min(t - m / this.speed, this.startTime)),
        n ? this.currentTime = t : this.holdTime !== null ? this.currentTime = this.holdTime : this.currentTime = Math.round(t - this.startTime) * this.speed;
        const _ = this.currentTime - x * (this.speed >= 0 ? 1 : -1)
          , k = this.speed >= 0 ? _ < 0 : _ > m;
        this.currentTime = Math.max(_, 0),
        this.state === "finished" && this.holdTime === null && (this.currentTime = m);
        let j = this.currentTime
          , M = a;
        if (T) {
            const W = Math.min(this.currentTime, m) / v;
            let oe = Math.floor(W)
              , fe = W % 1;
            !fe && W >= 1 && (fe = 1),
            fe === 1 && oe--,
            oe = Math.min(oe, T + 1),
            oe % 2 && (C === "reverse" ? (fe = 1 - fe,
            S && (fe -= S / v)) : C === "mirror" && (M = u)),
            j = Fr(0, 1, fe) * v
        }
        const O = k ? {
            done: !1,
            value: f[0]
        } : M.next(j);
        c && (O.value = c(O.value));
        let {done: z} = O;
        !k && h !== null && (z = this.speed >= 0 ? this.currentTime >= m : this.currentTime <= 0);
        const U = this.holdTime === null && (this.state === "finished" || this.state === "running" && z);
        return U && o !== void 0 && (O.value = Mc(f, this.options, o)),
        P && P(O.value),
        U && this.finish(),
        O
    }
    get duration() {
        const {resolved: t} = this;
        return t ? Dr(t.calculatedDuration) : 0
    }
    get time() {
        return Dr(this.currentTime)
    }
    set time(t) {
        t = jr(t),
        this.currentTime = t,
        this.holdTime !== null || this.speed === 0 ? this.holdTime = t : this.driver && (this.startTime = this.driver.now() - t / this.speed)
    }
    get speed() {
        return this.playbackSpeed
    }
    set speed(t) {
        const n = this.playbackSpeed !== t;
        this.playbackSpeed = t,
        n && (this.time = Dr(this.currentTime))
    }
    play() {
        if (this.resolver.isScheduled || this.resolver.resume(),
        !this._resolved) {
            this.pendingPlayState = "running";
            return
        }
        if (this.isStopped)
            return;
        const {driver: t=yF, onPlay: n, startTime: s} = this.options;
        this.driver || (this.driver = t(a => this.tick(a))),
        n && n();
        const o = this.driver.now();
        this.holdTime !== null ? this.startTime = o - this.holdTime : this.startTime ? this.state === "finished" && (this.startTime = o) : this.startTime = s ?? this.calcStartTime(),
        this.state === "finished" && this.updateFinishedPromise(),
        this.cancelTime = this.startTime,
        this.holdTime = null,
        this.state = "running",
        this.driver.start()
    }
    pause() {
        var t;
        if (!this._resolved) {
            this.pendingPlayState = "paused";
            return
        }
        this.state = "paused",
        this.holdTime = (t = this.currentTime) !== null && t !== void 0 ? t : 0
    }
    complete() {
        this.state !== "running" && this.play(),
        this.pendingPlayState = this.state = "finished",
        this.holdTime = null
    }
    finish() {
        this.teardown(),
        this.state = "finished";
        const {onComplete: t} = this.options;
        t && t()
    }
    cancel() {
        this.cancelTime !== null && this.tick(this.cancelTime),
        this.teardown(),
        this.updateFinishedPromise()
    }
    teardown() {
        this.state = "idle",
        this.stopDriver(),
        this.resolveFinishedPromise(),
        this.updateFinishedPromise(),
        this.startTime = this.cancelTime = null,
        this.resolver.cancel()
    }
    stopDriver() {
        this.driver && (this.driver.stop(),
        this.driver = void 0)
    }
    sample(t) {
        return this.startTime = 0,
        this.tick(t, !0)
    }
}
const wF = new Set(["opacity", "clipPath", "filter", "transform"]);
function bF(e, t, n, {delay: s=0, duration: o=300, repeat: a=0, repeatType: u="loop", ease: c="easeInOut", times: f}={}) {
    const h = {
        [t]: n
    };
    f && (h.offset = f);
    const m = KS(c, o);
    return Array.isArray(m) && (h.easing = m),
    e.animate(h, {
        delay: s,
        duration: o,
        easing: Array.isArray(m) ? "linear" : m,
        fill: "both",
        iterations: a + 1,
        direction: u === "reverse" ? "alternate" : "normal"
    })
}
const SF = zp( () => Object.hasOwnProperty.call(Element.prototype, "animate"))
  , tc = 10
  , TF = 2e4;
function PF(e) {
    return nm(e.type) || e.type === "spring" || !QS(e.ease)
}
function CF(e, t) {
    const n = new mm({
        ...t,
        keyframes: e,
        repeat: 0,
        delay: 0,
        isGenerator: !0
    });
    let s = {
        done: !1,
        value: e[0]
    };
    const o = [];
    let a = 0;
    for (; !s.done && a < TF; )
        s = n.sample(a),
        o.push(s.value),
        a += tc;
    return {
        times: void 0,
        keyframes: o,
        duration: a - tc,
        ease: "linear"
    }
}
const N1 = {
    anticipate: o1,
    backInOut: i1,
    circInOut: l1
};
function EF(e) {
    return e in N1
}
class Wx extends T1 {
    constructor(t) {
        super(t);
        const {name: n, motionValue: s, element: o, keyframes: a} = this.options;
        this.resolver = new S1(a, (u, c) => this.onKeyframesResolved(u, c),n,s,o),
        this.resolver.scheduleResolve()
    }
    initPlayback(t, n) {
        let {duration: s=300, times: o, ease: a, type: u, motionValue: c, name: f, startTime: h} = this.options;
        if (!c.owner || !c.owner.current)
            return !1;
        if (typeof a == "string" && Xu() && EF(a) && (a = N1[a]),
        PF(this.options)) {
            const {onComplete: v, onUpdate: x, motionValue: T, element: C, ...S} = this.options
              , P = CF(t, S);
            t = P.keyframes,
            t.length === 1 && (t[1] = t[0]),
            s = P.duration,
            o = P.times,
            a = P.ease,
            u = "keyframes"
        }
        const m = bF(c.owner.current, f, t, {
            ...this.options,
            duration: s,
            times: o,
            ease: a
        });
        return m.startTime = h ?? this.calcStartTime(),
        this.pendingTimeline ? (kx(m, this.pendingTimeline),
        this.pendingTimeline = void 0) : m.onfinish = () => {
            const {onComplete: v} = this.options;
            c.set(Mc(t, this.options, n)),
            v && v(),
            this.cancel(),
            this.resolveFinishedPromise()
        }
        ,
        {
            animation: m,
            duration: s,
            times: o,
            type: u,
            ease: a,
            keyframes: t
        }
    }
    get duration() {
        const {resolved: t} = this;
        if (!t)
            return 0;
        const {duration: n} = t;
        return Dr(n)
    }
    get time() {
        const {resolved: t} = this;
        if (!t)
            return 0;
        const {animation: n} = t;
        return Dr(n.currentTime || 0)
    }
    set time(t) {
        const {resolved: n} = this;
        if (!n)
            return;
        const {animation: s} = n;
        s.currentTime = jr(t)
    }
    get speed() {
        const {resolved: t} = this;
        if (!t)
            return 1;
        const {animation: n} = t;
        return n.playbackRate
    }
    set speed(t) {
        const {resolved: n} = this;
        if (!n)
            return;
        const {animation: s} = n;
        s.playbackRate = t
    }
    get state() {
        const {resolved: t} = this;
        if (!t)
            return "idle";
        const {animation: n} = t;
        return n.playState
    }
    get startTime() {
        const {resolved: t} = this;
        if (!t)
            return null;
        const {animation: n} = t;
        return n.startTime
    }
    attachTimeline(t) {
        if (!this._resolved)
            this.pendingTimeline = t;
        else {
            const {resolved: n} = this;
            if (!n)
                return gn;
            const {animation: s} = n;
            kx(s, t)
        }
        return gn
    }
    play() {
        if (this.isStopped)
            return;
        const {resolved: t} = this;
        if (!t)
            return;
        const {animation: n} = t;
        n.playState === "finished" && this.updateFinishedPromise(),
        n.play()
    }
    pause() {
        const {resolved: t} = this;
        if (!t)
            return;
        const {animation: n} = t;
        n.pause()
    }
    stop() {
        if (this.resolver.cancel(),
        this.isStopped = !0,
        this.state === "idle")
            return;
        this.resolveFinishedPromise(),
        this.updateFinishedPromise();
        const {resolved: t} = this;
        if (!t)
            return;
        const {animation: n, keyframes: s, duration: o, type: a, ease: u, times: c} = t;
        if (n.playState === "idle" || n.playState === "finished")
            return;
        if (this.time) {
            const {motionValue: h, onUpdate: m, onComplete: v, element: x, ...T} = this.options
              , C = new mm({
                ...T,
                keyframes: s,
                duration: o,
                type: a,
                ease: u,
                times: c,
                isGenerator: !0
            })
              , S = jr(this.time);
            h.setWithVelocity(C.sample(S - tc).value, C.sample(S).value, tc)
        }
        const {onStop: f} = this.options;
        f && f(),
        this.cancel()
    }
    complete() {
        const {resolved: t} = this;
        t && t.animation.finish()
    }
    cancel() {
        const {resolved: t} = this;
        t && t.animation.cancel()
    }
    static supports(t) {
        const {motionValue: n, name: s, repeatDelay: o, repeatType: a, damping: u, type: c} = t;
        if (!n || !n.owner || !(n.owner.current instanceof HTMLElement))
            return !1;
        const {onUpdate: f, transformTemplate: h} = n.owner.getProps();
        return SF() && s && wF.has(s) && !f && !h && !o && a !== "mirror" && u !== 0 && c !== "inertia"
    }
}
const _F = {
    type: "spring",
    stiffness: 500,
    damping: 25,
    restSpeed: 10
}
  , kF = e => ({
    type: "spring",
    stiffness: 550,
    damping: e === 0 ? 2 * Math.sqrt(550) : 30,
    restSpeed: 10
})
  , NF = {
    type: "keyframes",
    duration: .8
}
  , AF = {
    type: "keyframes",
    ease: [.25, .1, .35, 1],
    duration: .3
}
  , RF = (e, {keyframes: t}) => t.length > 2 ? NF : ni.has(e) ? e.startsWith("scale") ? kF(t[1]) : _F : AF;
function jF({when: e, delay: t, delayChildren: n, staggerChildren: s, staggerDirection: o, repeat: a, repeatType: u, repeatDelay: c, from: f, elapsed: h, ...m}) {
    return !!Object.keys(m).length
}
const gm = (e, t, n, s={}, o, a) => u => {
    const c = tm(s, e) || {}
      , f = c.delay || s.delay || 0;
    let {elapsed: h=0} = s;
    h = h - jr(f);
    let m = {
        keyframes: Array.isArray(n) ? n : [null, n],
        ease: "easeOut",
        velocity: t.getVelocity(),
        ...c,
        delay: -h,
        onUpdate: x => {
            t.set(x),
            c.onUpdate && c.onUpdate(x)
        }
        ,
        onComplete: () => {
            u(),
            c.onComplete && c.onComplete()
        }
        ,
        name: e,
        motionValue: t,
        element: a ? void 0 : o
    };
    jF(c) || (m = {
        ...m,
        ...RF(e, m)
    }),
    m.duration && (m.duration = jr(m.duration)),
    m.repeatDelay && (m.repeatDelay = jr(m.repeatDelay)),
    m.from !== void 0 && (m.keyframes[0] = m.from);
    let v = !1;
    if ((m.type === !1 || m.duration === 0 && !m.repeatDelay) && (m.duration = 0,
    m.delay === 0 && (v = !0)),
    v && !a && t.get() !== void 0) {
        const x = Mc(m.keyframes, c);
        if (x !== void 0)
            return it.update( () => {
                m.onUpdate(x),
                m.onComplete()
            }
            ),
            new Y2([])
    }
    return !a && Wx.supports(m) ? new Wx(m) : new mm(m)
}
;
function DF({protectedKeys: e, needsAnimating: t}, n) {
    const s = e.hasOwnProperty(n) && t[n] !== !0;
    return t[n] = !1,
    s
}
function A1(e, t, {delay: n=0, transitionOverride: s, type: o}={}) {
    var a;
    let {transition: u=e.getDefaultTransition(), transitionEnd: c, ...f} = t;
    s && (u = s);
    const h = []
      , m = o && e.animationState && e.animationState.getState()[o];
    for (const v in f) {
        const x = e.getValue(v, (a = e.latestValues[v]) !== null && a !== void 0 ? a : null)
          , T = f[v];
        if (T === void 0 || m && DF(m, v))
            continue;
        const C = {
            delay: n,
            ...tm(u || {}, v)
        };
        let S = !1;
        if (window.MotionHandoffAnimation) {
            const _ = e1(e);
            if (_) {
                const k = window.MotionHandoffAnimation(_, v, it);
                k !== null && (C.startTime = k,
                S = !0)
            }
        }
        qh(e, v),
        x.start(gm(v, x, T, e.shouldReduceMotion && XS.has(v) ? {
            type: !1
        } : C, e, S));
        const P = x.animation;
        P && h.push(P)
    }
    return c && Promise.all(h).then( () => {
        it.update( () => {
            c && dI(e, c)
        }
        )
    }
    ),
    h
}
function Jh(e, t, n={}) {
    var s;
    const o = Oc(e, t, n.type === "exit" ? (s = e.presenceContext) === null || s === void 0 ? void 0 : s.custom : void 0);
    let {transition: a=e.getDefaultTransition() || {}} = o || {};
    n.transitionOverride && (a = n.transitionOverride);
    const u = o ? () => Promise.all(A1(e, o, n)) : () => Promise.resolve()
      , c = e.variantChildren && e.variantChildren.size ? (h=0) => {
        const {delayChildren: m=0, staggerChildren: v, staggerDirection: x} = a;
        return OF(e, t, m + h, v, x, n)
    }
    : () => Promise.resolve()
      , {when: f} = a;
    if (f) {
        const [h,m] = f === "beforeChildren" ? [u, c] : [c, u];
        return h().then( () => m())
    } else
        return Promise.all([u(), c(n.delay)])
}
function OF(e, t, n=0, s=0, o=1, a) {
    const u = []
      , c = (e.variantChildren.size - 1) * s
      , f = o === 1 ? (h=0) => h * s : (h=0) => c - h * s;
    return Array.from(e.variantChildren).sort(MF).forEach( (h, m) => {
        h.notify("AnimationStart", t),
        u.push(Jh(h, t, {
            ...a,
            delay: n + f(m)
        }).then( () => h.notify("AnimationComplete", t)))
    }
    ),
    Promise.all(u)
}
function MF(e, t) {
    return e.sortNodePosition(t)
}
function IF(e, t, n={}) {
    e.notify("AnimationStart", t);
    let s;
    if (Array.isArray(t)) {
        const o = t.map(a => Jh(e, a, n));
        s = Promise.all(o)
    } else if (typeof t == "string")
        s = Jh(e, t, n);
    else {
        const o = typeof t == "function" ? Oc(e, t, n.custom) : t;
        s = Promise.all(A1(e, o, n))
    }
    return s.then( () => {
        e.notify("AnimationComplete", t)
    }
    )
}
const FF = $p.length;
function R1(e) {
    if (!e)
        return;
    if (!e.isControllingVariants) {
        const n = e.parent ? R1(e.parent) || {} : {};
        return e.props.initial !== void 0 && (n.initial = e.props.initial),
        n
    }
    const t = {};
    for (let n = 0; n < FF; n++) {
        const s = $p[n]
          , o = e.props[s];
        ($a(o) || o === !1) && (t[s] = o)
    }
    return t
}
const LF = [...Up].reverse()
  , VF = Up.length;
function BF(e) {
    return t => Promise.all(t.map( ({animation: n, options: s}) => IF(e, n, s)))
}
function zF(e) {
    let t = BF(e)
      , n = Hx()
      , s = !0;
    const o = f => (h, m) => {
        var v;
        const x = Oc(e, m, f === "exit" ? (v = e.presenceContext) === null || v === void 0 ? void 0 : v.custom : void 0);
        if (x) {
            const {transition: T, transitionEnd: C, ...S} = x;
            h = {
                ...h,
                ...S,
                ...C
            }
        }
        return h
    }
    ;
    function a(f) {
        t = f(e)
    }
    function u(f) {
        const {props: h} = e
          , m = R1(e.parent) || {}
          , v = []
          , x = new Set;
        let T = {}
          , C = 1 / 0;
        for (let P = 0; P < VF; P++) {
            const _ = LF[P]
              , k = n[_]
              , j = h[_] !== void 0 ? h[_] : m[_]
              , M = $a(j)
              , O = _ === f ? k.isActive : null;
            O === !1 && (C = P);
            let z = j === m[_] && j !== h[_] && M;
            if (z && s && e.manuallyAnimateOnMount && (z = !1),
            k.protectedKeys = {
                ...T
            },
            !k.isActive && O === null || !j && !k.prevProp || jc(j) || typeof j == "boolean")
                continue;
            const U = UF(k.prevProp, j);
            let W = U || _ === f && k.isActive && !z && M || P > C && M
              , oe = !1;
            const fe = Array.isArray(j) ? j : [j];
            let we = fe.reduce(o(_), {});
            O === !1 && (we = {});
            const {prevResolvedValues: X={}} = k
              , se = {
                ...X,
                ...we
            }
              , G = ie => {
                W = !0,
                x.has(ie) && (oe = !0,
                x.delete(ie)),
                k.needsAnimating[ie] = !0;
                const B = e.getValue(ie);
                B && (B.liveStyle = !1)
            }
            ;
            for (const ie in se) {
                const B = we[ie]
                  , ne = X[ie];
                if (T.hasOwnProperty(ie))
                    continue;
                let J = !1;
                $h(B) && $h(ne) ? J = !WS(B, ne) : J = B !== ne,
                J ? B != null ? G(ie) : x.add(ie) : B !== void 0 && x.has(ie) ? G(ie) : k.protectedKeys[ie] = !0
            }
            k.prevProp = j,
            k.prevResolvedValues = we,
            k.isActive && (T = {
                ...T,
                ...we
            }),
            s && e.blockInitialAnimation && (W = !1),
            W && (!(z && U) || oe) && v.push(...fe.map(ie => ({
                animation: ie,
                options: {
                    type: _
                }
            })))
        }
        if (x.size) {
            const P = {};
            x.forEach(_ => {
                const k = e.getBaseTarget(_)
                  , j = e.getValue(_);
                j && (j.liveStyle = !0),
                P[_] = k ?? null
            }
            ),
            v.push({
                animation: P
            })
        }
        let S = !!v.length;
        return s && (h.initial === !1 || h.initial === h.animate) && !e.manuallyAnimateOnMount && (S = !1),
        s = !1,
        S ? t(v) : Promise.resolve()
    }
    function c(f, h) {
        var m;
        if (n[f].isActive === h)
            return Promise.resolve();
        (m = e.variantChildren) === null || m === void 0 || m.forEach(x => {
            var T;
            return (T = x.animationState) === null || T === void 0 ? void 0 : T.setActive(f, h)
        }
        ),
        n[f].isActive = h;
        const v = u(f);
        for (const x in n)
            n[x].protectedKeys = {};
        return v
    }
    return {
        animateChanges: u,
        setActive: c,
        setAnimateFunction: a,
        getState: () => n,
        reset: () => {
            n = Hx(),
            s = !0
        }
    }
}
function UF(e, t) {
    return typeof t == "string" ? t !== e : Array.isArray(t) ? !WS(t, e) : !1
}
function Fs(e=!1) {
    return {
        isActive: e,
        protectedKeys: {},
        needsAnimating: {},
        prevResolvedValues: {}
    }
}
function Hx() {
    return {
        animate: Fs(!0),
        whileInView: Fs(),
        whileHover: Fs(),
        whileTap: Fs(),
        whileDrag: Fs(),
        whileFocus: Fs(),
        exit: Fs()
    }
}
class bs {
    constructor(t) {
        this.isMounted = !1,
        this.node = t
    }
    update() {}
}
class $F extends bs {
    constructor(t) {
        super(t),
        t.animationState || (t.animationState = zF(t))
    }
    updateAnimationControlsSubscription() {
        const {animate: t} = this.node.getProps();
        jc(t) && (this.unmountControls = t.subscribe(this.node))
    }
    mount() {
        this.updateAnimationControlsSubscription()
    }
    update() {
        const {animate: t} = this.node.getProps()
          , {animate: n} = this.node.prevProps || {};
        t !== n && this.updateAnimationControlsSubscription()
    }
    unmount() {
        var t;
        this.node.animationState.reset(),
        (t = this.unmountControls) === null || t === void 0 || t.call(this)
    }
}
let WF = 0;
class HF extends bs {
    constructor() {
        super(...arguments),
        this.id = WF++
    }
    update() {
        if (!this.node.presenceContext)
            return;
        const {isPresent: t, onExitComplete: n} = this.node.presenceContext
          , {isPresent: s} = this.node.prevPresenceContext || {};
        if (!this.node.animationState || t === s)
            return;
        const o = this.node.animationState.setActive("exit", !t);
        n && !t && o.then( () => n(this.id))
    }
    mount() {
        const {register: t} = this.node.presenceContext || {};
        t && (this.unmount = t(this.id))
    }
    unmount() {}
}
const qF = {
    animation: {
        Feature: $F
    },
    exit: {
        Feature: HF
    }
};
function Qa(e, t, n, s={
    passive: !0
}) {
    return e.addEventListener(t, n, s),
    () => e.removeEventListener(t, n)
}
function tl(e) {
    return {
        point: {
            x: e.pageX,
            y: e.pageY
        }
    }
}
const QF = e => t => sm(t) && e(t, tl(t));
function va(e, t, n, s) {
    return Qa(e, t, QF(n), s)
}
const qx = (e, t) => Math.abs(e - t);
function KF(e, t) {
    const n = qx(e.x, t.x)
      , s = qx(e.y, t.y);
    return Math.sqrt(n ** 2 + s ** 2)
}
class j1 {
    constructor(t, n, {transformPagePoint: s, contextWindow: o, dragSnapToOrigin: a=!1}={}) {
        if (this.startEvent = null,
        this.lastMoveEvent = null,
        this.lastMoveEventInfo = null,
        this.handlers = {},
        this.contextWindow = window,
        this.updatePoint = () => {
            if (!(this.lastMoveEvent && this.lastMoveEventInfo))
                return;
            const v = sh(this.lastMoveEventInfo, this.history)
              , x = this.startEvent !== null
              , T = KF(v.offset, {
                x: 0,
                y: 0
            }) >= 3;
            if (!x && !T)
                return;
            const {point: C} = v
              , {timestamp: S} = Ft;
            this.history.push({
                ...C,
                timestamp: S
            });
            const {onStart: P, onMove: _} = this.handlers;
            x || (P && P(this.lastMoveEvent, v),
            this.startEvent = this.lastMoveEvent),
            _ && _(this.lastMoveEvent, v)
        }
        ,
        this.handlePointerMove = (v, x) => {
            this.lastMoveEvent = v,
            this.lastMoveEventInfo = rh(x, this.transformPagePoint),
            it.update(this.updatePoint, !0)
        }
        ,
        this.handlePointerUp = (v, x) => {
            this.end();
            const {onEnd: T, onSessionEnd: C, resumeAnimation: S} = this.handlers;
            if (this.dragSnapToOrigin && S && S(),
            !(this.lastMoveEvent && this.lastMoveEventInfo))
                return;
            const P = sh(v.type === "pointercancel" ? this.lastMoveEventInfo : rh(x, this.transformPagePoint), this.history);
            this.startEvent && T && T(v, P),
            C && C(v, P)
        }
        ,
        !sm(t))
            return;
        this.dragSnapToOrigin = a,
        this.handlers = n,
        this.transformPagePoint = s,
        this.contextWindow = o || window;
        const u = tl(t)
          , c = rh(u, this.transformPagePoint)
          , {point: f} = c
          , {timestamp: h} = Ft;
        this.history = [{
            ...f,
            timestamp: h
        }];
        const {onSessionStart: m} = n;
        m && m(t, sh(c, this.history)),
        this.removeListeners = el(va(this.contextWindow, "pointermove", this.handlePointerMove), va(this.contextWindow, "pointerup", this.handlePointerUp), va(this.contextWindow, "pointercancel", this.handlePointerUp))
    }
    updateHandlers(t) {
        this.handlers = t
    }
    end() {
        this.removeListeners && this.removeListeners(),
        xs(this.updatePoint)
    }
}
function rh(e, t) {
    return t ? {
        point: t(e.point)
    } : e
}
function Qx(e, t) {
    return {
        x: e.x - t.x,
        y: e.y - t.y
    }
}
function sh({point: e}, t) {
    return {
        point: e,
        delta: Qx(e, D1(t)),
        offset: Qx(e, GF(t)),
        velocity: ZF(t, .1)
    }
}
function GF(e) {
    return e[0]
}
function D1(e) {
    return e[e.length - 1]
}
function ZF(e, t) {
    if (e.length < 2)
        return {
            x: 0,
            y: 0
        };
    let n = e.length - 1
      , s = null;
    const o = D1(e);
    for (; n >= 0 && (s = e[n],
    !(o.timestamp - s.timestamp > jr(t))); )
        n--;
    if (!s)
        return {
            x: 0,
            y: 0
        };
    const a = Dr(o.timestamp - s.timestamp);
    if (a === 0)
        return {
            x: 0,
            y: 0
        };
    const u = {
        x: (o.x - s.x) / a,
        y: (o.y - s.y) / a
    };
    return u.x === 1 / 0 && (u.x = 0),
    u.y === 1 / 0 && (u.y = 0),
    u
}
const O1 = 1e-4
  , YF = 1 - O1
  , XF = 1 + O1
  , M1 = .01
  , JF = 0 - M1
  , eL = 0 + M1;
function vn(e) {
    return e.max - e.min
}
function tL(e, t, n) {
    return Math.abs(e - t) <= n
}
function Kx(e, t, n, s=.5) {
    e.origin = s,
    e.originPoint = dt(t.min, t.max, e.origin),
    e.scale = vn(n) / vn(t),
    e.translate = dt(n.min, n.max, e.origin) - e.originPoint,
    (e.scale >= YF && e.scale <= XF || isNaN(e.scale)) && (e.scale = 1),
    (e.translate >= JF && e.translate <= eL || isNaN(e.translate)) && (e.translate = 0)
}
function xa(e, t, n, s) {
    Kx(e.x, t.x, n.x, s ? s.originX : void 0),
    Kx(e.y, t.y, n.y, s ? s.originY : void 0)
}
function Gx(e, t, n) {
    e.min = n.min + t.min,
    e.max = e.min + vn(t)
}
function nL(e, t, n) {
    Gx(e.x, t.x, n.x),
    Gx(e.y, t.y, n.y)
}
function Zx(e, t, n) {
    e.min = t.min - n.min,
    e.max = e.min + vn(t)
}
function wa(e, t, n) {
    Zx(e.x, t.x, n.x),
    Zx(e.y, t.y, n.y)
}
function rL(e, {min: t, max: n}, s) {
    return t !== void 0 && e < t ? e = s ? dt(t, e, s.min) : Math.max(e, t) : n !== void 0 && e > n && (e = s ? dt(n, e, s.max) : Math.min(e, n)),
    e
}
function Yx(e, t, n) {
    return {
        min: t !== void 0 ? e.min + t : void 0,
        max: n !== void 0 ? e.max + n - (e.max - e.min) : void 0
    }
}
function sL(e, {top: t, left: n, bottom: s, right: o}) {
    return {
        x: Yx(e.x, n, o),
        y: Yx(e.y, t, s)
    }
}
function Xx(e, t) {
    let n = t.min - e.min
      , s = t.max - e.max;
    return t.max - t.min < e.max - e.min && ([n,s] = [s, n]),
    {
        min: n,
        max: s
    }
}
function iL(e, t) {
    return {
        x: Xx(e.x, t.x),
        y: Xx(e.y, t.y)
    }
}
function oL(e, t) {
    let n = .5;
    const s = vn(e)
      , o = vn(t);
    return o > s ? n = so(t.min, t.max - s, e.min) : s > o && (n = so(e.min, e.max - o, t.min)),
    Fr(0, 1, n)
}
function aL(e, t) {
    const n = {};
    return t.min !== void 0 && (n.min = t.min - e.min),
    t.max !== void 0 && (n.max = t.max - e.min),
    n
}
const ep = .35;
function lL(e=ep) {
    return e === !1 ? e = 0 : e === !0 && (e = ep),
    {
        x: Jx(e, "left", "right"),
        y: Jx(e, "top", "bottom")
    }
}
function Jx(e, t, n) {
    return {
        min: e0(e, t),
        max: e0(e, n)
    }
}
function e0(e, t) {
    return typeof e == "number" ? e : e[t] || 0
}
const t0 = () => ({
    translate: 0,
    scale: 1,
    origin: 0,
    originPoint: 0
})
  , $i = () => ({
    x: t0(),
    y: t0()
})
  , n0 = () => ({
    min: 0,
    max: 0
})
  , yt = () => ({
    x: n0(),
    y: n0()
});
function En(e) {
    return [e("x"), e("y")]
}
function I1({top: e, left: t, right: n, bottom: s}) {
    return {
        x: {
            min: t,
            max: n
        },
        y: {
            min: e,
            max: s
        }
    }
}
function uL({x: e, y: t}) {
    return {
        top: t.min,
        right: e.max,
        bottom: t.max,
        left: e.min
    }
}
function cL(e, t) {
    if (!t)
        return e;
    const n = t({
        x: e.left,
        y: e.top
    })
      , s = t({
        x: e.right,
        y: e.bottom
    });
    return {
        top: n.y,
        left: n.x,
        bottom: s.y,
        right: s.x
    }
}
function ih(e) {
    return e === void 0 || e === 1
}
function tp({scale: e, scaleX: t, scaleY: n}) {
    return !ih(e) || !ih(t) || !ih(n)
}
function Vs(e) {
    return tp(e) || F1(e) || e.z || e.rotate || e.rotateX || e.rotateY || e.skewX || e.skewY
}
function F1(e) {
    return r0(e.x) || r0(e.y)
}
function r0(e) {
    return e && e !== "0%"
}
function nc(e, t, n) {
    const s = e - n
      , o = t * s;
    return n + o
}
function s0(e, t, n, s, o) {
    return o !== void 0 && (e = nc(e, o, s)),
    nc(e, n, s) + t
}
function np(e, t=0, n=1, s, o) {
    e.min = s0(e.min, t, n, s, o),
    e.max = s0(e.max, t, n, s, o)
}
function L1(e, {x: t, y: n}) {
    np(e.x, t.translate, t.scale, t.originPoint),
    np(e.y, n.translate, n.scale, n.originPoint)
}
const i0 = .999999999999
  , o0 = 1.0000000000001;
function dL(e, t, n, s=!1) {
    const o = n.length;
    if (!o)
        return;
    t.x = t.y = 1;
    let a, u;
    for (let c = 0; c < o; c++) {
        a = n[c],
        u = a.projectionDelta;
        const {visualElement: f} = a.options;
        f && f.props.style && f.props.style.display === "contents" || (s && a.options.layoutScroll && a.scroll && a !== a.root && Hi(e, {
            x: -a.scroll.offset.x,
            y: -a.scroll.offset.y
        }),
        u && (t.x *= u.x.scale,
        t.y *= u.y.scale,
        L1(e, u)),
        s && Vs(a.latestValues) && Hi(e, a.latestValues))
    }
    t.x < o0 && t.x > i0 && (t.x = 1),
    t.y < o0 && t.y > i0 && (t.y = 1)
}
function Wi(e, t) {
    e.min = e.min + t,
    e.max = e.max + t
}
function a0(e, t, n, s, o=.5) {
    const a = dt(e.min, e.max, o);
    np(e, t, n, a, s)
}
function Hi(e, t) {
    a0(e.x, t.x, t.scaleX, t.scale, t.originX),
    a0(e.y, t.y, t.scaleY, t.scale, t.originY)
}
function V1(e, t) {
    return I1(cL(e.getBoundingClientRect(), t))
}
function fL(e, t, n) {
    const s = V1(e, n)
      , {scroll: o} = t;
    return o && (Wi(s.x, o.offset.x),
    Wi(s.y, o.offset.y)),
    s
}
const B1 = ({current: e}) => e ? e.ownerDocument.defaultView : null
  , hL = new WeakMap;
class pL {
    constructor(t) {
        this.openDragLock = null,
        this.isDragging = !1,
        this.currentDirection = null,
        this.originPoint = {
            x: 0,
            y: 0
        },
        this.constraints = !1,
        this.hasMutatedConstraints = !1,
        this.elastic = yt(),
        this.visualElement = t
    }
    start(t, {snapToCursor: n=!1}={}) {
        const {presenceContext: s} = this.visualElement;
        if (s && s.isPresent === !1)
            return;
        const o = m => {
            const {dragSnapToOrigin: v} = this.getProps();
            v ? this.pauseAnimation() : this.stopAnimation(),
            n && this.snapToCursor(tl(m).point)
        }
          , a = (m, v) => {
            const {drag: x, dragPropagation: T, onDragStart: C} = this.getProps();
            if (x && !T && (this.openDragLock && this.openDragLock(),
            this.openDragLock = oI(x),
            !this.openDragLock))
                return;
            this.isDragging = !0,
            this.currentDirection = null,
            this.resolveConstraints(),
            this.visualElement.projection && (this.visualElement.projection.isAnimationBlocked = !0,
            this.visualElement.projection.target = void 0),
            En(P => {
                let _ = this.getAxisMotionValue(P).get() || 0;
                if (lr.test(_)) {
                    const {projection: k} = this.visualElement;
                    if (k && k.layout) {
                        const j = k.layout.layoutBox[P];
                        j && (_ = vn(j) * (parseFloat(_) / 100))
                    }
                }
                this.originPoint[P] = _
            }
            ),
            C && it.postRender( () => C(m, v)),
            qh(this.visualElement, "transform");
            const {animationState: S} = this.visualElement;
            S && S.setActive("whileDrag", !0)
        }
          , u = (m, v) => {
            const {dragPropagation: x, dragDirectionLock: T, onDirectionLock: C, onDrag: S} = this.getProps();
            if (!x && !this.openDragLock)
                return;
            const {offset: P} = v;
            if (T && this.currentDirection === null) {
                this.currentDirection = mL(P),
                this.currentDirection !== null && C && C(this.currentDirection);
                return
            }
            this.updateAxis("x", v.point, P),
            this.updateAxis("y", v.point, P),
            this.visualElement.render(),
            S && S(m, v)
        }
          , c = (m, v) => this.stop(m, v)
          , f = () => En(m => {
            var v;
            return this.getAnimationState(m) === "paused" && ((v = this.getAxisMotionValue(m).animation) === null || v === void 0 ? void 0 : v.play())
        }
        )
          , {dragSnapToOrigin: h} = this.getProps();
        this.panSession = new j1(t,{
            onSessionStart: o,
            onStart: a,
            onMove: u,
            onSessionEnd: c,
            resumeAnimation: f
        },{
            transformPagePoint: this.visualElement.getTransformPagePoint(),
            dragSnapToOrigin: h,
            contextWindow: B1(this.visualElement)
        })
    }
    stop(t, n) {
        const s = this.isDragging;
        if (this.cancel(),
        !s)
            return;
        const {velocity: o} = n;
        this.startAnimation(o);
        const {onDragEnd: a} = this.getProps();
        a && it.postRender( () => a(t, n))
    }
    cancel() {
        this.isDragging = !1;
        const {projection: t, animationState: n} = this.visualElement;
        t && (t.isAnimationBlocked = !1),
        this.panSession && this.panSession.end(),
        this.panSession = void 0;
        const {dragPropagation: s} = this.getProps();
        !s && this.openDragLock && (this.openDragLock(),
        this.openDragLock = null),
        n && n.setActive("whileDrag", !1)
    }
    updateAxis(t, n, s) {
        const {drag: o} = this.getProps();
        if (!s || !wu(t, o, this.currentDirection))
            return;
        const a = this.getAxisMotionValue(t);
        let u = this.originPoint[t] + s[t];
        this.constraints && this.constraints[t] && (u = rL(u, this.constraints[t], this.elastic[t])),
        a.set(u)
    }
    resolveConstraints() {
        var t;
        const {dragConstraints: n, dragElastic: s} = this.getProps()
          , o = this.visualElement.projection && !this.visualElement.projection.layout ? this.visualElement.projection.measure(!1) : (t = this.visualElement.projection) === null || t === void 0 ? void 0 : t.layout
          , a = this.constraints;
        n && zi(n) ? this.constraints || (this.constraints = this.resolveRefConstraints()) : n && o ? this.constraints = sL(o.layoutBox, n) : this.constraints = !1,
        this.elastic = lL(s),
        a !== this.constraints && o && this.constraints && !this.hasMutatedConstraints && En(u => {
            this.constraints !== !1 && this.getAxisMotionValue(u) && (this.constraints[u] = aL(o.layoutBox[u], this.constraints[u]))
        }
        )
    }
    resolveRefConstraints() {
        const {dragConstraints: t, onMeasureDragConstraints: n} = this.getProps();
        if (!t || !zi(t))
            return !1;
        const s = t.current
          , {projection: o} = this.visualElement;
        if (!o || !o.layout)
            return !1;
        const a = fL(s, o.root, this.visualElement.getTransformPagePoint());
        let u = iL(o.layout.layoutBox, a);
        if (n) {
            const c = n(uL(u));
            this.hasMutatedConstraints = !!c,
            c && (u = I1(c))
        }
        return u
    }
    startAnimation(t) {
        const {drag: n, dragMomentum: s, dragElastic: o, dragTransition: a, dragSnapToOrigin: u, onDragTransitionEnd: c} = this.getProps()
          , f = this.constraints || {}
          , h = En(m => {
            if (!wu(m, n, this.currentDirection))
                return;
            let v = f && f[m] || {};
            u && (v = {
                min: 0,
                max: 0
            });
            const x = o ? 200 : 1e6
              , T = o ? 40 : 1e7
              , C = {
                type: "inertia",
                velocity: s ? t[m] : 0,
                bounceStiffness: x,
                bounceDamping: T,
                timeConstant: 750,
                restDelta: 1,
                restSpeed: 10,
                ...a,
                ...v
            };
            return this.startAxisValueAnimation(m, C)
        }
        );
        return Promise.all(h).then(c)
    }
    startAxisValueAnimation(t, n) {
        const s = this.getAxisMotionValue(t);
        return qh(this.visualElement, t),
        s.start(gm(t, s, 0, n, this.visualElement, !1))
    }
    stopAnimation() {
        En(t => this.getAxisMotionValue(t).stop())
    }
    pauseAnimation() {
        En(t => {
            var n;
            return (n = this.getAxisMotionValue(t).animation) === null || n === void 0 ? void 0 : n.pause()
        }
        )
    }
    getAnimationState(t) {
        var n;
        return (n = this.getAxisMotionValue(t).animation) === null || n === void 0 ? void 0 : n.state
    }
    getAxisMotionValue(t) {
        const n = `_drag${t.toUpperCase()}`
          , s = this.visualElement.getProps()
          , o = s[n];
        return o || this.visualElement.getValue(t, (s.initial ? s.initial[t] : void 0) || 0)
    }
    snapToCursor(t) {
        En(n => {
            const {drag: s} = this.getProps();
            if (!wu(n, s, this.currentDirection))
                return;
            const {projection: o} = this.visualElement
              , a = this.getAxisMotionValue(n);
            if (o && o.layout) {
                const {min: u, max: c} = o.layout.layoutBox[n];
                a.set(t[n] - dt(u, c, .5))
            }
        }
        )
    }
    scalePositionWithinConstraints() {
        if (!this.visualElement.current)
            return;
        const {drag: t, dragConstraints: n} = this.getProps()
          , {projection: s} = this.visualElement;
        if (!zi(n) || !s || !this.constraints)
            return;
        this.stopAnimation();
        const o = {
            x: 0,
            y: 0
        };
        En(u => {
            const c = this.getAxisMotionValue(u);
            if (c && this.constraints !== !1) {
                const f = c.get();
                o[u] = oL({
                    min: f,
                    max: f
                }, this.constraints[u])
            }
        }
        );
        const {transformTemplate: a} = this.visualElement.getProps();
        this.visualElement.current.style.transform = a ? a({}, "") : "none",
        s.root && s.root.updateScroll(),
        s.updateLayout(),
        this.resolveConstraints(),
        En(u => {
            if (!wu(u, t, null))
                return;
            const c = this.getAxisMotionValue(u)
              , {min: f, max: h} = this.constraints[u];
            c.set(dt(f, h, o[u]))
        }
        )
    }
    addListeners() {
        if (!this.visualElement.current)
            return;
        hL.set(this.visualElement, this);
        const t = this.visualElement.current
          , n = va(t, "pointerdown", f => {
            const {drag: h, dragListener: m=!0} = this.getProps();
            h && m && this.start(f)
        }
        )
          , s = () => {
            const {dragConstraints: f} = this.getProps();
            zi(f) && f.current && (this.constraints = this.resolveRefConstraints())
        }
          , {projection: o} = this.visualElement
          , a = o.addEventListener("measure", s);
        o && !o.layout && (o.root && o.root.updateScroll(),
        o.updateLayout()),
        it.read(s);
        const u = Qa(window, "resize", () => this.scalePositionWithinConstraints())
          , c = o.addEventListener("didUpdate", ( ({delta: f, hasLayoutChanged: h}) => {
            this.isDragging && h && (En(m => {
                const v = this.getAxisMotionValue(m);
                v && (this.originPoint[m] += f[m].translate,
                v.set(v.get() + f[m].translate))
            }
            ),
            this.visualElement.render())
        }
        ));
        return () => {
            u(),
            n(),
            a(),
            c && c()
        }
    }
    getProps() {
        const t = this.visualElement.getProps()
          , {drag: n=!1, dragDirectionLock: s=!1, dragPropagation: o=!1, dragConstraints: a=!1, dragElastic: u=ep, dragMomentum: c=!0} = t;
        return {
            ...t,
            drag: n,
            dragDirectionLock: s,
            dragPropagation: o,
            dragConstraints: a,
            dragElastic: u,
            dragMomentum: c
        }
    }
}
function wu(e, t, n) {
    return (t === !0 || t === e) && (n === null || n === e)
}
function mL(e, t=10) {
    let n = null;
    return Math.abs(e.y) > t ? n = "y" : Math.abs(e.x) > t && (n = "x"),
    n
}
class gL extends bs {
    constructor(t) {
        super(t),
        this.removeGroupControls = gn,
        this.removeListeners = gn,
        this.controls = new pL(t)
    }
    mount() {
        const {dragControls: t} = this.node.getProps();
        t && (this.removeGroupControls = t.subscribe(this.controls)),
        this.removeListeners = this.controls.addListeners() || gn
    }
    unmount() {
        this.removeGroupControls(),
        this.removeListeners()
    }
}
const l0 = e => (t, n) => {
    e && it.postRender( () => e(t, n))
}
;
class yL extends bs {
    constructor() {
        super(...arguments),
        this.removePointerDownListener = gn
    }
    onPointerDown(t) {
        this.session = new j1(t,this.createPanHandlers(),{
            transformPagePoint: this.node.getTransformPagePoint(),
            contextWindow: B1(this.node)
        })
    }
    createPanHandlers() {
        const {onPanSessionStart: t, onPanStart: n, onPan: s, onPanEnd: o} = this.node.getProps();
        return {
            onSessionStart: l0(t),
            onStart: l0(n),
            onMove: s,
            onEnd: (a, u) => {
                delete this.session,
                o && it.postRender( () => o(a, u))
            }
        }
    }
    mount() {
        this.removePointerDownListener = va(this.node.current, "pointerdown", t => this.onPointerDown(t))
    }
    update() {
        this.session && this.session.updateHandlers(this.createPanHandlers())
    }
    unmount() {
        this.removePointerDownListener(),
        this.session && this.session.end()
    }
}
const Au = {
    hasAnimatedSinceResize: !0,
    hasEverUpdated: !1
};
function u0(e, t) {
    return t.max === t.min ? 0 : e / (t.max - t.min) * 100
}
const oa = {
    correct: (e, t) => {
        if (!t.target)
            return e;
        if (typeof e == "string")
            if (Pe.test(e))
                e = parseFloat(e);
            else
                return e;
        const n = u0(e, t.target.x)
          , s = u0(e, t.target.y);
        return `${n}% ${s}%`
    }
}
  , vL = {
    correct: (e, {treeScale: t, projectionDelta: n}) => {
        const s = e
          , o = ws.parse(e);
        if (o.length > 5)
            return s;
        const a = ws.createTransformer(e)
          , u = typeof o[0] != "number" ? 1 : 0
          , c = n.x.scale * t.x
          , f = n.y.scale * t.y;
        o[0 + u] /= c,
        o[1 + u] /= f;
        const h = dt(c, f, .5);
        return typeof o[2 + u] == "number" && (o[2 + u] /= h),
        typeof o[3 + u] == "number" && (o[3 + u] /= h),
        a(o)
    }
};
class xL extends w.Component {
    componentDidMount() {
        const {visualElement: t, layoutGroup: n, switchLayoutGroup: s, layoutId: o} = this.props
          , {projection: a} = t;
        V2(wL),
        a && (n.group && n.group.add(a),
        s && s.register && o && s.register(a),
        a.root.didUpdate(),
        a.addEventListener("animationComplete", () => {
            this.safeToRemove()
        }
        ),
        a.setOptions({
            ...a.options,
            onExitComplete: () => this.safeToRemove()
        })),
        Au.hasEverUpdated = !0
    }
    getSnapshotBeforeUpdate(t) {
        const {layoutDependency: n, visualElement: s, drag: o, isPresent: a} = this.props
          , u = s.projection;
        return u && (u.isPresent = a,
        o || t.layoutDependency !== n || n === void 0 ? u.willUpdate() : this.safeToRemove(),
        t.isPresent !== a && (a ? u.promote() : u.relegate() || it.postRender( () => {
            const c = u.getStack();
            (!c || !c.members.length) && this.safeToRemove()
        }
        ))),
        null
    }
    componentDidUpdate() {
        const {projection: t} = this.props.visualElement;
        t && (t.root.didUpdate(),
        Hp.postRender( () => {
            !t.currentAnimation && t.isLead() && this.safeToRemove()
        }
        ))
    }
    componentWillUnmount() {
        const {visualElement: t, layoutGroup: n, switchLayoutGroup: s} = this.props
          , {projection: o} = t;
        o && (o.scheduleCheckAfterUnmount(),
        n && n.group && n.group.remove(o),
        s && s.deregister && s.deregister(o))
    }
    safeToRemove() {
        const {safeToRemove: t} = this.props;
        t && t()
    }
    render() {
        return null
    }
}
function z1(e) {
    const [t,n] = TS()
      , s = w.useContext(Fp);
    return y.jsx(xL, {
        ...e,
        layoutGroup: s,
        switchLayoutGroup: w.useContext(RS),
        isPresent: t,
        safeToRemove: n
    })
}
const wL = {
    borderRadius: {
        ...oa,
        applyTo: ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomLeftRadius", "borderBottomRightRadius"]
    },
    borderTopLeftRadius: oa,
    borderTopRightRadius: oa,
    borderBottomLeftRadius: oa,
    borderBottomRightRadius: oa,
    boxShadow: vL
};
function bL(e, t, n) {
    const s = Wt(e) ? e : Ha(e);
    return s.start(gm("", s, t, n)),
    s.animation
}
function SL(e) {
    return e instanceof SVGElement && e.tagName !== "svg"
}
const TL = (e, t) => e.depth - t.depth;
class PL {
    constructor() {
        this.children = [],
        this.isDirty = !1
    }
    add(t) {
        im(this.children, t),
        this.isDirty = !0
    }
    remove(t) {
        om(this.children, t),
        this.isDirty = !0
    }
    forEach(t) {
        this.isDirty && this.children.sort(TL),
        this.isDirty = !1,
        this.children.forEach(t)
    }
}
function CL(e, t) {
    const n = ur.now()
      , s = ({timestamp: o}) => {
        const a = o - n;
        a >= t && (xs(s),
        e(a - t))
    }
    ;
    return it.read(s, !0),
    () => xs(s)
}
const U1 = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"]
  , EL = U1.length
  , c0 = e => typeof e == "string" ? parseFloat(e) : e
  , d0 = e => typeof e == "number" || Pe.test(e);
function _L(e, t, n, s, o, a) {
    o ? (e.opacity = dt(0, n.opacity !== void 0 ? n.opacity : 1, kL(s)),
    e.opacityExit = dt(t.opacity !== void 0 ? t.opacity : 1, 0, NL(s))) : a && (e.opacity = dt(t.opacity !== void 0 ? t.opacity : 1, n.opacity !== void 0 ? n.opacity : 1, s));
    for (let u = 0; u < EL; u++) {
        const c = `border${U1[u]}Radius`;
        let f = f0(t, c)
          , h = f0(n, c);
        if (f === void 0 && h === void 0)
            continue;
        f || (f = 0),
        h || (h = 0),
        f === 0 || h === 0 || d0(f) === d0(h) ? (e[c] = Math.max(dt(c0(f), c0(h), s), 0),
        (lr.test(h) || lr.test(f)) && (e[c] += "%")) : e[c] = h
    }
    (t.rotate || n.rotate) && (e.rotate = dt(t.rotate || 0, n.rotate || 0, s))
}
function f0(e, t) {
    return e[t] !== void 0 ? e[t] : e.borderRadius
}
const kL = $1(0, .5, a1)
  , NL = $1(.5, .95, gn);
function $1(e, t, n) {
    return s => s < e ? 0 : s > t ? 1 : n(so(e, t, s))
}
function h0(e, t) {
    e.min = t.min,
    e.max = t.max
}
function Cn(e, t) {
    h0(e.x, t.x),
    h0(e.y, t.y)
}
function p0(e, t) {
    e.translate = t.translate,
    e.scale = t.scale,
    e.originPoint = t.originPoint,
    e.origin = t.origin
}
function m0(e, t, n, s, o) {
    return e -= t,
    e = nc(e, 1 / n, s),
    o !== void 0 && (e = nc(e, 1 / o, s)),
    e
}
function AL(e, t=0, n=1, s=.5, o, a=e, u=e) {
    if (lr.test(t) && (t = parseFloat(t),
    t = dt(u.min, u.max, t / 100) - u.min),
    typeof t != "number")
        return;
    let c = dt(a.min, a.max, s);
    e === a && (c -= t),
    e.min = m0(e.min, t, n, c, o),
    e.max = m0(e.max, t, n, c, o)
}
function g0(e, t, [n,s,o], a, u) {
    AL(e, t[n], t[s], t[o], t.scale, a, u)
}
const RL = ["x", "scaleX", "originX"]
  , jL = ["y", "scaleY", "originY"];
function y0(e, t, n, s) {
    g0(e.x, t, RL, n ? n.x : void 0, s ? s.x : void 0),
    g0(e.y, t, jL, n ? n.y : void 0, s ? s.y : void 0)
}
function v0(e) {
    return e.translate === 0 && e.scale === 1
}
function W1(e) {
    return v0(e.x) && v0(e.y)
}
function x0(e, t) {
    return e.min === t.min && e.max === t.max
}
function DL(e, t) {
    return x0(e.x, t.x) && x0(e.y, t.y)
}
function w0(e, t) {
    return Math.round(e.min) === Math.round(t.min) && Math.round(e.max) === Math.round(t.max)
}
function H1(e, t) {
    return w0(e.x, t.x) && w0(e.y, t.y)
}
function b0(e) {
    return vn(e.x) / vn(e.y)
}
function S0(e, t) {
    return e.translate === t.translate && e.scale === t.scale && e.originPoint === t.originPoint
}
class OL {
    constructor() {
        this.members = []
    }
    add(t) {
        im(this.members, t),
        t.scheduleRender()
    }
    remove(t) {
        if (om(this.members, t),
        t === this.prevLead && (this.prevLead = void 0),
        t === this.lead) {
            const n = this.members[this.members.length - 1];
            n && this.promote(n)
        }
    }
    relegate(t) {
        const n = this.members.findIndex(o => t === o);
        if (n === 0)
            return !1;
        let s;
        for (let o = n; o >= 0; o--) {
            const a = this.members[o];
            if (a.isPresent !== !1) {
                s = a;
                break
            }
        }
        return s ? (this.promote(s),
        !0) : !1
    }
    promote(t, n) {
        const s = this.lead;
        if (t !== s && (this.prevLead = s,
        this.lead = t,
        t.show(),
        s)) {
            s.instance && s.scheduleRender(),
            t.scheduleRender(),
            t.resumeFrom = s,
            n && (t.resumeFrom.preserveOpacity = !0),
            s.snapshot && (t.snapshot = s.snapshot,
            t.snapshot.latestValues = s.animationValues || s.latestValues),
            t.root && t.root.isUpdating && (t.isLayoutDirty = !0);
            const {crossfade: o} = t.options;
            o === !1 && s.hide()
        }
    }
    exitAnimationComplete() {
        this.members.forEach(t => {
            const {options: n, resumingFrom: s} = t;
            n.onExitComplete && n.onExitComplete(),
            s && s.options.onExitComplete && s.options.onExitComplete()
        }
        )
    }
    scheduleRender() {
        this.members.forEach(t => {
            t.instance && t.scheduleRender(!1)
        }
        )
    }
    removeLeadSnapshot() {
        this.lead && this.lead.snapshot && (this.lead.snapshot = void 0)
    }
}
function ML(e, t, n) {
    let s = "";
    const o = e.x.translate / t.x
      , a = e.y.translate / t.y
      , u = n?.z || 0;
    if ((o || a || u) && (s = `translate3d(${o}px, ${a}px, ${u}px) `),
    (t.x !== 1 || t.y !== 1) && (s += `scale(${1 / t.x}, ${1 / t.y}) `),
    n) {
        const {transformPerspective: h, rotate: m, rotateX: v, rotateY: x, skewX: T, skewY: C} = n;
        h && (s = `perspective(${h}px) ${s}`),
        m && (s += `rotate(${m}deg) `),
        v && (s += `rotateX(${v}deg) `),
        x && (s += `rotateY(${x}deg) `),
        T && (s += `skewX(${T}deg) `),
        C && (s += `skewY(${C}deg) `)
    }
    const c = e.x.scale * t.x
      , f = e.y.scale * t.y;
    return (c !== 1 || f !== 1) && (s += `scale(${c}, ${f})`),
    s || "none"
}
const Bs = {
    type: "projectionFrame",
    totalNodes: 0,
    resolvedTargetDeltas: 0,
    recalculatedProjection: 0
}
  , ha = typeof window < "u" && window.MotionDebug !== void 0
  , oh = ["", "X", "Y", "Z"]
  , IL = {
    visibility: "hidden"
}
  , T0 = 1e3;
let FL = 0;
function ah(e, t, n, s) {
    const {latestValues: o} = t;
    o[e] && (n[e] = o[e],
    t.setStaticValue(e, 0),
    s && (s[e] = 0))
}
function q1(e) {
    if (e.hasCheckedOptimisedAppear = !0,
    e.root === e)
        return;
    const {visualElement: t} = e.options;
    if (!t)
        return;
    const n = e1(t);
    if (window.MotionHasOptimisedAnimation(n, "transform")) {
        const {layout: o, layoutId: a} = e.options;
        window.MotionCancelOptimisedAnimation(n, "transform", it, !(o || a))
    }
    const {parent: s} = e;
    s && !s.hasCheckedOptimisedAppear && q1(s)
}
function Q1({attachResizeListener: e, defaultParent: t, measureScroll: n, checkIsScrollRoot: s, resetTransform: o}) {
    return class {
        constructor(u={}, c=t?.()) {
            this.id = FL++,
            this.animationId = 0,
            this.children = new Set,
            this.options = {},
            this.isTreeAnimating = !1,
            this.isAnimationBlocked = !1,
            this.isLayoutDirty = !1,
            this.isProjectionDirty = !1,
            this.isSharedProjectionDirty = !1,
            this.isTransformDirty = !1,
            this.updateManuallyBlocked = !1,
            this.updateBlockedByResize = !1,
            this.isUpdating = !1,
            this.isSVG = !1,
            this.needsReset = !1,
            this.shouldResetTransform = !1,
            this.hasCheckedOptimisedAppear = !1,
            this.treeScale = {
                x: 1,
                y: 1
            },
            this.eventHandlers = new Map,
            this.hasTreeAnimated = !1,
            this.updateScheduled = !1,
            this.scheduleUpdate = () => this.update(),
            this.projectionUpdateScheduled = !1,
            this.checkUpdateFailed = () => {
                this.isUpdating && (this.isUpdating = !1,
                this.clearAllSnapshots())
            }
            ,
            this.updateProjection = () => {
                this.projectionUpdateScheduled = !1,
                ha && (Bs.totalNodes = Bs.resolvedTargetDeltas = Bs.recalculatedProjection = 0),
                this.nodes.forEach(BL),
                this.nodes.forEach(HL),
                this.nodes.forEach(qL),
                this.nodes.forEach(zL),
                ha && window.MotionDebug.record(Bs)
            }
            ,
            this.resolvedRelativeTargetAt = 0,
            this.hasProjected = !1,
            this.isVisible = !0,
            this.animationProgress = 0,
            this.sharedNodes = new Map,
            this.latestValues = u,
            this.root = c ? c.root || c : this,
            this.path = c ? [...c.path, c] : [],
            this.parent = c,
            this.depth = c ? c.depth + 1 : 0;
            for (let f = 0; f < this.path.length; f++)
                this.path[f].shouldResetTransform = !0;
            this.root === this && (this.nodes = new PL)
        }
        addEventListener(u, c) {
            return this.eventHandlers.has(u) || this.eventHandlers.set(u, new am),
            this.eventHandlers.get(u).add(c)
        }
        notifyListeners(u, ...c) {
            const f = this.eventHandlers.get(u);
            f && f.notify(...c)
        }
        hasListeners(u) {
            return this.eventHandlers.has(u)
        }
        mount(u, c=this.root.hasTreeAnimated) {
            if (this.instance)
                return;
            this.isSVG = SL(u),
            this.instance = u;
            const {layoutId: f, layout: h, visualElement: m} = this.options;
            if (m && !m.current && m.mount(u),
            this.root.nodes.add(this),
            this.parent && this.parent.children.add(this),
            c && (h || f) && (this.isLayoutDirty = !0),
            e) {
                let v;
                const x = () => this.root.updateBlockedByResize = !1;
                e(u, () => {
                    this.root.updateBlockedByResize = !0,
                    v && v(),
                    v = CL(x, 250),
                    Au.hasAnimatedSinceResize && (Au.hasAnimatedSinceResize = !1,
                    this.nodes.forEach(C0))
                }
                )
            }
            f && this.root.registerSharedNode(f, this),
            this.options.animate !== !1 && m && (f || h) && this.addEventListener("didUpdate", ({delta: v, hasLayoutChanged: x, hasRelativeTargetChanged: T, layout: C}) => {
                if (this.isTreeAnimationBlocked()) {
                    this.target = void 0,
                    this.relativeTarget = void 0;
                    return
                }
                const S = this.options.transition || m.getDefaultTransition() || YL
                  , {onLayoutAnimationStart: P, onLayoutAnimationComplete: _} = m.getProps()
                  , k = !this.targetLayout || !H1(this.targetLayout, C) || T
                  , j = !x && T;
                if (this.options.layoutRoot || this.resumeFrom && this.resumeFrom.instance || j || x && (k || !this.currentAnimation)) {
                    this.resumeFrom && (this.resumingFrom = this.resumeFrom,
                    this.resumingFrom.resumingFrom = void 0),
                    this.setAnimationOrigin(v, j);
                    const M = {
                        ...tm(S, "layout"),
                        onPlay: P,
                        onComplete: _
                    };
                    (m.shouldReduceMotion || this.options.layoutRoot) && (M.delay = 0,
                    M.type = !1),
                    this.startAnimation(M)
                } else
                    x || C0(this),
                    this.isLead() && this.options.onExitComplete && this.options.onExitComplete();
                this.targetLayout = C
            }
            )
        }
        unmount() {
            this.options.layoutId && this.willUpdate(),
            this.root.nodes.remove(this);
            const u = this.getStack();
            u && u.remove(this),
            this.parent && this.parent.children.delete(this),
            this.instance = void 0,
            xs(this.updateProjection)
        }
        blockUpdate() {
            this.updateManuallyBlocked = !0
        }
        unblockUpdate() {
            this.updateManuallyBlocked = !1
        }
        isUpdateBlocked() {
            return this.updateManuallyBlocked || this.updateBlockedByResize
        }
        isTreeAnimationBlocked() {
            return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || !1
        }
        startUpdate() {
            this.isUpdateBlocked() || (this.isUpdating = !0,
            this.nodes && this.nodes.forEach(QL),
            this.animationId++)
        }
        getTransformTemplate() {
            const {visualElement: u} = this.options;
            return u && u.getProps().transformTemplate
        }
        willUpdate(u=!0) {
            if (this.root.hasTreeAnimated = !0,
            this.root.isUpdateBlocked()) {
                this.options.onExitComplete && this.options.onExitComplete();
                return
            }
            if (window.MotionCancelOptimisedAnimation && !this.hasCheckedOptimisedAppear && q1(this),
            !this.root.isUpdating && this.root.startUpdate(),
            this.isLayoutDirty)
                return;
            this.isLayoutDirty = !0;
            for (let m = 0; m < this.path.length; m++) {
                const v = this.path[m];
                v.shouldResetTransform = !0,
                v.updateScroll("snapshot"),
                v.options.layoutRoot && v.willUpdate(!1)
            }
            const {layoutId: c, layout: f} = this.options;
            if (c === void 0 && !f)
                return;
            const h = this.getTransformTemplate();
            this.prevTransformTemplateValue = h ? h(this.latestValues, "") : void 0,
            this.updateSnapshot(),
            u && this.notifyListeners("willUpdate")
        }
        update() {
            if (this.updateScheduled = !1,
            this.isUpdateBlocked()) {
                this.unblockUpdate(),
                this.clearAllSnapshots(),
                this.nodes.forEach(P0);
                return
            }
            this.isUpdating || this.nodes.forEach($L),
            this.isUpdating = !1,
            this.nodes.forEach(WL),
            this.nodes.forEach(LL),
            this.nodes.forEach(VL),
            this.clearAllSnapshots();
            const c = ur.now();
            Ft.delta = Fr(0, 1e3 / 60, c - Ft.timestamp),
            Ft.timestamp = c,
            Ft.isProcessing = !0,
            Yf.update.process(Ft),
            Yf.preRender.process(Ft),
            Yf.render.process(Ft),
            Ft.isProcessing = !1
        }
        didUpdate() {
            this.updateScheduled || (this.updateScheduled = !0,
            Hp.read(this.scheduleUpdate))
        }
        clearAllSnapshots() {
            this.nodes.forEach(UL),
            this.sharedNodes.forEach(KL)
        }
        scheduleUpdateProjection() {
            this.projectionUpdateScheduled || (this.projectionUpdateScheduled = !0,
            it.preRender(this.updateProjection, !1, !0))
        }
        scheduleCheckAfterUnmount() {
            it.postRender( () => {
                this.isLayoutDirty ? this.root.didUpdate() : this.root.checkUpdateFailed()
            }
            )
        }
        updateSnapshot() {
            this.snapshot || !this.instance || (this.snapshot = this.measure())
        }
        updateLayout() {
            if (!this.instance || (this.updateScroll(),
            !(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty))
                return;
            if (this.resumeFrom && !this.resumeFrom.instance)
                for (let f = 0; f < this.path.length; f++)
                    this.path[f].updateScroll();
            const u = this.layout;
            this.layout = this.measure(!1),
            this.layoutCorrected = yt(),
            this.isLayoutDirty = !1,
            this.projectionDelta = void 0,
            this.notifyListeners("measure", this.layout.layoutBox);
            const {visualElement: c} = this.options;
            c && c.notify("LayoutMeasure", this.layout.layoutBox, u ? u.layoutBox : void 0)
        }
        updateScroll(u="measure") {
            let c = !!(this.options.layoutScroll && this.instance);
            if (this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === u && (c = !1),
            c) {
                const f = s(this.instance);
                this.scroll = {
                    animationId: this.root.animationId,
                    phase: u,
                    isRoot: f,
                    offset: n(this.instance),
                    wasRoot: this.scroll ? this.scroll.isRoot : f
                }
            }
        }
        resetTransform() {
            if (!o)
                return;
            const u = this.isLayoutDirty || this.shouldResetTransform || this.options.alwaysMeasureLayout
              , c = this.projectionDelta && !W1(this.projectionDelta)
              , f = this.getTransformTemplate()
              , h = f ? f(this.latestValues, "") : void 0
              , m = h !== this.prevTransformTemplateValue;
            u && (c || Vs(this.latestValues) || m) && (o(this.instance, h),
            this.shouldResetTransform = !1,
            this.scheduleRender())
        }
        measure(u=!0) {
            const c = this.measurePageBox();
            let f = this.removeElementScroll(c);
            return u && (f = this.removeTransform(f)),
            XL(f),
            {
                animationId: this.root.animationId,
                measuredBox: c,
                layoutBox: f,
                latestValues: {},
                source: this.id
            }
        }
        measurePageBox() {
            var u;
            const {visualElement: c} = this.options;
            if (!c)
                return yt();
            const f = c.measureViewportBox();
            if (!(((u = this.scroll) === null || u === void 0 ? void 0 : u.wasRoot) || this.path.some(JL))) {
                const {scroll: m} = this.root;
                m && (Wi(f.x, m.offset.x),
                Wi(f.y, m.offset.y))
            }
            return f
        }
        removeElementScroll(u) {
            var c;
            const f = yt();
            if (Cn(f, u),
            !((c = this.scroll) === null || c === void 0) && c.wasRoot)
                return f;
            for (let h = 0; h < this.path.length; h++) {
                const m = this.path[h]
                  , {scroll: v, options: x} = m;
                m !== this.root && v && x.layoutScroll && (v.wasRoot && Cn(f, u),
                Wi(f.x, v.offset.x),
                Wi(f.y, v.offset.y))
            }
            return f
        }
        applyTransform(u, c=!1) {
            const f = yt();
            Cn(f, u);
            for (let h = 0; h < this.path.length; h++) {
                const m = this.path[h];
                !c && m.options.layoutScroll && m.scroll && m !== m.root && Hi(f, {
                    x: -m.scroll.offset.x,
                    y: -m.scroll.offset.y
                }),
                Vs(m.latestValues) && Hi(f, m.latestValues)
            }
            return Vs(this.latestValues) && Hi(f, this.latestValues),
            f
        }
        removeTransform(u) {
            const c = yt();
            Cn(c, u);
            for (let f = 0; f < this.path.length; f++) {
                const h = this.path[f];
                if (!h.instance || !Vs(h.latestValues))
                    continue;
                tp(h.latestValues) && h.updateSnapshot();
                const m = yt()
                  , v = h.measurePageBox();
                Cn(m, v),
                y0(c, h.latestValues, h.snapshot ? h.snapshot.layoutBox : void 0, m)
            }
            return Vs(this.latestValues) && y0(c, this.latestValues),
            c
        }
        setTargetDelta(u) {
            this.targetDelta = u,
            this.root.scheduleUpdateProjection(),
            this.isProjectionDirty = !0
        }
        setOptions(u) {
            this.options = {
                ...this.options,
                ...u,
                crossfade: u.crossfade !== void 0 ? u.crossfade : !0
            }
        }
        clearMeasurements() {
            this.scroll = void 0,
            this.layout = void 0,
            this.snapshot = void 0,
            this.prevTransformTemplateValue = void 0,
            this.targetDelta = void 0,
            this.target = void 0,
            this.isLayoutDirty = !1
        }
        forceRelativeParentToResolveTarget() {
            this.relativeParent && this.relativeParent.resolvedRelativeTargetAt !== Ft.timestamp && this.relativeParent.resolveTargetDelta(!0)
        }
        resolveTargetDelta(u=!1) {
            var c;
            const f = this.getLead();
            this.isProjectionDirty || (this.isProjectionDirty = f.isProjectionDirty),
            this.isTransformDirty || (this.isTransformDirty = f.isTransformDirty),
            this.isSharedProjectionDirty || (this.isSharedProjectionDirty = f.isSharedProjectionDirty);
            const h = !!this.resumingFrom || this !== f;
            if (!(u || h && this.isSharedProjectionDirty || this.isProjectionDirty || !((c = this.parent) === null || c === void 0) && c.isProjectionDirty || this.attemptToResolveRelativeTarget || this.root.updateBlockedByResize))
                return;
            const {layout: v, layoutId: x} = this.options;
            if (!(!this.layout || !(v || x))) {
                if (this.resolvedRelativeTargetAt = Ft.timestamp,
                !this.targetDelta && !this.relativeTarget) {
                    const T = this.getClosestProjectingParent();
                    T && T.layout && this.animationProgress !== 1 ? (this.relativeParent = T,
                    this.forceRelativeParentToResolveTarget(),
                    this.relativeTarget = yt(),
                    this.relativeTargetOrigin = yt(),
                    wa(this.relativeTargetOrigin, this.layout.layoutBox, T.layout.layoutBox),
                    Cn(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0
                }
                if (!(!this.relativeTarget && !this.targetDelta)) {
                    if (this.target || (this.target = yt(),
                    this.targetWithTransforms = yt()),
                    this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target ? (this.forceRelativeParentToResolveTarget(),
                    nL(this.target, this.relativeTarget, this.relativeParent.target)) : this.targetDelta ? (this.resumingFrom ? this.target = this.applyTransform(this.layout.layoutBox) : Cn(this.target, this.layout.layoutBox),
                    L1(this.target, this.targetDelta)) : Cn(this.target, this.layout.layoutBox),
                    this.attemptToResolveRelativeTarget) {
                        this.attemptToResolveRelativeTarget = !1;
                        const T = this.getClosestProjectingParent();
                        T && !!T.resumingFrom == !!this.resumingFrom && !T.options.layoutScroll && T.target && this.animationProgress !== 1 ? (this.relativeParent = T,
                        this.forceRelativeParentToResolveTarget(),
                        this.relativeTarget = yt(),
                        this.relativeTargetOrigin = yt(),
                        wa(this.relativeTargetOrigin, this.target, T.target),
                        Cn(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0
                    }
                    ha && Bs.resolvedTargetDeltas++
                }
            }
        }
        getClosestProjectingParent() {
            if (!(!this.parent || tp(this.parent.latestValues) || F1(this.parent.latestValues)))
                return this.parent.isProjecting() ? this.parent : this.parent.getClosestProjectingParent()
        }
        isProjecting() {
            return !!((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout)
        }
        calcProjection() {
            var u;
            const c = this.getLead()
              , f = !!this.resumingFrom || this !== c;
            let h = !0;
            if ((this.isProjectionDirty || !((u = this.parent) === null || u === void 0) && u.isProjectionDirty) && (h = !1),
            f && (this.isSharedProjectionDirty || this.isTransformDirty) && (h = !1),
            this.resolvedRelativeTargetAt === Ft.timestamp && (h = !1),
            h)
                return;
            const {layout: m, layoutId: v} = this.options;
            if (this.isTreeAnimating = !!(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation),
            this.isTreeAnimating || (this.targetDelta = this.relativeTarget = void 0),
            !this.layout || !(m || v))
                return;
            Cn(this.layoutCorrected, this.layout.layoutBox);
            const x = this.treeScale.x
              , T = this.treeScale.y;
            dL(this.layoutCorrected, this.treeScale, this.path, f),
            c.layout && !c.target && (this.treeScale.x !== 1 || this.treeScale.y !== 1) && (c.target = c.layout.layoutBox,
            c.targetWithTransforms = yt());
            const {target: C} = c;
            if (!C) {
                this.prevProjectionDelta && (this.createProjectionDeltas(),
                this.scheduleRender());
                return
            }
            !this.projectionDelta || !this.prevProjectionDelta ? this.createProjectionDeltas() : (p0(this.prevProjectionDelta.x, this.projectionDelta.x),
            p0(this.prevProjectionDelta.y, this.projectionDelta.y)),
            xa(this.projectionDelta, this.layoutCorrected, C, this.latestValues),
            (this.treeScale.x !== x || this.treeScale.y !== T || !S0(this.projectionDelta.x, this.prevProjectionDelta.x) || !S0(this.projectionDelta.y, this.prevProjectionDelta.y)) && (this.hasProjected = !0,
            this.scheduleRender(),
            this.notifyListeners("projectionUpdate", C)),
            ha && Bs.recalculatedProjection++
        }
        hide() {
            this.isVisible = !1
        }
        show() {
            this.isVisible = !0
        }
        scheduleRender(u=!0) {
            var c;
            if ((c = this.options.visualElement) === null || c === void 0 || c.scheduleRender(),
            u) {
                const f = this.getStack();
                f && f.scheduleRender()
            }
            this.resumingFrom && !this.resumingFrom.instance && (this.resumingFrom = void 0)
        }
        createProjectionDeltas() {
            this.prevProjectionDelta = $i(),
            this.projectionDelta = $i(),
            this.projectionDeltaWithTransform = $i()
        }
        setAnimationOrigin(u, c=!1) {
            const f = this.snapshot
              , h = f ? f.latestValues : {}
              , m = {
                ...this.latestValues
            }
              , v = $i();
            (!this.relativeParent || !this.relativeParent.options.layoutRoot) && (this.relativeTarget = this.relativeTargetOrigin = void 0),
            this.attemptToResolveRelativeTarget = !c;
            const x = yt()
              , T = f ? f.source : void 0
              , C = this.layout ? this.layout.source : void 0
              , S = T !== C
              , P = this.getStack()
              , _ = !P || P.members.length <= 1
              , k = !!(S && !_ && this.options.crossfade === !0 && !this.path.some(ZL));
            this.animationProgress = 0;
            let j;
            this.mixTargetDelta = M => {
                const O = M / 1e3;
                E0(v.x, u.x, O),
                E0(v.y, u.y, O),
                this.setTargetDelta(v),
                this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout && (wa(x, this.layout.layoutBox, this.relativeParent.layout.layoutBox),
                GL(this.relativeTarget, this.relativeTargetOrigin, x, O),
                j && DL(this.relativeTarget, j) && (this.isProjectionDirty = !1),
                j || (j = yt()),
                Cn(j, this.relativeTarget)),
                S && (this.animationValues = m,
                _L(m, h, this.latestValues, O, k, _)),
                this.root.scheduleUpdateProjection(),
                this.scheduleRender(),
                this.animationProgress = O
            }
            ,
            this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0)
        }
        startAnimation(u) {
            this.notifyListeners("animationStart"),
            this.currentAnimation && this.currentAnimation.stop(),
            this.resumingFrom && this.resumingFrom.currentAnimation && this.resumingFrom.currentAnimation.stop(),
            this.pendingAnimation && (xs(this.pendingAnimation),
            this.pendingAnimation = void 0),
            this.pendingAnimation = it.update( () => {
                Au.hasAnimatedSinceResize = !0,
                this.currentAnimation = bL(0, T0, {
                    ...u,
                    onUpdate: c => {
                        this.mixTargetDelta(c),
                        u.onUpdate && u.onUpdate(c)
                    }
                    ,
                    onComplete: () => {
                        u.onComplete && u.onComplete(),
                        this.completeAnimation()
                    }
                }),
                this.resumingFrom && (this.resumingFrom.currentAnimation = this.currentAnimation),
                this.pendingAnimation = void 0
            }
            )
        }
        completeAnimation() {
            this.resumingFrom && (this.resumingFrom.currentAnimation = void 0,
            this.resumingFrom.preserveOpacity = void 0);
            const u = this.getStack();
            u && u.exitAnimationComplete(),
            this.resumingFrom = this.currentAnimation = this.animationValues = void 0,
            this.notifyListeners("animationComplete")
        }
        finishAnimation() {
            this.currentAnimation && (this.mixTargetDelta && this.mixTargetDelta(T0),
            this.currentAnimation.stop()),
            this.completeAnimation()
        }
        applyTransformsToTarget() {
            const u = this.getLead();
            let {targetWithTransforms: c, target: f, layout: h, latestValues: m} = u;
            if (!(!c || !f || !h)) {
                if (this !== u && this.layout && h && K1(this.options.animationType, this.layout.layoutBox, h.layoutBox)) {
                    f = this.target || yt();
                    const v = vn(this.layout.layoutBox.x);
                    f.x.min = u.target.x.min,
                    f.x.max = f.x.min + v;
                    const x = vn(this.layout.layoutBox.y);
                    f.y.min = u.target.y.min,
                    f.y.max = f.y.min + x
                }
                Cn(c, f),
                Hi(c, m),
                xa(this.projectionDeltaWithTransform, this.layoutCorrected, c, m)
            }
        }
        registerSharedNode(u, c) {
            this.sharedNodes.has(u) || this.sharedNodes.set(u, new OL),
            this.sharedNodes.get(u).add(c);
            const h = c.options.initialPromotionConfig;
            c.promote({
                transition: h ? h.transition : void 0,
                preserveFollowOpacity: h && h.shouldPreserveFollowOpacity ? h.shouldPreserveFollowOpacity(c) : void 0
            })
        }
        isLead() {
            const u = this.getStack();
            return u ? u.lead === this : !0
        }
        getLead() {
            var u;
            const {layoutId: c} = this.options;
            return c ? ((u = this.getStack()) === null || u === void 0 ? void 0 : u.lead) || this : this
        }
        getPrevLead() {
            var u;
            const {layoutId: c} = this.options;
            return c ? (u = this.getStack()) === null || u === void 0 ? void 0 : u.prevLead : void 0
        }
        getStack() {
            const {layoutId: u} = this.options;
            if (u)
                return this.root.sharedNodes.get(u)
        }
        promote({needsReset: u, transition: c, preserveFollowOpacity: f}={}) {
            const h = this.getStack();
            h && h.promote(this, f),
            u && (this.projectionDelta = void 0,
            this.needsReset = !0),
            c && this.setOptions({
                transition: c
            })
        }
        relegate() {
            const u = this.getStack();
            return u ? u.relegate(this) : !1
        }
        resetSkewAndRotation() {
            const {visualElement: u} = this.options;
            if (!u)
                return;
            let c = !1;
            const {latestValues: f} = u;
            if ((f.z || f.rotate || f.rotateX || f.rotateY || f.rotateZ || f.skewX || f.skewY) && (c = !0),
            !c)
                return;
            const h = {};
            f.z && ah("z", u, h, this.animationValues);
            for (let m = 0; m < oh.length; m++)
                ah(`rotate${oh[m]}`, u, h, this.animationValues),
                ah(`skew${oh[m]}`, u, h, this.animationValues);
            u.render();
            for (const m in h)
                u.setStaticValue(m, h[m]),
                this.animationValues && (this.animationValues[m] = h[m]);
            u.scheduleRender()
        }
        getProjectionStyles(u) {
            var c, f;
            if (!this.instance || this.isSVG)
                return;
            if (!this.isVisible)
                return IL;
            const h = {
                visibility: ""
            }
              , m = this.getTransformTemplate();
            if (this.needsReset)
                return this.needsReset = !1,
                h.opacity = "",
                h.pointerEvents = ku(u?.pointerEvents) || "",
                h.transform = m ? m(this.latestValues, "") : "none",
                h;
            const v = this.getLead();
            if (!this.projectionDelta || !this.layout || !v.target) {
                const S = {};
                return this.options.layoutId && (S.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1,
                S.pointerEvents = ku(u?.pointerEvents) || ""),
                this.hasProjected && !Vs(this.latestValues) && (S.transform = m ? m({}, "") : "none",
                this.hasProjected = !1),
                S
            }
            const x = v.animationValues || v.latestValues;
            this.applyTransformsToTarget(),
            h.transform = ML(this.projectionDeltaWithTransform, this.treeScale, x),
            m && (h.transform = m(x, h.transform));
            const {x: T, y: C} = this.projectionDelta;
            h.transformOrigin = `${T.origin * 100}% ${C.origin * 100}% 0`,
            v.animationValues ? h.opacity = v === this ? (f = (c = x.opacity) !== null && c !== void 0 ? c : this.latestValues.opacity) !== null && f !== void 0 ? f : 1 : this.preserveOpacity ? this.latestValues.opacity : x.opacityExit : h.opacity = v === this ? x.opacity !== void 0 ? x.opacity : "" : x.opacityExit !== void 0 ? x.opacityExit : 0;
            for (const S in Yu) {
                if (x[S] === void 0)
                    continue;
                const {correct: P, applyTo: _} = Yu[S]
                  , k = h.transform === "none" ? x[S] : P(x[S], v);
                if (_) {
                    const j = _.length;
                    for (let M = 0; M < j; M++)
                        h[_[M]] = k
                } else
                    h[S] = k
            }
            return this.options.layoutId && (h.pointerEvents = v === this ? ku(u?.pointerEvents) || "" : "none"),
            h
        }
        clearSnapshot() {
            this.resumeFrom = this.snapshot = void 0
        }
        resetTree() {
            this.root.nodes.forEach(u => {
                var c;
                return (c = u.currentAnimation) === null || c === void 0 ? void 0 : c.stop()
            }
            ),
            this.root.nodes.forEach(P0),
            this.root.sharedNodes.clear()
        }
    }
}
function LL(e) {
    e.updateLayout()
}
function VL(e) {
    var t;
    const n = ((t = e.resumeFrom) === null || t === void 0 ? void 0 : t.snapshot) || e.snapshot;
    if (e.isLead() && e.layout && n && e.hasListeners("didUpdate")) {
        const {layoutBox: s, measuredBox: o} = e.layout
          , {animationType: a} = e.options
          , u = n.source !== e.layout.source;
        a === "size" ? En(v => {
            const x = u ? n.measuredBox[v] : n.layoutBox[v]
              , T = vn(x);
            x.min = s[v].min,
            x.max = x.min + T
        }
        ) : K1(a, n.layoutBox, s) && En(v => {
            const x = u ? n.measuredBox[v] : n.layoutBox[v]
              , T = vn(s[v]);
            x.max = x.min + T,
            e.relativeTarget && !e.currentAnimation && (e.isProjectionDirty = !0,
            e.relativeTarget[v].max = e.relativeTarget[v].min + T)
        }
        );
        const c = $i();
        xa(c, s, n.layoutBox);
        const f = $i();
        u ? xa(f, e.applyTransform(o, !0), n.measuredBox) : xa(f, s, n.layoutBox);
        const h = !W1(c);
        let m = !1;
        if (!e.resumeFrom) {
            const v = e.getClosestProjectingParent();
            if (v && !v.resumeFrom) {
                const {snapshot: x, layout: T} = v;
                if (x && T) {
                    const C = yt();
                    wa(C, n.layoutBox, x.layoutBox);
                    const S = yt();
                    wa(S, s, T.layoutBox),
                    H1(C, S) || (m = !0),
                    v.options.layoutRoot && (e.relativeTarget = S,
                    e.relativeTargetOrigin = C,
                    e.relativeParent = v)
                }
            }
        }
        e.notifyListeners("didUpdate", {
            layout: s,
            snapshot: n,
            delta: f,
            layoutDelta: c,
            hasLayoutChanged: h,
            hasRelativeTargetChanged: m
        })
    } else if (e.isLead()) {
        const {onExitComplete: s} = e.options;
        s && s()
    }
    e.options.transition = void 0
}
function BL(e) {
    ha && Bs.totalNodes++,
    e.parent && (e.isProjecting() || (e.isProjectionDirty = e.parent.isProjectionDirty),
    e.isSharedProjectionDirty || (e.isSharedProjectionDirty = !!(e.isProjectionDirty || e.parent.isProjectionDirty || e.parent.isSharedProjectionDirty)),
    e.isTransformDirty || (e.isTransformDirty = e.parent.isTransformDirty))
}
function zL(e) {
    e.isProjectionDirty = e.isSharedProjectionDirty = e.isTransformDirty = !1
}
function UL(e) {
    e.clearSnapshot()
}
function P0(e) {
    e.clearMeasurements()
}
function $L(e) {
    e.isLayoutDirty = !1
}
function WL(e) {
    const {visualElement: t} = e.options;
    t && t.getProps().onBeforeLayoutMeasure && t.notify("BeforeLayoutMeasure"),
    e.resetTransform()
}
function C0(e) {
    e.finishAnimation(),
    e.targetDelta = e.relativeTarget = e.target = void 0,
    e.isProjectionDirty = !0
}
function HL(e) {
    e.resolveTargetDelta()
}
function qL(e) {
    e.calcProjection()
}
function QL(e) {
    e.resetSkewAndRotation()
}
function KL(e) {
    e.removeLeadSnapshot()
}
function E0(e, t, n) {
    e.translate = dt(t.translate, 0, n),
    e.scale = dt(t.scale, 1, n),
    e.origin = t.origin,
    e.originPoint = t.originPoint
}
function _0(e, t, n, s) {
    e.min = dt(t.min, n.min, s),
    e.max = dt(t.max, n.max, s)
}
function GL(e, t, n, s) {
    _0(e.x, t.x, n.x, s),
    _0(e.y, t.y, n.y, s)
}
function ZL(e) {
    return e.animationValues && e.animationValues.opacityExit !== void 0
}
const YL = {
    duration: .45,
    ease: [.4, 0, .1, 1]
}
  , k0 = e => typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().includes(e)
  , N0 = k0("applewebkit/") && !k0("chrome/") ? Math.round : gn;
function A0(e) {
    e.min = N0(e.min),
    e.max = N0(e.max)
}
function XL(e) {
    A0(e.x),
    A0(e.y)
}
function K1(e, t, n) {
    return e === "position" || e === "preserve-aspect" && !tL(b0(t), b0(n), .2)
}
function JL(e) {
    var t;
    return e !== e.root && ((t = e.scroll) === null || t === void 0 ? void 0 : t.wasRoot)
}
const eV = Q1({
    attachResizeListener: (e, t) => Qa(e, "resize", t),
    measureScroll: () => ({
        x: document.documentElement.scrollLeft || document.body.scrollLeft,
        y: document.documentElement.scrollTop || document.body.scrollTop
    }),
    checkIsScrollRoot: () => !0
})
  , lh = {
    current: void 0
}
  , G1 = Q1({
    measureScroll: e => ({
        x: e.scrollLeft,
        y: e.scrollTop
    }),
    defaultParent: () => {
        if (!lh.current) {
            const e = new eV({});
            e.mount(window),
            e.setOptions({
                layoutScroll: !0
            }),
            lh.current = e
        }
        return lh.current
    }
    ,
    resetTransform: (e, t) => {
        e.style.transform = t !== void 0 ? t : "none"
    }
    ,
    checkIsScrollRoot: e => window.getComputedStyle(e).position === "fixed"
})
  , tV = {
    pan: {
        Feature: yL
    },
    drag: {
        Feature: gL,
        ProjectionNode: G1,
        MeasureLayout: z1
    }
};
function R0(e, t, n) {
    const {props: s} = e;
    e.animationState && s.whileHover && e.animationState.setActive("whileHover", n === "Start");
    const o = "onHover" + n
      , a = s[o];
    a && it.postRender( () => a(t, tl(t)))
}
class nV extends bs {
    mount() {
        const {current: t} = this.node;
        t && (this.unmount = tI(t, n => (R0(this.node, n, "Start"),
        s => R0(this.node, s, "End"))))
    }
    unmount() {}
}
class rV extends bs {
    constructor() {
        super(...arguments),
        this.isActive = !1
    }
    onFocus() {
        let t = !1;
        try {
            t = this.node.current.matches(":focus-visible")
        } catch {
            t = !0
        }
        !t || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !0),
        this.isActive = !0)
    }
    onBlur() {
        !this.isActive || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !1),
        this.isActive = !1)
    }
    mount() {
        this.unmount = el(Qa(this.node.current, "focus", () => this.onFocus()), Qa(this.node.current, "blur", () => this.onBlur()))
    }
    unmount() {}
}
function j0(e, t, n) {
    const {props: s} = e;
    e.animationState && s.whileTap && e.animationState.setActive("whileTap", n === "Start");
    const o = "onTap" + (n === "End" ? "" : n)
      , a = s[o];
    a && it.postRender( () => a(t, tl(t)))
}
class sV extends bs {
    mount() {
        const {current: t} = this.node;
        t && (this.unmount = iI(t, n => (j0(this.node, n, "Start"),
        (s, {success: o}) => j0(this.node, s, o ? "End" : "Cancel")), {
            useGlobalTarget: this.node.props.globalTapTarget
        }))
    }
    unmount() {}
}
const rp = new WeakMap
  , uh = new WeakMap
  , iV = e => {
    const t = rp.get(e.target);
    t && t(e)
}
  , oV = e => {
    e.forEach(iV)
}
;
function aV({root: e, ...t}) {
    const n = e || document;
    uh.has(n) || uh.set(n, {});
    const s = uh.get(n)
      , o = JSON.stringify(t);
    return s[o] || (s[o] = new IntersectionObserver(oV,{
        root: e,
        ...t
    })),
    s[o]
}
function lV(e, t, n) {
    const s = aV(t);
    return rp.set(e, n),
    s.observe(e),
    () => {
        rp.delete(e),
        s.unobserve(e)
    }
}
const uV = {
    some: 0,
    all: 1
};
class cV extends bs {
    constructor() {
        super(...arguments),
        this.hasEnteredView = !1,
        this.isInView = !1
    }
    startObserver() {
        this.unmount();
        const {viewport: t={}} = this.node.getProps()
          , {root: n, margin: s, amount: o="some", once: a} = t
          , u = {
            root: n ? n.current : void 0,
            rootMargin: s,
            threshold: typeof o == "number" ? o : uV[o]
        }
          , c = f => {
            const {isIntersecting: h} = f;
            if (this.isInView === h || (this.isInView = h,
            a && !h && this.hasEnteredView))
                return;
            h && (this.hasEnteredView = !0),
            this.node.animationState && this.node.animationState.setActive("whileInView", h);
            const {onViewportEnter: m, onViewportLeave: v} = this.node.getProps()
              , x = h ? m : v;
            x && x(f)
        }
        ;
        return lV(this.node.current, u, c)
    }
    mount() {
        this.startObserver()
    }
    update() {
        if (typeof IntersectionObserver > "u")
            return;
        const {props: t, prevProps: n} = this.node;
        ["amount", "margin", "root"].some(dV(t, n)) && this.startObserver()
    }
    unmount() {}
}
function dV({viewport: e={}}, {viewport: t={}}={}) {
    return n => e[n] !== t[n]
}
const fV = {
    inView: {
        Feature: cV
    },
    tap: {
        Feature: sV
    },
    focus: {
        Feature: rV
    },
    hover: {
        Feature: nV
    }
}
  , hV = {
    layout: {
        ProjectionNode: G1,
        MeasureLayout: z1
    }
}
  , sp = {
    current: null
}
  , Z1 = {
    current: !1
};
function pV() {
    if (Z1.current = !0,
    !!Bp)
        if (window.matchMedia) {
            const e = window.matchMedia("(prefers-reduced-motion)")
              , t = () => sp.current = e.matches;
            e.addListener(t),
            t()
        } else
            sp.current = !1
}
const mV = [...b1, Ut, ws]
  , gV = e => mV.find(w1(e))
  , D0 = new WeakMap;
function yV(e, t, n) {
    for (const s in t) {
        const o = t[s]
          , a = n[s];
        if (Wt(o))
            e.addValue(s, o);
        else if (Wt(a))
            e.addValue(s, Ha(o, {
                owner: e
            }));
        else if (a !== o)
            if (e.hasValue(s)) {
                const u = e.getValue(s);
                u.liveStyle === !0 ? u.jump(o) : u.hasAnimated || u.set(o)
            } else {
                const u = e.getStaticValue(s);
                e.addValue(s, Ha(u !== void 0 ? u : o, {
                    owner: e
                }))
            }
    }
    for (const s in n)
        t[s] === void 0 && e.removeValue(s);
    return t
}
const O0 = ["AnimationStart", "AnimationComplete", "Update", "BeforeLayoutMeasure", "LayoutMeasure", "LayoutAnimationStart", "LayoutAnimationComplete"];
class vV {
    scrapeMotionValuesFromProps(t, n, s) {
        return {}
    }
    constructor({parent: t, props: n, presenceContext: s, reducedMotionConfig: o, blockInitialAnimation: a, visualState: u}, c={}) {
        this.current = null,
        this.children = new Set,
        this.isVariantNode = !1,
        this.isControllingVariants = !1,
        this.shouldReduceMotion = null,
        this.values = new Map,
        this.KeyframeResolver = hm,
        this.features = {},
        this.valueSubscriptions = new Map,
        this.prevMotionValues = {},
        this.events = {},
        this.propEventSubscriptions = {},
        this.notifyUpdate = () => this.notify("Update", this.latestValues),
        this.render = () => {
            this.current && (this.triggerBuild(),
            this.renderInstance(this.current, this.renderState, this.props.style, this.projection))
        }
        ,
        this.renderScheduledAt = 0,
        this.scheduleRender = () => {
            const T = ur.now();
            this.renderScheduledAt < T && (this.renderScheduledAt = T,
            it.render(this.render, !1, !0))
        }
        ;
        const {latestValues: f, renderState: h, onUpdate: m} = u;
        this.onUpdate = m,
        this.latestValues = f,
        this.baseTarget = {
            ...f
        },
        this.initialValues = n.initial ? {
            ...f
        } : {},
        this.renderState = h,
        this.parent = t,
        this.props = n,
        this.presenceContext = s,
        this.depth = t ? t.depth + 1 : 0,
        this.reducedMotionConfig = o,
        this.options = c,
        this.blockInitialAnimation = !!a,
        this.isControllingVariants = Dc(n),
        this.isVariantNode = NS(n),
        this.isVariantNode && (this.variantChildren = new Set),
        this.manuallyAnimateOnMount = !!(t && t.current);
        const {willChange: v, ...x} = this.scrapeMotionValuesFromProps(n, {}, this);
        for (const T in x) {
            const C = x[T];
            f[T] !== void 0 && Wt(C) && C.set(f[T], !1)
        }
    }
    mount(t) {
        this.current = t,
        D0.set(t, this),
        this.projection && !this.projection.instance && this.projection.mount(t),
        this.parent && this.isVariantNode && !this.isControllingVariants && (this.removeFromVariantTree = this.parent.addVariantChild(this)),
        this.values.forEach( (n, s) => this.bindToMotionValue(s, n)),
        Z1.current || pV(),
        this.shouldReduceMotion = this.reducedMotionConfig === "never" ? !1 : this.reducedMotionConfig === "always" ? !0 : sp.current,
        this.parent && this.parent.children.add(this),
        this.update(this.props, this.presenceContext)
    }
    unmount() {
        D0.delete(this.current),
        this.projection && this.projection.unmount(),
        xs(this.notifyUpdate),
        xs(this.render),
        this.valueSubscriptions.forEach(t => t()),
        this.valueSubscriptions.clear(),
        this.removeFromVariantTree && this.removeFromVariantTree(),
        this.parent && this.parent.children.delete(this);
        for (const t in this.events)
            this.events[t].clear();
        for (const t in this.features) {
            const n = this.features[t];
            n && (n.unmount(),
            n.isMounted = !1)
        }
        this.current = null
    }
    bindToMotionValue(t, n) {
        this.valueSubscriptions.has(t) && this.valueSubscriptions.get(t)();
        const s = ni.has(t)
          , o = n.on("change", c => {
            this.latestValues[t] = c,
            this.props.onUpdate && it.preRender(this.notifyUpdate),
            s && this.projection && (this.projection.isTransformDirty = !0)
        }
        )
          , a = n.on("renderRequest", this.scheduleRender);
        let u;
        window.MotionCheckAppearSync && (u = window.MotionCheckAppearSync(this, t, n)),
        this.valueSubscriptions.set(t, () => {
            o(),
            a(),
            u && u(),
            n.owner && n.stop()
        }
        )
    }
    sortNodePosition(t) {
        return !this.current || !this.sortInstanceNodePosition || this.type !== t.type ? 0 : this.sortInstanceNodePosition(this.current, t.current)
    }
    updateFeatures() {
        let t = "animation";
        for (t in io) {
            const n = io[t];
            if (!n)
                continue;
            const {isEnabled: s, Feature: o} = n;
            if (!this.features[t] && o && s(this.props) && (this.features[t] = new o(this)),
            this.features[t]) {
                const a = this.features[t];
                a.isMounted ? a.update() : (a.mount(),
                a.isMounted = !0)
            }
        }
    }
    triggerBuild() {
        this.build(this.renderState, this.latestValues, this.props)
    }
    measureViewportBox() {
        return this.current ? this.measureInstanceViewportBox(this.current, this.props) : yt()
    }
    getStaticValue(t) {
        return this.latestValues[t]
    }
    setStaticValue(t, n) {
        this.latestValues[t] = n
    }
    update(t, n) {
        (t.transformTemplate || this.props.transformTemplate) && this.scheduleRender(),
        this.prevProps = this.props,
        this.props = t,
        this.prevPresenceContext = this.presenceContext,
        this.presenceContext = n;
        for (let s = 0; s < O0.length; s++) {
            const o = O0[s];
            this.propEventSubscriptions[o] && (this.propEventSubscriptions[o](),
            delete this.propEventSubscriptions[o]);
            const a = "on" + o
              , u = t[a];
            u && (this.propEventSubscriptions[o] = this.on(o, u))
        }
        this.prevMotionValues = yV(this, this.scrapeMotionValuesFromProps(t, this.prevProps, this), this.prevMotionValues),
        this.handleChildMotionValue && this.handleChildMotionValue(),
        this.onUpdate && this.onUpdate(this)
    }
    getProps() {
        return this.props
    }
    getVariant(t) {
        return this.props.variants ? this.props.variants[t] : void 0
    }
    getDefaultTransition() {
        return this.props.transition
    }
    getTransformPagePoint() {
        return this.props.transformPagePoint
    }
    getClosestVariantNode() {
        return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0
    }
    addVariantChild(t) {
        const n = this.getClosestVariantNode();
        if (n)
            return n.variantChildren && n.variantChildren.add(t),
            () => n.variantChildren.delete(t)
    }
    addValue(t, n) {
        const s = this.values.get(t);
        n !== s && (s && this.removeValue(t),
        this.bindToMotionValue(t, n),
        this.values.set(t, n),
        this.latestValues[t] = n.get())
    }
    removeValue(t) {
        this.values.delete(t);
        const n = this.valueSubscriptions.get(t);
        n && (n(),
        this.valueSubscriptions.delete(t)),
        delete this.latestValues[t],
        this.removeValueFromRenderState(t, this.renderState)
    }
    hasValue(t) {
        return this.values.has(t)
    }
    getValue(t, n) {
        if (this.props.values && this.props.values[t])
            return this.props.values[t];
        let s = this.values.get(t);
        return s === void 0 && n !== void 0 && (s = Ha(n === null ? void 0 : n, {
            owner: this
        }),
        this.addValue(t, s)),
        s
    }
    readValue(t, n) {
        var s;
        let o = this.latestValues[t] !== void 0 || !this.current ? this.latestValues[t] : (s = this.getBaseTargetFromProps(this.props, t)) !== null && s !== void 0 ? s : this.readValueFromInstance(this.current, t, this.options);
        return o != null && (typeof o == "string" && (v1(o) || u1(o)) ? o = parseFloat(o) : !gV(o) && ws.test(n) && (o = m1(t, n)),
        this.setBaseTarget(t, Wt(o) ? o.get() : o)),
        Wt(o) ? o.get() : o
    }
    setBaseTarget(t, n) {
        this.baseTarget[t] = n
    }
    getBaseTarget(t) {
        var n;
        const {initial: s} = this.props;
        let o;
        if (typeof s == "string" || typeof s == "object") {
            const u = Qp(this.props, s, (n = this.presenceContext) === null || n === void 0 ? void 0 : n.custom);
            u && (o = u[t])
        }
        if (s && o !== void 0)
            return o;
        const a = this.getBaseTargetFromProps(this.props, t);
        return a !== void 0 && !Wt(a) ? a : this.initialValues[t] !== void 0 && o === void 0 ? void 0 : this.baseTarget[t]
    }
    on(t, n) {
        return this.events[t] || (this.events[t] = new am),
        this.events[t].add(n)
    }
    notify(t, ...n) {
        this.events[t] && this.events[t].notify(...n)
    }
}
class Y1 extends vV {
    constructor() {
        super(...arguments),
        this.KeyframeResolver = S1
    }
    sortInstanceNodePosition(t, n) {
        return t.compareDocumentPosition(n) & 2 ? 1 : -1
    }
    getBaseTargetFromProps(t, n) {
        return t.style ? t.style[n] : void 0
    }
    removeValueFromRenderState(t, {vars: n, style: s}) {
        delete n[t],
        delete s[t]
    }
    handleChildMotionValue() {
        this.childSubscription && (this.childSubscription(),
        delete this.childSubscription);
        const {children: t} = this.props;
        Wt(t) && (this.childSubscription = t.on("change", n => {
            this.current && (this.current.textContent = `${n}`)
        }
        ))
    }
}
function xV(e) {
    return window.getComputedStyle(e)
}
class wV extends Y1 {
    constructor() {
        super(...arguments),
        this.type = "html",
        this.renderInstance = LS
    }
    readValueFromInstance(t, n) {
        if (ni.has(n)) {
            const s = fm(n);
            return s && s.default || 0
        } else {
            const s = xV(t)
              , o = (MS(n) ? s.getPropertyValue(n) : s[n]) || 0;
            return typeof o == "string" ? o.trim() : o
        }
    }
    measureInstanceViewportBox(t, {transformPagePoint: n}) {
        return V1(t, n)
    }
    build(t, n, s) {
        Zp(t, n, s.transformTemplate)
    }
    scrapeMotionValuesFromProps(t, n, s) {
        return em(t, n, s)
    }
}
class bV extends Y1 {
    constructor() {
        super(...arguments),
        this.type = "svg",
        this.isSVGTag = !1,
        this.measureInstanceViewportBox = yt
    }
    getBaseTargetFromProps(t, n) {
        return t[n]
    }
    readValueFromInstance(t, n) {
        if (ni.has(n)) {
            const s = fm(n);
            return s && s.default || 0
        }
        return n = VS.has(n) ? n : Wp(n),
        t.getAttribute(n)
    }
    scrapeMotionValuesFromProps(t, n, s) {
        return US(t, n, s)
    }
    build(t, n, s) {
        Yp(t, n, this.isSVGTag, s.transformTemplate)
    }
    renderInstance(t, n, s, o) {
        BS(t, n, s, o)
    }
    mount(t) {
        this.isSVGTag = Jp(t.tagName),
        super.mount(t)
    }
}
const SV = (e, t) => qp(e) ? new bV(t) : new wV(t,{
    allowProjection: e !== w.Fragment
})
  , TV = K2({
    ...qF,
    ...fV,
    ...tV,
    ...hV
}, SV)
  , Ss = u2(TV)
  , PV = vc("whitespace-nowrap inline-flex items-center rounded-md border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 hover-elevate ", {
    variants: {
        variant: {
            default: "border-transparent bg-primary text-primary-foreground shadow-xs",
            secondary: "border-transparent bg-secondary text-secondary-foreground",
            destructive: "border-transparent bg-destructive text-destructive-foreground shadow-xs",
            outline: " border [border-color:var(--badge-outline)] shadow-xs"
        }
    },
    defaultVariants: {
        variant: "default"
    }
});
function Ru({className: e, variant: t, ...n}) {
    return y.jsx("div", {
        className: Ge(PV({
            variant: t
        }), e),
        ...n
    })
}
function X1({tournament: e}) {
    const t = {
        upcoming: "bg-green-500 text-black border-green-400",
        ongoing: "bg-red-500 text-white animate-pulse border-red-400",
        completed: "bg-slate-600 text-slate-200 border-slate-500"
    }
      , n = {
        upcoming: "Registration Open",
        ongoing: "Live Now",
        completed: "Completed"
    };
    return y.jsx(dn, {
        href: `/tournaments/${e.id}`,
        children: y.jsxs(Ss.div, {
            whileHover: {
                y: -8,
                scale: 1.02
            },
            className: "group relative h-full bg-card border border-border/50 rounded-3xl overflow-hidden cursor-pointer shadow-xl shadow-black/20 hover:border-primary/50 transition-all duration-300",
            children: [y.jsxs("div", {
                className: "relative h-48 bg-muted overflow-hidden",
                children: [y.jsx("div", {
                    className: "absolute inset-0 bg-gradient-to-t from-card via-card/20 to-transparent z-10"
                }), y.jsx("div", {
                    className: "absolute top-4 right-4 z-20",
                    children: y.jsx(Ru, {
                        className: `${t[e.status]} font-display tracking-wider border-2 shadow-lg`,
                        children: n[e.status]
                    })
                }), y.jsx("img", {
                    src: e.imageUrl || "https://images.unsplash.com/photo-1542751371-adc38448a05e?w=800&q=80",
                    alt: e.title,
                    className: "w-full h-full object-cover transform group-hover:scale-110 transition-transform duration-700"
                })]
            }), y.jsxs("div", {
                className: "p-6 relative z-20 -mt-6",
                children: [y.jsx("h3", {
                    className: "text-2xl font-display text-white mb-2 leading-tight group-hover:text-primary transition-colors",
                    children: e.title
                }), y.jsxs("div", {
                    className: "space-y-3 mt-4",
                    children: [y.jsxs("div", {
                        className: "flex items-center gap-3 text-muted-foreground group-hover:text-white transition-colors",
                        children: [y.jsx(nb, {
                            className: "w-5 h-5 text-accent"
                        }), y.jsx("span", {
                            className: "font-medium",
                            children: SS(new Date(e.date), "MMM d, yyyy • h:mm a")
                        })]
                    }), y.jsxs("div", {
                        className: "flex items-center gap-3 text-muted-foreground group-hover:text-white transition-colors",
                        children: [y.jsx(ir, {
                            className: "w-5 h-5 text-accent"
                        }), y.jsxs("span", {
                            className: "font-medium text-accent",
                            children: [e.prizePool, " Prize Pool"]
                        })]
                    }), y.jsxs("div", {
                        className: "flex items-center gap-3 text-muted-foreground group-hover:text-white transition-colors",
                        children: [y.jsx(sb, {
                            className: "w-5 h-5 text-accent"
                        }), y.jsxs("span", {
                            className: "font-medium",
                            children: [e.maxTeams, " Teams Max"]
                        })]
                    })]
                }), y.jsxs("div", {
                    className: "mt-6 pt-4 border-t border-white/5 flex items-center justify-between",
                    children: [y.jsx("span", {
                        className: "text-sm font-medium text-muted-foreground",
                        children: e.game
                    }), y.jsx("div", {
                        className: "w-10 h-10 rounded-full bg-white/5 flex items-center justify-center group-hover:bg-primary group-hover:text-black transition-colors",
                        children: y.jsx(Nh, {
                            className: "w-5 h-5"
                        })
                    })]
                })]
            })]
        })
    })
}
async function CV() {
    const e = await fetch("/api/auth/user", {
        credentials: "include"
    });
    if (e.status === 401)
        return null;
    if (!e.ok)
        throw new Error(`${e.status}: ${e.statusText}`);
    return e.json()
}
async function EV() {
    window.location.href = "/api/logout"
}
function J1() {
    const e = uo()
      , {data: t, isLoading: n} = cc({
        queryKey: ["/api/auth/user"],
        queryFn: CV,
        retry: !1,
        staleTime: 1e3 * 60 * 5
    })
      , s = dc({
        mutationFn: EV,
        onSuccess: () => {
            e.setQueryData(["/api/auth/user"], null)
        }
    });
    return {
        user: t,
        isLoading: n,
        isAuthenticated: !!t,
        logout: s.mutate,
        isLoggingOut: s.isPending
    }
}
const _V = vc("inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0 hover-elevate active-elevate-2", {
    variants: {
        variant: {
            default: "bg-primary text-primary-foreground border border-primary-border",
            destructive: "bg-destructive text-destructive-foreground border border-destructive-border",
            outline: " border [border-color:var(--button-outline)]  shadow-xs active:shadow-none ",
            secondary: "border bg-secondary text-secondary-foreground border border-secondary-border ",
            ghost: "border border-transparent"
        },
        size: {
            default: "min-h-9 px-4 py-2",
            sm: "min-h-8 rounded-md px-3 text-xs",
            lg: "min-h-10 rounded-md px-8",
            icon: "h-9 w-9"
        }
    },
    defaultVariants: {
        variant: "default",
        size: "default"
    }
})
  , jt = w.forwardRef( ({className: e, variant: t, size: n, asChild: s=!1, ...o}, a) => {
    const u = s ? _w : "button";
    return y.jsx(u, {
        className: Ge(_V({
            variant: t,
            size: n,
            className: e
        })),
        ref: a,
        ...o
    })
}
);
jt.displayName = "Button";
function hr() {
    const [e] = cp()
      , {user: t, isLoading: n} = J1()
      , [s,o] = w.useState(!1)
      , a = [{
        href: "/tournaments",
        label: "Tournaments",
        icon: ir
    }, {
        href: "/winners",
        label: "Winners Teams",
        icon: ir
    }, {
        href: "/partners",
        label: "Partners",
        icon: ir
    }, {
        href: "/about",
        label: "About Us",
        icon: Ah
    }, {
        href: "/organization",
        label: "Organization",
        icon: Ah
    }];
    return y.jsxs("nav", {
        className: "sticky top-0 z-50 w-full border-b border-white/10 bg-background/80 backdrop-blur-md",
        children: [y.jsxs("div", {
            className: "container mx-auto px-4 h-20 flex items-center justify-between",
            children: [y.jsxs(dn, {
                href: "/",
                className: "flex items-center gap-3 group",
                children: [y.jsx("div", {
                    className: "w-12 h-12 flex items-center justify-center transition-transform duration-300 group-hover:scale-110",
                    children: y.jsx("span", {
                        className: "font-display text-3xl text-primary drop-shadow-[0_2px_4px_rgba(0,0,0,0.5)]",
                        children: "YF7"
                    })
                }), y.jsx("span", {
                    className: "font-display text-2xl tracking-wider text-white group-hover:text-primary transition-colors",
                    children: "TOURNAMENTS"
                })]
            }), y.jsxs("div", {
                className: "hidden md:flex items-center gap-8",
                children: [y.jsx(dn, {
                    href: "/",
                    children: y.jsxs("div", {
                        className: `
              flex items-center gap-2 font-medium text-lg cursor-pointer transition-colors
              ${e === "/" ? "text-primary" : "text-muted-foreground hover:text-white"}
            `,
                        children: [y.jsx(qv, {
                            className: "w-5 h-5"
                        }), y.jsx("span", {
                            children: "Home"
                        })]
                    })
                }), a.map(u => y.jsx(dn, {
                    href: u.href,
                    children: y.jsxs("div", {
                        className: `
                flex items-center gap-2 font-medium text-lg cursor-pointer transition-colors
                ${e === u.href ? "text-primary" : "text-muted-foreground hover:text-white"}
              `,
                        children: [y.jsx(u.icon, {
                            className: "w-5 h-5"
                        }), y.jsx("span", {
                            children: u.label
                        })]
                    })
                }, u.href)), !n && t?.isAdmin && y.jsx(dn, {
                    href: "/admin",
                    children: y.jsx(jt, {
                        variant: "outline",
                        className: "border-accent text-accent hover:bg-accent hover:text-accent-foreground font-display tracking-wide",
                        children: "Admin Panel"
                    })
                })]
            }), y.jsx("button", {
                className: "md:hidden text-white",
                onClick: () => o(!s),
                children: s ? y.jsx(bp, {}) : y.jsx(Ok, {})
            })]
        }), y.jsx(t2, {
            children: s && y.jsx(Ss.div, {
                initial: {
                    height: 0,
                    opacity: 0
                },
                animate: {
                    height: "auto",
                    opacity: 1
                },
                exit: {
                    height: 0,
                    opacity: 0
                },
                className: "md:hidden overflow-hidden bg-card border-b border-white/10",
                children: y.jsxs("div", {
                    className: "p-4 flex flex-col gap-4",
                    children: [y.jsx(dn, {
                        href: "/",
                        children: y.jsxs("div", {
                            className: "flex items-center gap-3 p-3 rounded-lg hover:bg-white/5 text-white",
                            onClick: () => o(!1),
                            children: [y.jsx(qv, {
                                className: "w-5 h-5 text-primary"
                            }), y.jsx("span", {
                                className: "font-medium",
                                children: "Home"
                            })]
                        })
                    }), a.map(u => y.jsx(dn, {
                        href: u.href,
                        children: y.jsxs("div", {
                            className: "flex items-center gap-3 p-3 rounded-lg hover:bg-white/5 text-white",
                            onClick: () => o(!1),
                            children: [y.jsx(u.icon, {
                                className: "w-5 h-5 text-primary"
                            }), y.jsx("span", {
                                className: "font-medium",
                                children: u.label
                            })]
                        })
                    }, u.href))]
                })
            })
        })]
    })
}
function kV() {
    const {data: e, isLoading: t} = Ip("upcoming")
      , n = e?.[0];
    return y.jsxs("div", {
        className: "min-h-screen bg-background text-foreground overflow-x-hidden",
        children: [y.jsx(hr, {}), y.jsxs("section", {
            className: "relative pt-20 pb-32 md:pt-32 md:pb-48 px-4 overflow-hidden",
            children: [y.jsxs("div", {
                className: "absolute top-0 left-0 w-full h-full overflow-hidden pointer-events-none z-0",
                children: [y.jsx("div", {
                    className: "absolute top-[-10%] right-[-5%] w-[500px] h-[500px] bg-primary/10 rounded-full blur-[100px]"
                }), y.jsx("div", {
                    className: "absolute bottom-0 left-[-10%] w-[600px] h-[600px] bg-primary/5 rounded-full blur-[120px]"
                })]
            }), y.jsx("div", {
                className: "container mx-auto relative z-10 text-center",
                children: y.jsxs(Ss.div, {
                    initial: {
                        opacity: 0,
                        y: 30
                    },
                    animate: {
                        opacity: 1,
                        y: 0
                    },
                    transition: {
                        duration: .8,
                        ease: "easeOut"
                    },
                    children: [y.jsxs("div", {
                        className: "inline-flex items-center gap-2 px-4 py-2 rounded-full bg-white/5 border border-white/10 mb-8 backdrop-blur-sm",
                        children: [y.jsx(Ik, {
                            className: "w-4 h-4 text-accent"
                        }), y.jsx("span", {
                            className: "text-sm font-medium tracking-wide",
                            children: "The #1 Brawl Stars Tournament Platform"
                        })]
                    }), y.jsxs("h1", {
                        className: "text-5xl md:text-7xl lg:text-8xl font-display mb-6 leading-[0.9] text-white drop-shadow-2xl",
                        children: ["COMPETE FOR ", y.jsx("br", {}), y.jsx("span", {
                            className: "text-primary",
                            children: "GLORY"
                        })]
                    }), y.jsx("p", {
                        className: "text-xl md:text-2xl text-muted-foreground max-w-2xl mx-auto mb-10 leading-relaxed",
                        children: "Join the most exciting community tournaments. Rise through the ranks, win prizes, and become a legend."
                    }), y.jsxs("div", {
                        className: "flex flex-col sm:flex-row items-center justify-center gap-4",
                        children: [y.jsx(dn, {
                            href: "/tournaments",
                            children: y.jsx(jt, {
                                size: "lg",
                                className: "w-full sm:w-auto h-14 px-8 text-xl font-display bg-primary text-primary-foreground hover:bg-primary/90 shadow-lg shadow-primary/30 transition-all hover:scale-105",
                                children: "Browse Tournaments"
                            })
                        }), y.jsx(dn, {
                            href: "/rules",
                            children: y.jsx(jt, {
                                variant: "outline",
                                size: "lg",
                                className: "w-full sm:w-auto h-14 px-8 text-xl font-display border-white/20 hover:bg-white/10 transition-all",
                                children: "Read Rules"
                            })
                        })]
                    })]
                })
            })]
        }), t ? y.jsx("div", {
            className: "container mx-auto px-4 py-20 flex justify-center",
            children: y.jsx("div", {
                className: "w-12 h-12 border-4 border-primary border-t-transparent rounded-full animate-spin"
            })
        }) : n && y.jsx("section", {
            className: "container mx-auto px-4 -mt-20 relative z-20 mb-32",
            children: y.jsxs("div", {
                className: "bg-card/50 backdrop-blur-xl border border-white/10 rounded-[2.5rem] p-8 md:p-12 overflow-hidden relative group",
                children: [y.jsx("div", {
                    className: "absolute top-0 right-0 w-2/3 h-full bg-gradient-to-l from-black/80 to-transparent z-10 hidden md:block"
                }), y.jsx("img", {
                    src: n.imageUrl || "https://images.unsplash.com/photo-1542751371-adc38448a05e?w=1200&q=80",
                    alt: "Featured",
                    className: "absolute inset-0 w-full h-full object-cover opacity-60 group-hover:scale-105 transition-transform duration-1000"
                }), y.jsxs("div", {
                    className: "relative z-20 flex flex-col items-start gap-6 max-w-xl",
                    children: [y.jsxs("div", {
                        className: "flex gap-3",
                        children: [y.jsx("span", {
                            className: "px-4 py-1 rounded-full bg-accent text-accent-foreground font-bold text-sm tracking-wider uppercase",
                            children: "Featured Event"
                        }), y.jsx("span", {
                            className: "px-4 py-1 rounded-full bg-black/50 text-white font-bold text-sm tracking-wider uppercase backdrop-blur-md border border-white/10",
                            children: n.game
                        })]
                    }), y.jsx("h2", {
                        className: "text-4xl md:text-6xl font-display text-white drop-shadow-lg",
                        children: n.title
                    }), y.jsx("p", {
                        className: "text-lg text-gray-200 line-clamp-3",
                        children: n.description
                    }), y.jsxs("div", {
                        className: "flex items-center gap-8 text-white/90",
                        children: [y.jsxs("div", {
                            className: "flex items-center gap-2",
                            children: [y.jsx(ir, {
                                className: "w-6 h-6 text-accent"
                            }), y.jsx("span", {
                                className: "text-xl font-bold",
                                children: n.prizePool
                            })]
                        }), y.jsx("div", {
                            className: "w-px h-8 bg-white/20"
                        }), y.jsxs("div", {
                            className: "text-lg",
                            children: ["Starts ", new Date(n.date).toLocaleDateString()]
                        })]
                    }), y.jsx(dn, {
                        href: `/tournaments/${n.id}`,
                        children: y.jsxs(jt, {
                            className: "mt-4 bg-white text-black hover:bg-white/90 font-display text-lg px-8 py-6 rounded-xl",
                            children: ["Register Now ", y.jsx(Nh, {
                                className: "ml-2 w-5 h-5"
                            })]
                        })
                    })]
                })]
            })
        }), y.jsxs("section", {
            className: "container mx-auto px-4 pb-32",
            children: [y.jsxs("div", {
                className: "flex items-center justify-between mb-12",
                children: [y.jsxs("h2", {
                    className: "text-4xl md:text-5xl font-display text-white",
                    children: ["Upcoming ", y.jsx("span", {
                        className: "text-primary",
                        children: "Battles"
                    })]
                }), y.jsxs(dn, {
                    href: "/tournaments",
                    className: "hidden md:flex items-center gap-2 text-primary hover:text-primary/80 font-medium transition-colors",
                    children: ["View All ", y.jsx(Nh, {
                        className: "w-4 h-4"
                    })]
                })]
            }), y.jsxs("div", {
                className: "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-8",
                children: [e?.slice(1, 4).map(s => y.jsx(X1, {
                    tournament: s
                }, s.id)), (!e || e.length < 2) && y.jsx("div", {
                    className: "col-span-full text-center py-20 bg-card/30 rounded-3xl border border-white/5 border-dashed",
                    children: y.jsx("p", {
                        className: "text-muted-foreground text-xl",
                        children: "More tournaments coming soon!"
                    })
                })]
            }), y.jsx("div", {
                className: "mt-8 text-center md:hidden",
                children: y.jsx(dn, {
                    href: "/tournaments",
                    children: y.jsx(jt, {
                        variant: "outline",
                        className: "w-full",
                        children: "View All Tournaments"
                    })
                })
            })]
        })]
    })
}
var NV = w.createContext(void 0);
function eT(e) {
    const t = w.useContext(NV);
    return e || t || "ltr"
}
var ch = "rovingFocusGroup.onEntryFocus"
  , AV = {
    bubbles: !1,
    cancelable: !0
}
  , Ic = "RovingFocusGroup"
  , [ip,tT,RV] = Nw(Ic)
  , [jV,nT] = ei(Ic, [RV])
  , [DV,OV] = jV(Ic)
  , rT = w.forwardRef( (e, t) => y.jsx(ip.Provider, {
    scope: e.__scopeRovingFocusGroup,
    children: y.jsx(ip.Slot, {
        scope: e.__scopeRovingFocusGroup,
        children: y.jsx(MV, {
            ...e,
            ref: t
        })
    })
}));
rT.displayName = Ic;
var MV = w.forwardRef( (e, t) => {
    const {__scopeRovingFocusGroup: n, orientation: s, loop: o=!1, dir: a, currentTabStopId: u, defaultCurrentTabStopId: c, onCurrentTabStopIdChange: f, onEntryFocus: h, preventScrollOnEntryFocus: m=!1, ...v} = e
      , x = w.useRef(null)
      , T = qt(t, x)
      , C = eT(a)
      , [S=null,P] = pc({
        prop: u,
        defaultProp: c,
        onChange: f
    })
      , [_,k] = w.useState(!1)
      , j = yn(h)
      , M = tT(n)
      , O = w.useRef(!1)
      , [z,U] = w.useState(0);
    return w.useEffect( () => {
        const W = x.current;
        if (W)
            return W.addEventListener(ch, j),
            () => W.removeEventListener(ch, j)
    }
    , [j]),
    y.jsx(DV, {
        scope: n,
        orientation: s,
        dir: C,
        loop: o,
        currentTabStopId: S,
        onItemFocus: w.useCallback(W => P(W), [P]),
        onItemShiftTab: w.useCallback( () => k(!0), []),
        onFocusableItemAdd: w.useCallback( () => U(W => W + 1), []),
        onFocusableItemRemove: w.useCallback( () => U(W => W - 1), []),
        children: y.jsx(Xe.div, {
            tabIndex: _ || z === 0 ? -1 : 0,
            "data-orientation": s,
            ...v,
            ref: T,
            style: {
                outline: "none",
                ...e.style
            },
            onMouseDown: We(e.onMouseDown, () => {
                O.current = !0
            }
            ),
            onFocus: We(e.onFocus, W => {
                const oe = !O.current;
                if (W.target === W.currentTarget && oe && !_) {
                    const fe = new CustomEvent(ch,AV);
                    if (W.currentTarget.dispatchEvent(fe),
                    !fe.defaultPrevented) {
                        const we = M().filter(ce => ce.focusable)
                          , X = we.find(ce => ce.active)
                          , se = we.find(ce => ce.id === S)
                          , be = [X, se, ...we].filter(Boolean).map(ce => ce.ref.current);
                        oT(be, m)
                    }
                }
                O.current = !1
            }
            ),
            onBlur: We(e.onBlur, () => k(!1))
        })
    })
}
)
  , sT = "RovingFocusGroupItem"
  , iT = w.forwardRef( (e, t) => {
    const {__scopeRovingFocusGroup: n, focusable: s=!0, active: o=!1, tabStopId: a, ...u} = e
      , c = ga()
      , f = a || c
      , h = OV(sT, n)
      , m = h.currentTabStopId === f
      , v = tT(n)
      , {onFocusableItemAdd: x, onFocusableItemRemove: T} = h;
    return w.useEffect( () => {
        if (s)
            return x(),
            () => T()
    }
    , [s, x, T]),
    y.jsx(ip.ItemSlot, {
        scope: n,
        id: f,
        focusable: s,
        active: o,
        children: y.jsx(Xe.span, {
            tabIndex: m ? 0 : -1,
            "data-orientation": h.orientation,
            ...u,
            ref: t,
            onMouseDown: We(e.onMouseDown, C => {
                s ? h.onItemFocus(f) : C.preventDefault()
            }
            ),
            onFocus: We(e.onFocus, () => h.onItemFocus(f)),
            onKeyDown: We(e.onKeyDown, C => {
                if (C.key === "Tab" && C.shiftKey) {
                    h.onItemShiftTab();
                    return
                }
                if (C.target !== C.currentTarget)
                    return;
                const S = LV(C, h.orientation, h.dir);
                if (S !== void 0) {
                    if (C.metaKey || C.ctrlKey || C.altKey || C.shiftKey)
                        return;
                    C.preventDefault();
                    let _ = v().filter(k => k.focusable).map(k => k.ref.current);
                    if (S === "last")
                        _.reverse();
                    else if (S === "prev" || S === "next") {
                        S === "prev" && _.reverse();
                        const k = _.indexOf(C.currentTarget);
                        _ = h.loop ? VV(_, k + 1) : _.slice(k + 1)
                    }
                    setTimeout( () => oT(_))
                }
            }
            )
        })
    })
}
);
iT.displayName = sT;
var IV = {
    ArrowLeft: "prev",
    ArrowUp: "prev",
    ArrowRight: "next",
    ArrowDown: "next",
    PageUp: "first",
    Home: "first",
    PageDown: "last",
    End: "last"
};
function FV(e, t) {
    return t !== "rtl" ? e : e === "ArrowLeft" ? "ArrowRight" : e === "ArrowRight" ? "ArrowLeft" : e
}
function LV(e, t, n) {
    const s = FV(e.key, n);
    if (!(t === "vertical" && ["ArrowLeft", "ArrowRight"].includes(s)) && !(t === "horizontal" && ["ArrowUp", "ArrowDown"].includes(s)))
        return IV[s]
}
function oT(e, t=!1) {
    const n = document.activeElement;
    for (const s of e)
        if (s === n || (s.focus({
            preventScroll: t
        }),
        document.activeElement !== n))
            return
}
function VV(e, t) {
    return e.map( (n, s) => e[(t + s) % e.length])
}
var BV = rT
  , zV = iT
  , ym = "Tabs"
  , [UV] = ei(ym, [nT])
  , aT = nT()
  , [$V,vm] = UV(ym)
  , lT = w.forwardRef( (e, t) => {
    const {__scopeTabs: n, value: s, onValueChange: o, defaultValue: a, orientation: u="horizontal", dir: c, activationMode: f="automatic", ...h} = e
      , m = eT(c)
      , [v,x] = pc({
        prop: s,
        onChange: o,
        defaultProp: a
    });
    return y.jsx($V, {
        scope: n,
        baseId: ga(),
        value: v,
        onValueChange: x,
        orientation: u,
        dir: m,
        activationMode: f,
        children: y.jsx(Xe.div, {
            dir: m,
            "data-orientation": u,
            ...h,
            ref: t
        })
    })
}
);
lT.displayName = ym;
var uT = "TabsList"
  , cT = w.forwardRef( (e, t) => {
    const {__scopeTabs: n, loop: s=!0, ...o} = e
      , a = vm(uT, n)
      , u = aT(n);
    return y.jsx(BV, {
        asChild: !0,
        ...u,
        orientation: a.orientation,
        dir: a.dir,
        loop: s,
        children: y.jsx(Xe.div, {
            role: "tablist",
            "aria-orientation": a.orientation,
            ...o,
            ref: t
        })
    })
}
);
cT.displayName = uT;
var dT = "TabsTrigger"
  , fT = w.forwardRef( (e, t) => {
    const {__scopeTabs: n, value: s, disabled: o=!1, ...a} = e
      , u = vm(dT, n)
      , c = aT(n)
      , f = mT(u.baseId, s)
      , h = gT(u.baseId, s)
      , m = s === u.value;
    return y.jsx(zV, {
        asChild: !0,
        ...c,
        focusable: !o,
        active: m,
        children: y.jsx(Xe.button, {
            type: "button",
            role: "tab",
            "aria-selected": m,
            "aria-controls": h,
            "data-state": m ? "active" : "inactive",
            "data-disabled": o ? "" : void 0,
            disabled: o,
            id: f,
            ...a,
            ref: t,
            onMouseDown: We(e.onMouseDown, v => {
                !o && v.button === 0 && v.ctrlKey === !1 ? u.onValueChange(s) : v.preventDefault()
            }
            ),
            onKeyDown: We(e.onKeyDown, v => {
                [" ", "Enter"].includes(v.key) && u.onValueChange(s)
            }
            ),
            onFocus: We(e.onFocus, () => {
                const v = u.activationMode !== "manual";
                !m && !o && v && u.onValueChange(s)
            }
            )
        })
    })
}
);
fT.displayName = dT;
var hT = "TabsContent"
  , pT = w.forwardRef( (e, t) => {
    const {__scopeTabs: n, value: s, forceMount: o, children: a, ...u} = e
      , c = vm(hT, n)
      , f = mT(c.baseId, s)
      , h = gT(c.baseId, s)
      , m = s === c.value
      , v = w.useRef(m);
    return w.useEffect( () => {
        const x = requestAnimationFrame( () => v.current = !1);
        return () => cancelAnimationFrame(x)
    }
    , []),
    y.jsx(ti, {
        present: o || m,
        children: ({present: x}) => y.jsx(Xe.div, {
            "data-state": m ? "active" : "inactive",
            "data-orientation": c.orientation,
            role: "tabpanel",
            "aria-labelledby": f,
            hidden: !x,
            id: h,
            tabIndex: 0,
            ...u,
            ref: t,
            style: {
                ...e.style,
                animationDuration: v.current ? "0s" : void 0
            },
            children: x && a
        })
    })
}
);
pT.displayName = hT;
function mT(e, t) {
    return `${e}-trigger-${t}`
}
function gT(e, t) {
    return `${e}-content-${t}`
}
var WV = lT
  , yT = cT
  , vT = fT
  , xT = pT;
const wT = WV
  , xm = w.forwardRef( ({className: e, ...t}, n) => y.jsx(yT, {
    ref: n,
    className: Ge("inline-flex h-10 items-center justify-center rounded-md bg-muted p-1 text-muted-foreground", e),
    ...t
}));
xm.displayName = yT.displayName;
const us = w.forwardRef( ({className: e, ...t}, n) => y.jsx(vT, {
    ref: n,
    className: Ge("inline-flex items-center justify-center whitespace-nowrap rounded-sm px-3 py-1.5 text-sm font-medium ring-offset-background transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow-sm", e),
    ...t
}));
us.displayName = vT.displayName;
const pa = w.forwardRef( ({className: e, ...t}, n) => y.jsx(xT, {
    ref: n,
    className: Ge("mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2", e),
    ...t
}));
pa.displayName = xT.displayName;
function HV() {
    const [e,t] = w.useState("upcoming")
      , {data: n, isLoading: s} = Ip(e);
    return y.jsxs("div", {
        className: "min-h-screen bg-background",
        children: [y.jsx(hr, {}), y.jsxs("div", {
            className: "container mx-auto px-4 py-12 md:py-20",
            children: [y.jsxs("div", {
                className: "flex flex-col md:flex-row items-center justify-between gap-8 mb-16",
                children: [y.jsxs("div", {
                    children: [y.jsx("h1", {
                        className: "text-4xl md:text-6xl font-display text-white mb-4",
                        children: "Tournaments"
                    }), y.jsx("p", {
                        className: "text-muted-foreground text-lg max-w-xl",
                        children: "Find your next challenge. Join upcoming events or browse past results."
                    })]
                }), y.jsx(wT, {
                    defaultValue: "upcoming",
                    value: e,
                    onValueChange: o => t(o),
                    className: "w-full md:w-auto",
                    children: y.jsxs(xm, {
                        className: "bg-card border border-border/50 p-1 rounded-full h-14 w-full md:w-auto",
                        children: [y.jsx(us, {
                            value: "upcoming",
                            className: "rounded-full px-6 h-12 text-base font-medium data-[state=active]:bg-primary data-[state=active]:text-black",
                            children: "Upcoming"
                        }), y.jsx(us, {
                            value: "ongoing",
                            className: "rounded-full px-6 h-12 text-base font-medium data-[state=active]:bg-primary data-[state=active]:text-black",
                            children: "Live"
                        }), y.jsx(us, {
                            value: "completed",
                            className: "rounded-full px-6 h-12 text-base font-medium data-[state=active]:bg-primary data-[state=active]:text-black",
                            children: "Past"
                        })]
                    })
                })]
            }), s ? y.jsx("div", {
                className: "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-8",
                children: [1, 2, 3].map(o => y.jsx("div", {
                    className: "h-[400px] bg-card/30 rounded-3xl animate-pulse"
                }, o))
            }) : y.jsxs(Ss.div, {
                layout: !0,
                className: "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-8",
                children: [n?.map(o => y.jsx(X1, {
                    tournament: o
                }, o.id)), n?.length === 0 && y.jsxs("div", {
                    className: "col-span-full py-32 text-center text-muted-foreground",
                    children: [y.jsx("p", {
                        className: "text-2xl font-display",
                        children: "No tournaments found"
                    }), y.jsx("p", {
                        children: "Check back later for new events!"
                    })]
                })]
            })]
        })]
    })
}
var nl = e => e.type === "checkbox"
  , $s = e => e instanceof Date
  , Yt = e => e == null;
const bT = e => typeof e == "object";
var wt = e => !Yt(e) && !Array.isArray(e) && bT(e) && !$s(e)
  , ST = e => wt(e) && e.target ? nl(e.target) ? e.target.checked : e.target.value : e
  , qV = e => e.substring(0, e.search(/\.\d+(\.|$)/)) || e
  , TT = (e, t) => e.has(qV(t))
  , QV = e => {
    const t = e.constructor && e.constructor.prototype;
    return wt(t) && t.hasOwnProperty("isPrototypeOf")
}
  , wm = typeof window < "u" && typeof window.HTMLElement < "u" && typeof document < "u";
function It(e) {
    let t;
    const n = Array.isArray(e)
      , s = typeof FileList < "u" ? e instanceof FileList : !1;
    if (e instanceof Date)
        t = new Date(e);
    else if (e instanceof Set)
        t = new Set(e);
    else if (!(wm && (e instanceof Blob || s)) && (n || wt(e)))
        if (t = n ? [] : {},
        !n && !QV(e))
            t = e;
        else
            for (const o in e)
                e.hasOwnProperty(o) && (t[o] = It(e[o]));
    else
        return e;
    return t
}
var Fc = e => Array.isArray(e) ? e.filter(Boolean) : []
  , xt = e => e === void 0
  , ae = (e, t, n) => {
    if (!t || !wt(e))
        return n;
    const s = Fc(t.split(/[,[\].]+?/)).reduce( (o, a) => Yt(o) ? o : o[a], e);
    return xt(s) || s === e ? xt(e[t]) ? n : e[t] : s
}
  , cn = e => typeof e == "boolean"
  , bm = e => /^\w*$/.test(e)
  , PT = e => Fc(e.replace(/["|']|\]/g, "").split(/\.|\[/))
  , Ke = (e, t, n) => {
    let s = -1;
    const o = bm(t) ? [t] : PT(t)
      , a = o.length
      , u = a - 1;
    for (; ++s < a; ) {
        const c = o[s];
        let f = n;
        if (s !== u) {
            const h = e[c];
            f = wt(h) || Array.isArray(h) ? h : isNaN(+o[s + 1]) ? {} : []
        }
        if (c === "__proto__" || c === "constructor" || c === "prototype")
            return;
        e[c] = f,
        e = e[c]
    }
}
;
const rc = {
    BLUR: "blur",
    FOCUS_OUT: "focusout",
    CHANGE: "change"
}
  , Vn = {
    onBlur: "onBlur",
    onChange: "onChange",
    onSubmit: "onSubmit",
    onTouched: "onTouched",
    all: "all"
}
  , Cr = {
    max: "max",
    min: "min",
    maxLength: "maxLength",
    minLength: "minLength",
    pattern: "pattern",
    required: "required",
    validate: "validate"
}
  , CT = Re.createContext(null)
  , Lc = () => Re.useContext(CT)
  , KV = e => {
    const {children: t, ...n} = e;
    return Re.createElement(CT.Provider, {
        value: n
    }, t)
}
;
var ET = (e, t, n, s=!0) => {
    const o = {
        defaultValues: t._defaultValues
    };
    for (const a in e)
        Object.defineProperty(o, a, {
            get: () => {
                const u = a;
                return t._proxyFormState[u] !== Vn.all && (t._proxyFormState[u] = !s || Vn.all),
                n && (n[u] = !0),
                e[u]
            }
        });
    return o
}
;
function GV(e) {
    const t = Lc()
      , {control: n=t.control, disabled: s, name: o, exact: a} = e || {}
      , [u,c] = Re.useState(n._formState)
      , f = Re.useRef({
        isDirty: !1,
        isLoading: !1,
        dirtyFields: !1,
        touchedFields: !1,
        validatingFields: !1,
        isValidating: !1,
        isValid: !1,
        errors: !1
    })
      , h = Re.useRef(o);
    return h.current = o,
    Re.useEffect( () => n._subscribe({
        name: h.current,
        formState: f.current,
        exact: a,
        callback: m => {
            !s && c({
                ...n._formState,
                ...m
            })
        }
    }), [n, s, a]),
    Re.useEffect( () => {
        f.current.isValid && n._setValid(!0)
    }
    , [n]),
    Re.useMemo( () => ET(u, n, f.current, !1), [u, n])
}
var sr = e => typeof e == "string"
  , _T = (e, t, n, s, o) => sr(e) ? (s && t.watch.add(e),
ae(n, e, o)) : Array.isArray(e) ? e.map(a => (s && t.watch.add(a),
ae(n, a))) : (s && (t.watchAll = !0),
n);
function ZV(e) {
    const t = Lc()
      , {control: n=t.control, name: s, defaultValue: o, disabled: a, exact: u} = e || {}
      , c = Re.useRef(s)
      , f = Re.useRef(o);
    c.current = s,
    Re.useEffect( () => n._subscribe({
        name: c.current,
        formState: {
            values: !0
        },
        exact: u,
        callback: v => !a && m(_T(c.current, n._names, v.values || n._formValues, !1, f.current))
    }), [n, a, u]);
    const [h,m] = Re.useState(n._getWatch(s, o));
    return Re.useEffect( () => n._removeUnmounted()),
    h
}
function YV(e) {
    const t = Lc()
      , {name: n, disabled: s, control: o=t.control, shouldUnregister: a} = e
      , u = TT(o._names.array, n)
      , c = ZV({
        control: o,
        name: n,
        defaultValue: ae(o._formValues, n, ae(o._defaultValues, n, e.defaultValue)),
        exact: !0
    })
      , f = GV({
        control: o,
        name: n,
        exact: !0
    })
      , h = Re.useRef(e)
      , m = Re.useRef(o.register(n, {
        ...e.rules,
        value: c,
        ...cn(e.disabled) ? {
            disabled: e.disabled
        } : {}
    }))
      , v = Re.useMemo( () => Object.defineProperties({}, {
        invalid: {
            enumerable: !0,
            get: () => !!ae(f.errors, n)
        },
        isDirty: {
            enumerable: !0,
            get: () => !!ae(f.dirtyFields, n)
        },
        isTouched: {
            enumerable: !0,
            get: () => !!ae(f.touchedFields, n)
        },
        isValidating: {
            enumerable: !0,
            get: () => !!ae(f.validatingFields, n)
        },
        error: {
            enumerable: !0,
            get: () => ae(f.errors, n)
        }
    }), [f, n])
      , x = Re.useCallback(P => m.current.onChange({
        target: {
            value: ST(P),
            name: n
        },
        type: rc.CHANGE
    }), [n])
      , T = Re.useCallback( () => m.current.onBlur({
        target: {
            value: ae(o._formValues, n),
            name: n
        },
        type: rc.BLUR
    }), [n, o._formValues])
      , C = Re.useCallback(P => {
        const _ = ae(o._fields, n);
        _ && P && (_._f.ref = {
            focus: () => P.focus(),
            select: () => P.select(),
            setCustomValidity: k => P.setCustomValidity(k),
            reportValidity: () => P.reportValidity()
        })
    }
    , [o._fields, n])
      , S = Re.useMemo( () => ({
        name: n,
        value: c,
        ...cn(s) || f.disabled ? {
            disabled: f.disabled || s
        } : {},
        onChange: x,
        onBlur: T,
        ref: C
    }), [n, s, f.disabled, x, T, C, c]);
    return Re.useEffect( () => {
        const P = o._options.shouldUnregister || a;
        o.register(n, {
            ...h.current.rules,
            ...cn(h.current.disabled) ? {
                disabled: h.current.disabled
            } : {}
        });
        const _ = (k, j) => {
            const M = ae(o._fields, k);
            M && M._f && (M._f.mount = j)
        }
        ;
        if (_(n, !0),
        P) {
            const k = It(ae(o._options.defaultValues, n));
            Ke(o._defaultValues, n, k),
            xt(ae(o._formValues, n)) && Ke(o._formValues, n, k)
        }
        return !u && o.register(n),
        () => {
            (u ? P && !o._state.action : P) ? o.unregister(n) : _(n, !1)
        }
    }
    , [n, o, u, a]),
    Re.useEffect( () => {
        o._setDisabledField({
            disabled: s,
            name: n
        })
    }
    , [s, n, o]),
    Re.useMemo( () => ({
        field: S,
        formState: f,
        fieldState: v
    }), [S, f, v])
}
const XV = e => e.render(YV(e));
var kT = (e, t, n, s, o) => t ? {
    ...n[e],
    types: {
        ...n[e] && n[e].types ? n[e].types : {},
        [s]: o || !0
    }
} : {}
  , ba = e => Array.isArray(e) ? e : [e]
  , M0 = () => {
    let e = [];
    return {
        get observers() {
            return e
        },
        next: o => {
            for (const a of e)
                a.next && a.next(o)
        }
        ,
        subscribe: o => (e.push(o),
        {
            unsubscribe: () => {
                e = e.filter(a => a !== o)
            }
        }),
        unsubscribe: () => {
            e = []
        }
    }
}
  , op = e => Yt(e) || !bT(e);
function ls(e, t) {
    if (op(e) || op(t))
        return e === t;
    if ($s(e) && $s(t))
        return e.getTime() === t.getTime();
    const n = Object.keys(e)
      , s = Object.keys(t);
    if (n.length !== s.length)
        return !1;
    for (const o of n) {
        const a = e[o];
        if (!s.includes(o))
            return !1;
        if (o !== "ref") {
            const u = t[o];
            if ($s(a) && $s(u) || wt(a) && wt(u) || Array.isArray(a) && Array.isArray(u) ? !ls(a, u) : a !== u)
                return !1
        }
    }
    return !0
}
var Zt = e => wt(e) && !Object.keys(e).length
  , Sm = e => e.type === "file"
  , Bn = e => typeof e == "function"
  , sc = e => {
    if (!wm)
        return !1;
    const t = e ? e.ownerDocument : 0;
    return e instanceof (t && t.defaultView ? t.defaultView.HTMLElement : HTMLElement)
}
  , NT = e => e.type === "select-multiple"
  , Tm = e => e.type === "radio"
  , JV = e => Tm(e) || nl(e)
  , dh = e => sc(e) && e.isConnected;
function e4(e, t) {
    const n = t.slice(0, -1).length;
    let s = 0;
    for (; s < n; )
        e = xt(e) ? s++ : e[t[s++]];
    return e
}
function t4(e) {
    for (const t in e)
        if (e.hasOwnProperty(t) && !xt(e[t]))
            return !1;
    return !0
}
function Et(e, t) {
    const n = Array.isArray(t) ? t : bm(t) ? [t] : PT(t)
      , s = n.length === 1 ? e : e4(e, n)
      , o = n.length - 1
      , a = n[o];
    return s && delete s[a],
    o !== 0 && (wt(s) && Zt(s) || Array.isArray(s) && t4(s)) && Et(e, n.slice(0, -1)),
    e
}
var AT = e => {
    for (const t in e)
        if (Bn(e[t]))
            return !0;
    return !1
}
;
function ic(e, t={}) {
    const n = Array.isArray(e);
    if (wt(e) || n)
        for (const s in e)
            Array.isArray(e[s]) || wt(e[s]) && !AT(e[s]) ? (t[s] = Array.isArray(e[s]) ? [] : {},
            ic(e[s], t[s])) : Yt(e[s]) || (t[s] = !0);
    return t
}
function RT(e, t, n) {
    const s = Array.isArray(e);
    if (wt(e) || s)
        for (const o in e)
            Array.isArray(e[o]) || wt(e[o]) && !AT(e[o]) ? xt(t) || op(n[o]) ? n[o] = Array.isArray(e[o]) ? ic(e[o], []) : {
                ...ic(e[o])
            } : RT(e[o], Yt(t) ? {} : t[o], n[o]) : n[o] = !ls(e[o], t[o]);
    return n
}
var aa = (e, t) => RT(e, t, ic(t));
const I0 = {
    value: !1,
    isValid: !1
}
  , F0 = {
    value: !0,
    isValid: !0
};
var jT = e => {
    if (Array.isArray(e)) {
        if (e.length > 1) {
            const t = e.filter(n => n && n.checked && !n.disabled).map(n => n.value);
            return {
                value: t,
                isValid: !!t.length
            }
        }
        return e[0].checked && !e[0].disabled ? e[0].attributes && !xt(e[0].attributes.value) ? xt(e[0].value) || e[0].value === "" ? F0 : {
            value: e[0].value,
            isValid: !0
        } : F0 : I0
    }
    return I0
}
  , DT = (e, {valueAsNumber: t, valueAsDate: n, setValueAs: s}) => xt(e) ? e : t ? e === "" ? NaN : e && +e : n && sr(e) ? new Date(e) : s ? s(e) : e;
const L0 = {
    isValid: !1,
    value: null
};
var OT = e => Array.isArray(e) ? e.reduce( (t, n) => n && n.checked && !n.disabled ? {
    isValid: !0,
    value: n.value
} : t, L0) : L0;
function V0(e) {
    const t = e.ref;
    return Sm(t) ? t.files : Tm(t) ? OT(e.refs).value : NT(t) ? [...t.selectedOptions].map( ({value: n}) => n) : nl(t) ? jT(e.refs).value : DT(xt(t.value) ? e.ref.value : t.value, e)
}
var n4 = (e, t, n, s) => {
    const o = {};
    for (const a of e) {
        const u = ae(t, a);
        u && Ke(o, a, u._f)
    }
    return {
        criteriaMode: n,
        names: [...e],
        fields: o,
        shouldUseNativeValidation: s
    }
}
  , oc = e => e instanceof RegExp
  , la = e => xt(e) ? e : oc(e) ? e.source : wt(e) ? oc(e.value) ? e.value.source : e.value : e
  , B0 = e => ({
    isOnSubmit: !e || e === Vn.onSubmit,
    isOnBlur: e === Vn.onBlur,
    isOnChange: e === Vn.onChange,
    isOnAll: e === Vn.all,
    isOnTouch: e === Vn.onTouched
});
const z0 = "AsyncFunction";
var r4 = e => !!e && !!e.validate && !!(Bn(e.validate) && e.validate.constructor.name === z0 || wt(e.validate) && Object.values(e.validate).find(t => t.constructor.name === z0))
  , s4 = e => e.mount && (e.required || e.min || e.max || e.maxLength || e.minLength || e.pattern || e.validate)
  , U0 = (e, t, n) => !n && (t.watchAll || t.watch.has(e) || [...t.watch].some(s => e.startsWith(s) && /^\.\w+/.test(e.slice(s.length))));
const Sa = (e, t, n, s) => {
    for (const o of n || Object.keys(e)) {
        const a = ae(e, o);
        if (a) {
            const {_f: u, ...c} = a;
            if (u) {
                if (u.refs && u.refs[0] && t(u.refs[0], o) && !s)
                    return !0;
                if (u.ref && t(u.ref, u.name) && !s)
                    return !0;
                if (Sa(c, t))
                    break
            } else if (wt(c) && Sa(c, t))
                break
        }
    }
}
;
function $0(e, t, n) {
    const s = ae(e, n);
    if (s || bm(n))
        return {
            error: s,
            name: n
        };
    const o = n.split(".");
    for (; o.length; ) {
        const a = o.join(".")
          , u = ae(t, a)
          , c = ae(e, a);
        if (u && !Array.isArray(u) && n !== a)
            return {
                name: n
            };
        if (c && c.type)
            return {
                name: a,
                error: c
            };
        o.pop()
    }
    return {
        name: n
    }
}
var i4 = (e, t, n, s) => {
    n(e);
    const {name: o, ...a} = e;
    return Zt(a) || Object.keys(a).length >= Object.keys(t).length || Object.keys(a).find(u => t[u] === (!s || Vn.all))
}
  , o4 = (e, t, n) => !e || !t || e === t || ba(e).some(s => s && (n ? s === t : s.startsWith(t) || t.startsWith(s)))
  , a4 = (e, t, n, s, o) => o.isOnAll ? !1 : !n && o.isOnTouch ? !(t || e) : (n ? s.isOnBlur : o.isOnBlur) ? !e : (n ? s.isOnChange : o.isOnChange) ? e : !0
  , l4 = (e, t) => !Fc(ae(e, t)).length && Et(e, t)
  , u4 = (e, t, n) => {
    const s = ba(ae(e, n));
    return Ke(s, "root", t[n]),
    Ke(e, n, s),
    e
}
  , ju = e => sr(e);
function W0(e, t, n="validate") {
    if (ju(e) || Array.isArray(e) && e.every(ju) || cn(e) && !e)
        return {
            type: n,
            message: ju(e) ? e : "",
            ref: t
        }
}
var Mi = e => wt(e) && !oc(e) ? e : {
    value: e,
    message: ""
}
  , H0 = async (e, t, n, s, o, a) => {
    const {ref: u, refs: c, required: f, maxLength: h, minLength: m, min: v, max: x, pattern: T, validate: C, name: S, valueAsNumber: P, mount: _} = e._f
      , k = ae(n, S);
    if (!_ || t.has(S))
        return {};
    const j = c ? c[0] : u
      , M = X => {
        o && j.reportValidity && (j.setCustomValidity(cn(X) ? "" : X || ""),
        j.reportValidity())
    }
      , O = {}
      , z = Tm(u)
      , U = nl(u)
      , W = z || U
      , oe = (P || Sm(u)) && xt(u.value) && xt(k) || sc(u) && u.value === "" || k === "" || Array.isArray(k) && !k.length
      , fe = kT.bind(null, S, s, O)
      , we = (X, se, G, be=Cr.maxLength, ce=Cr.minLength) => {
        const ie = X ? se : G;
        O[S] = {
            type: X ? be : ce,
            message: ie,
            ref: u,
            ...fe(X ? be : ce, ie)
        }
    }
    ;
    if (a ? !Array.isArray(k) || !k.length : f && (!W && (oe || Yt(k)) || cn(k) && !k || U && !jT(c).isValid || z && !OT(c).isValid)) {
        const {value: X, message: se} = ju(f) ? {
            value: !!f,
            message: f
        } : Mi(f);
        if (X && (O[S] = {
            type: Cr.required,
            message: se,
            ref: j,
            ...fe(Cr.required, se)
        },
        !s))
            return M(se),
            O
    }
    if (!oe && (!Yt(v) || !Yt(x))) {
        let X, se;
        const G = Mi(x)
          , be = Mi(v);
        if (!Yt(k) && !isNaN(k)) {
            const ce = u.valueAsNumber || k && +k;
            Yt(G.value) || (X = ce > G.value),
            Yt(be.value) || (se = ce < be.value)
        } else {
            const ce = u.valueAsDate || new Date(k)
              , ie = J => new Date(new Date().toDateString() + " " + J)
              , B = u.type == "time"
              , ne = u.type == "week";
            sr(G.value) && k && (X = B ? ie(k) > ie(G.value) : ne ? k > G.value : ce > new Date(G.value)),
            sr(be.value) && k && (se = B ? ie(k) < ie(be.value) : ne ? k < be.value : ce < new Date(be.value))
        }
        if ((X || se) && (we(!!X, G.message, be.message, Cr.max, Cr.min),
        !s))
            return M(O[S].message),
            O
    }
    if ((h || m) && !oe && (sr(k) || a && Array.isArray(k))) {
        const X = Mi(h)
          , se = Mi(m)
          , G = !Yt(X.value) && k.length > +X.value
          , be = !Yt(se.value) && k.length < +se.value;
        if ((G || be) && (we(G, X.message, se.message),
        !s))
            return M(O[S].message),
            O
    }
    if (T && !oe && sr(k)) {
        const {value: X, message: se} = Mi(T);
        if (oc(X) && !k.match(X) && (O[S] = {
            type: Cr.pattern,
            message: se,
            ref: u,
            ...fe(Cr.pattern, se)
        },
        !s))
            return M(se),
            O
    }
    if (C) {
        if (Bn(C)) {
            const X = await C(k, n)
              , se = W0(X, j);
            if (se && (O[S] = {
                ...se,
                ...fe(Cr.validate, se.message)
            },
            !s))
                return M(se.message),
                O
        } else if (wt(C)) {
            let X = {};
            for (const se in C) {
                if (!Zt(X) && !s)
                    break;
                const G = W0(await C[se](k, n), j, se);
                G && (X = {
                    ...G,
                    ...fe(se, G.message)
                },
                M(G.message),
                s && (O[S] = X))
            }
            if (!Zt(X) && (O[S] = {
                ref: j,
                ...X
            },
            !s))
                return O
        }
    }
    return M(!0),
    O
}
;
const c4 = {
    mode: Vn.onSubmit,
    reValidateMode: Vn.onChange,
    shouldFocusError: !0
};
function d4(e={}) {
    let t = {
        ...c4,
        ...e
    }
      , n = {
        submitCount: 0,
        isDirty: !1,
        isLoading: Bn(t.defaultValues),
        isValidating: !1,
        isSubmitted: !1,
        isSubmitting: !1,
        isSubmitSuccessful: !1,
        isValid: !1,
        touchedFields: {},
        dirtyFields: {},
        validatingFields: {},
        errors: t.errors || {},
        disabled: t.disabled || !1
    };
    const s = {};
    let o = wt(t.defaultValues) || wt(t.values) ? It(t.values || t.defaultValues) || {} : {}, a = t.shouldUnregister ? {} : It(o), u = {
        action: !1,
        mount: !1,
        watch: !1
    }, c = {
        mount: new Set,
        disabled: new Set,
        unMount: new Set,
        array: new Set,
        watch: new Set
    }, f, h = 0;
    const m = {
        isDirty: !1,
        dirtyFields: !1,
        validatingFields: !1,
        touchedFields: !1,
        isValidating: !1,
        isValid: !1,
        errors: !1
    };
    let v = {
        ...m
    };
    const x = {
        array: M0(),
        state: M0()
    }
      , T = B0(t.mode)
      , C = B0(t.reValidateMode)
      , S = t.criteriaMode === Vn.all
      , P = N => L => {
        clearTimeout(h),
        h = setTimeout(N, L)
    }
      , _ = async N => {
        if (!t.disabled && (m.isValid || v.isValid || N)) {
            const L = t.resolver ? Zt((await oe()).errors) : await we(s, !0);
            L !== n.isValid && x.state.next({
                isValid: L
            })
        }
    }
      , k = (N, L) => {
        !t.disabled && (m.isValidating || m.validatingFields || v.isValidating || v.validatingFields) && ((N || Array.from(c.mount)).forEach($ => {
            $ && (L ? Ke(n.validatingFields, $, L) : Et(n.validatingFields, $))
        }
        ),
        x.state.next({
            validatingFields: n.validatingFields,
            isValidating: !Zt(n.validatingFields)
        }))
    }
      , j = (N, L=[], $, ue, re=!0, ee=!0) => {
        if (ue && $ && !t.disabled) {
            if (u.action = !0,
            ee && Array.isArray(ae(s, N))) {
                const pe = $(ae(s, N), ue.argA, ue.argB);
                re && Ke(s, N, pe)
            }
            if (ee && Array.isArray(ae(n.errors, N))) {
                const pe = $(ae(n.errors, N), ue.argA, ue.argB);
                re && Ke(n.errors, N, pe),
                l4(n.errors, N)
            }
            if ((m.touchedFields || v.touchedFields) && ee && Array.isArray(ae(n.touchedFields, N))) {
                const pe = $(ae(n.touchedFields, N), ue.argA, ue.argB);
                re && Ke(n.touchedFields, N, pe)
            }
            (m.dirtyFields || v.dirtyFields) && (n.dirtyFields = aa(o, a)),
            x.state.next({
                name: N,
                isDirty: se(N, L),
                dirtyFields: n.dirtyFields,
                errors: n.errors,
                isValid: n.isValid
            })
        } else
            Ke(a, N, L)
    }
      , M = (N, L) => {
        Ke(n.errors, N, L),
        x.state.next({
            errors: n.errors
        })
    }
      , O = N => {
        n.errors = N,
        x.state.next({
            errors: n.errors,
            isValid: !1
        })
    }
      , z = (N, L, $, ue) => {
        const re = ae(s, N);
        if (re) {
            const ee = ae(a, N, xt($) ? ae(o, N) : $);
            xt(ee) || ue && ue.defaultChecked || L ? Ke(a, N, L ? ee : V0(re._f)) : ce(N, ee),
            u.mount && _()
        }
    }
      , U = (N, L, $, ue, re) => {
        let ee = !1
          , pe = !1;
        const Be = {
            name: N
        };
        if (!t.disabled) {
            if (!$ || ue) {
                (m.isDirty || v.isDirty) && (pe = n.isDirty,
                n.isDirty = Be.isDirty = se(),
                ee = pe !== Be.isDirty);
                const Je = ls(ae(o, N), L);
                pe = !!ae(n.dirtyFields, N),
                Je ? Et(n.dirtyFields, N) : Ke(n.dirtyFields, N, !0),
                Be.dirtyFields = n.dirtyFields,
                ee = ee || (m.dirtyFields || v.dirtyFields) && pe !== !Je
            }
            if ($) {
                const Je = ae(n.touchedFields, N);
                Je || (Ke(n.touchedFields, N, $),
                Be.touchedFields = n.touchedFields,
                ee = ee || (m.touchedFields || v.touchedFields) && Je !== $)
            }
            ee && re && x.state.next(Be)
        }
        return ee ? Be : {}
    }
      , W = (N, L, $, ue) => {
        const re = ae(n.errors, N)
          , ee = (m.isValid || v.isValid) && cn(L) && n.isValid !== L;
        if (t.delayError && $ ? (f = P( () => M(N, $)),
        f(t.delayError)) : (clearTimeout(h),
        f = null,
        $ ? Ke(n.errors, N, $) : Et(n.errors, N)),
        ($ ? !ls(re, $) : re) || !Zt(ue) || ee) {
            const pe = {
                ...ue,
                ...ee && cn(L) ? {
                    isValid: L
                } : {},
                errors: n.errors,
                name: N
            };
            n = {
                ...n,
                ...pe
            },
            x.state.next(pe)
        }
    }
      , oe = async N => {
        k(N, !0);
        const L = await t.resolver(a, t.context, n4(N || c.mount, s, t.criteriaMode, t.shouldUseNativeValidation));
        return k(N),
        L
    }
      , fe = async N => {
        const {errors: L} = await oe(N);
        if (N)
            for (const $ of N) {
                const ue = ae(L, $);
                ue ? Ke(n.errors, $, ue) : Et(n.errors, $)
            }
        else
            n.errors = L;
        return L
    }
      , we = async (N, L, $={
        valid: !0
    }) => {
        for (const ue in N) {
            const re = N[ue];
            if (re) {
                const {_f: ee, ...pe} = re;
                if (ee) {
                    const Be = c.array.has(ee.name)
                      , Je = re._f && r4(re._f);
                    Je && m.validatingFields && k([ue], !0);
                    const ft = await H0(re, c.disabled, a, S, t.shouldUseNativeValidation && !L, Be);
                    if (Je && m.validatingFields && k([ue]),
                    ft[ee.name] && ($.valid = !1,
                    L))
                        break;
                    !L && (ae(ft, ee.name) ? Be ? u4(n.errors, ft, ee.name) : Ke(n.errors, ee.name, ft[ee.name]) : Et(n.errors, ee.name))
                }
                !Zt(pe) && await we(pe, L, $)
            }
        }
        return $.valid
    }
      , X = () => {
        for (const N of c.unMount) {
            const L = ae(s, N);
            L && (L._f.refs ? L._f.refs.every($ => !dh($)) : !dh(L._f.ref)) && Qe(N)
        }
        c.unMount = new Set
    }
      , se = (N, L) => !t.disabled && (N && L && Ke(a, N, L),
    !ls(H(), o))
      , G = (N, L, $) => _T(N, c, {
        ...u.mount ? a : xt(L) ? o : sr(N) ? {
            [N]: L
        } : L
    }, $, L)
      , be = N => Fc(ae(u.mount ? a : o, N, t.shouldUnregister ? ae(o, N, []) : []))
      , ce = (N, L, $={}) => {
        const ue = ae(s, N);
        let re = L;
        if (ue) {
            const ee = ue._f;
            ee && (!ee.disabled && Ke(a, N, DT(L, ee)),
            re = sc(ee.ref) && Yt(L) ? "" : L,
            NT(ee.ref) ? [...ee.ref.options].forEach(pe => pe.selected = re.includes(pe.value)) : ee.refs ? nl(ee.ref) ? ee.refs.length > 1 ? ee.refs.forEach(pe => (!pe.defaultChecked || !pe.disabled) && (pe.checked = Array.isArray(re) ? !!re.find(Be => Be === pe.value) : re === pe.value)) : ee.refs[0] && (ee.refs[0].checked = !!re) : ee.refs.forEach(pe => pe.checked = pe.value === re) : Sm(ee.ref) ? ee.ref.value = "" : (ee.ref.value = re,
            ee.ref.type || x.state.next({
                name: N,
                values: It(a)
            })))
        }
        ($.shouldDirty || $.shouldTouch) && U(N, re, $.shouldTouch, $.shouldDirty, !0),
        $.shouldValidate && D(N)
    }
      , ie = (N, L, $) => {
        for (const ue in L) {
            const re = L[ue]
              , ee = `${N}.${ue}`
              , pe = ae(s, ee);
            (c.array.has(N) || wt(re) || pe && !pe._f) && !$s(re) ? ie(ee, re, $) : ce(ee, re, $)
        }
    }
      , B = (N, L, $={}) => {
        const ue = ae(s, N)
          , re = c.array.has(N)
          , ee = It(L);
        Ke(a, N, ee),
        re ? (x.array.next({
            name: N,
            values: It(a)
        }),
        (m.isDirty || m.dirtyFields || v.isDirty || v.dirtyFields) && $.shouldDirty && x.state.next({
            name: N,
            dirtyFields: aa(o, a),
            isDirty: se(N, ee)
        })) : ue && !ue._f && !Yt(ee) ? ie(N, ee, $) : ce(N, ee, $),
        U0(N, c) && x.state.next({
            ...n
        }),
        x.state.next({
            name: u.mount ? N : void 0,
            values: It(a)
        })
    }
      , ne = async N => {
        u.mount = !0;
        const L = N.target;
        let $ = L.name
          , ue = !0;
        const re = ae(s, $)
          , ee = pe => {
            ue = Number.isNaN(pe) || $s(pe) && isNaN(pe.getTime()) || ls(pe, ae(a, $, pe))
        }
        ;
        if (re) {
            let pe, Be;
            const Je = L.type ? V0(re._f) : ST(N)
              , ft = N.type === rc.BLUR || N.type === rc.FOCUS_OUT
              , zc = !s4(re._f) && !t.resolver && !ae(n.errors, $) && !re._f.deps || a4(ft, ae(n.touchedFields, $), n.isSubmitted, C, T)
              , oi = U0($, c, ft);
            Ke(a, $, Je),
            ft ? (re._f.onBlur && re._f.onBlur(N),
            f && f(0)) : re._f.onChange && re._f.onChange(N);
            const ai = U($, Je, ft)
              , Uc = !Zt(ai) || oi;
            if (!ft && x.state.next({
                name: $,
                type: N.type,
                values: It(a)
            }),
            zc)
                return (m.isValid || v.isValid) && (t.mode === "onBlur" ? ft && _() : ft || _()),
                Uc && x.state.next({
                    name: $,
                    ...oi ? {} : ai
                });
            if (!ft && oi && x.state.next({
                ...n
            }),
            t.resolver) {
                const {errors: li} = await oe([$]);
                if (ee(Je),
                ue) {
                    const vo = $0(n.errors, s, $)
                      , ui = $0(li, s, vo.name || $);
                    pe = ui.error,
                    $ = ui.name,
                    Be = Zt(li)
                }
            } else
                k([$], !0),
                pe = (await H0(re, c.disabled, a, S, t.shouldUseNativeValidation))[$],
                k([$]),
                ee(Je),
                ue && (pe ? Be = !1 : (m.isValid || v.isValid) && (Be = await we(s, !0)));
            ue && (re._f.deps && D(re._f.deps),
            W($, Be, pe, ai))
        }
    }
      , J = (N, L) => {
        if (ae(n.errors, L) && N.focus)
            return N.focus(),
            1
    }
      , D = async (N, L={}) => {
        let $, ue;
        const re = ba(N);
        if (t.resolver) {
            const ee = await fe(xt(N) ? N : re);
            $ = Zt(ee),
            ue = N ? !re.some(pe => ae(ee, pe)) : $
        } else
            N ? (ue = (await Promise.all(re.map(async ee => {
                const pe = ae(s, ee);
                return await we(pe && pe._f ? {
                    [ee]: pe
                } : pe)
            }
            ))).every(Boolean),
            !(!ue && !n.isValid) && _()) : ue = $ = await we(s);
        return x.state.next({
            ...!sr(N) || (m.isValid || v.isValid) && $ !== n.isValid ? {} : {
                name: N
            },
            ...t.resolver || !N ? {
                isValid: $
            } : {},
            errors: n.errors
        }),
        L.shouldFocus && !ue && Sa(s, J, N ? re : c.mount),
        ue
    }
      , H = N => {
        const L = {
            ...u.mount ? a : o
        };
        return xt(N) ? L : sr(N) ? ae(L, N) : N.map($ => ae(L, $))
    }
      , Ce = (N, L) => ({
        invalid: !!ae((L || n).errors, N),
        isDirty: !!ae((L || n).dirtyFields, N),
        error: ae((L || n).errors, N),
        isValidating: !!ae(n.validatingFields, N),
        isTouched: !!ae((L || n).touchedFields, N)
    })
      , Ne = N => {
        N && ba(N).forEach(L => Et(n.errors, L)),
        x.state.next({
            errors: N ? n.errors : {}
        })
    }
      , Fe = (N, L, $) => {
        const ue = (ae(s, N, {
            _f: {}
        })._f || {}).ref
          , re = ae(n.errors, N) || {}
          , {ref: ee, message: pe, type: Be, ...Je} = re;
        Ke(n.errors, N, {
            ...Je,
            ...L,
            ref: ue
        }),
        x.state.next({
            name: N,
            errors: n.errors,
            isValid: !1
        }),
        $ && $.shouldFocus && ue && ue.focus && ue.focus()
    }
      , Le = (N, L) => Bn(N) ? x.state.subscribe({
        next: $ => N(G(void 0, L), $)
    }) : G(N, L, !0)
      , Ve = N => x.state.subscribe({
        next: L => {
            o4(N.name, L.name, N.exact) && i4(L, N.formState || m, yo, N.reRenderRoot) && N.callback({
                values: {
                    ...a
                },
                ...n,
                ...L
            })
        }
    }).unsubscribe
      , ze = N => (u.mount = !0,
    v = {
        ...v,
        ...N.formState
    },
    Ve({
        ...N,
        formState: v
    }))
      , Qe = (N, L={}) => {
        for (const $ of N ? ba(N) : c.mount)
            c.mount.delete($),
            c.array.delete($),
            L.keepValue || (Et(s, $),
            Et(a, $)),
            !L.keepError && Et(n.errors, $),
            !L.keepDirty && Et(n.dirtyFields, $),
            !L.keepTouched && Et(n.touchedFields, $),
            !L.keepIsValidating && Et(n.validatingFields, $),
            !t.shouldUnregister && !L.keepDefaultValue && Et(o, $);
        x.state.next({
            values: It(a)
        }),
        x.state.next({
            ...n,
            ...L.keepDirty ? {
                isDirty: se()
            } : {}
        }),
        !L.keepIsValid && _()
    }
      , kt = ({disabled: N, name: L}) => {
        (cn(N) && u.mount || N || c.disabled.has(L)) && (N ? c.disabled.add(L) : c.disabled.delete(L))
    }
      , Kn = (N, L={}) => {
        let $ = ae(s, N);
        const ue = cn(L.disabled) || cn(t.disabled);
        return Ke(s, N, {
            ...$ || {},
            _f: {
                ...$ && $._f ? $._f : {
                    ref: {
                        name: N
                    }
                },
                name: N,
                mount: !0,
                ...L
            }
        }),
        c.mount.add(N),
        $ ? kt({
            disabled: cn(L.disabled) ? L.disabled : t.disabled,
            name: N
        }) : z(N, !0, L.value),
        {
            ...ue ? {
                disabled: L.disabled || t.disabled
            } : {},
            ...t.progressive ? {
                required: !!L.required,
                min: la(L.min),
                max: la(L.max),
                minLength: la(L.minLength),
                maxLength: la(L.maxLength),
                pattern: la(L.pattern)
            } : {},
            name: N,
            onChange: ne,
            onBlur: ne,
            ref: re => {
                if (re) {
                    Kn(N, L),
                    $ = ae(s, N);
                    const ee = xt(re.value) && re.querySelectorAll && re.querySelectorAll("input,select,textarea")[0] || re
                      , pe = JV(ee)
                      , Be = $._f.refs || [];
                    if (pe ? Be.find(Je => Je === ee) : ee === $._f.ref)
                        return;
                    Ke(s, N, {
                        _f: {
                            ...$._f,
                            ...pe ? {
                                refs: [...Be.filter(dh), ee, ...Array.isArray(ae(o, N)) ? [{}] : []],
                                ref: {
                                    type: ee.type,
                                    name: N
                                }
                            } : {
                                ref: ee
                            }
                        }
                    }),
                    z(N, !1, void 0, ee)
                } else
                    $ = ae(s, N, {}),
                    $._f && ($._f.mount = !1),
                    (t.shouldUnregister || L.shouldUnregister) && !(TT(c.array, N) && u.action) && c.unMount.add(N)
            }
        }
    }
      , Ts = () => t.shouldFocusError && Sa(s, J, c.mount)
      , kn = N => {
        cn(N) && (x.state.next({
            disabled: N
        }),
        Sa(s, (L, $) => {
            const ue = ae(s, $);
            ue && (L.disabled = ue._f.disabled || N,
            Array.isArray(ue._f.refs) && ue._f.refs.forEach(re => {
                re.disabled = ue._f.disabled || N
            }
            ))
        }
        , 0, !1))
    }
      , ri = (N, L) => async $ => {
        let ue;
        $ && ($.preventDefault && $.preventDefault(),
        $.persist && $.persist());
        let re = It(a);
        if (x.state.next({
            isSubmitting: !0
        }),
        t.resolver) {
            const {errors: ee, values: pe} = await oe();
            n.errors = ee,
            re = pe
        } else
            await we(s);
        if (c.disabled.size)
            for (const ee of c.disabled)
                Ke(re, ee, void 0);
        if (Et(n.errors, "root"),
        Zt(n.errors)) {
            x.state.next({
                errors: {}
            });
            try {
                await N(re, $)
            } catch (ee) {
                ue = ee
            }
        } else
            L && await L({
                ...n.errors
            }, $),
            Ts(),
            setTimeout(Ts);
        if (x.state.next({
            isSubmitted: !0,
            isSubmitting: !1,
            isSubmitSuccessful: Zt(n.errors) && !ue,
            submitCount: n.submitCount + 1,
            errors: n.errors
        }),
        ue)
            throw ue
    }
      , rl = (N, L={}) => {
        ae(s, N) && (xt(L.defaultValue) ? B(N, It(ae(o, N))) : (B(N, L.defaultValue),
        Ke(o, N, It(L.defaultValue))),
        L.keepTouched || Et(n.touchedFields, N),
        L.keepDirty || (Et(n.dirtyFields, N),
        n.isDirty = L.defaultValue ? se(N, It(ae(o, N))) : se()),
        L.keepError || (Et(n.errors, N),
        m.isValid && _()),
        x.state.next({
            ...n
        }))
    }
      , go = (N, L={}) => {
        const $ = N ? It(N) : o
          , ue = It($)
          , re = Zt(N)
          , ee = re ? o : ue;
        if (L.keepDefaultValues || (o = $),
        !L.keepValues) {
            if (L.keepDirtyValues) {
                const pe = new Set([...c.mount, ...Object.keys(aa(o, a))]);
                for (const Be of Array.from(pe))
                    ae(n.dirtyFields, Be) ? Ke(ee, Be, ae(a, Be)) : B(Be, ae(ee, Be))
            } else {
                if (wm && xt(N))
                    for (const pe of c.mount) {
                        const Be = ae(s, pe);
                        if (Be && Be._f) {
                            const Je = Array.isArray(Be._f.refs) ? Be._f.refs[0] : Be._f.ref;
                            if (sc(Je)) {
                                const ft = Je.closest("form");
                                if (ft) {
                                    ft.reset();
                                    break
                                }
                            }
                        }
                    }
                for (const pe of c.mount)
                    B(pe, ae(ee, pe))
            }
            a = It(ee),
            x.array.next({
                values: {
                    ...ee
                }
            }),
            x.state.next({
                values: {
                    ...ee
                }
            })
        }
        c = {
            mount: L.keepDirtyValues ? c.mount : new Set,
            unMount: new Set,
            array: new Set,
            disabled: new Set,
            watch: new Set,
            watchAll: !1,
            focus: ""
        },
        u.mount = !m.isValid || !!L.keepIsValid || !!L.keepDirtyValues,
        u.watch = !!t.shouldUnregister,
        x.state.next({
            submitCount: L.keepSubmitCount ? n.submitCount : 0,
            isDirty: re ? !1 : L.keepDirty ? n.isDirty : !!(L.keepDefaultValues && !ls(N, o)),
            isSubmitted: L.keepIsSubmitted ? n.isSubmitted : !1,
            dirtyFields: re ? {} : L.keepDirtyValues ? L.keepDefaultValues && a ? aa(o, a) : n.dirtyFields : L.keepDefaultValues && N ? aa(o, N) : L.keepDirty ? n.dirtyFields : {},
            touchedFields: L.keepTouched ? n.touchedFields : {},
            errors: L.keepErrors ? n.errors : {},
            isSubmitSuccessful: L.keepIsSubmitSuccessful ? n.isSubmitSuccessful : !1,
            isSubmitting: !1
        })
    }
      , si = (N, L) => go(Bn(N) ? N(a) : N, L)
      , sl = (N, L={}) => {
        const $ = ae(s, N)
          , ue = $ && $._f;
        if (ue) {
            const re = ue.refs ? ue.refs[0] : ue.ref;
            re.focus && (re.focus(),
            L.shouldSelect && Bn(re.select) && re.select())
        }
    }
      , yo = N => {
        n = {
            ...n,
            ...N
        }
    }
      , mr = {
        control: {
            register: Kn,
            unregister: Qe,
            getFieldState: Ce,
            handleSubmit: ri,
            setError: Fe,
            _subscribe: Ve,
            _runSchema: oe,
            _getWatch: G,
            _getDirty: se,
            _setValid: _,
            _setFieldArray: j,
            _setDisabledField: kt,
            _setErrors: O,
            _getFieldArray: be,
            _reset: go,
            _resetDefaultValues: () => Bn(t.defaultValues) && t.defaultValues().then(N => {
                si(N, t.resetOptions),
                x.state.next({
                    isLoading: !1
                })
            }
            ),
            _removeUnmounted: X,
            _disableForm: kn,
            _subjects: x,
            _proxyFormState: m,
            get _fields() {
                return s
            },
            get _formValues() {
                return a
            },
            get _state() {
                return u
            },
            set _state(N) {
                u = N
            },
            get _defaultValues() {
                return o
            },
            get _names() {
                return c
            },
            set _names(N) {
                c = N
            },
            get _formState() {
                return n
            },
            get _options() {
                return t
            },
            set _options(N) {
                t = {
                    ...t,
                    ...N
                }
            }
        },
        subscribe: ze,
        trigger: D,
        register: Kn,
        handleSubmit: ri,
        watch: Le,
        setValue: B,
        getValues: H,
        reset: si,
        resetField: rl,
        clearErrors: Ne,
        unregister: Qe,
        setError: Fe,
        setFocus: sl,
        getFieldState: Ce
    };
    return {
        ...mr,
        formControl: mr
    }
}
function MT(e={}) {
    const t = Re.useRef(void 0)
      , n = Re.useRef(void 0)
      , [s,o] = Re.useState({
        isDirty: !1,
        isValidating: !1,
        isLoading: Bn(e.defaultValues),
        isSubmitted: !1,
        isSubmitting: !1,
        isSubmitSuccessful: !1,
        isValid: !1,
        submitCount: 0,
        dirtyFields: {},
        touchedFields: {},
        validatingFields: {},
        errors: e.errors || {},
        disabled: e.disabled || !1,
        defaultValues: Bn(e.defaultValues) ? void 0 : e.defaultValues
    });
    t.current || (t.current = {
        ...e.formControl ? e.formControl : d4(e),
        formState: s
    },
    e.formControl && e.defaultValues && !Bn(e.defaultValues) && e.formControl.reset(e.defaultValues, e.resetOptions));
    const a = t.current.control;
    return a._options = e,
    Re.useLayoutEffect( () => a._subscribe({
        formState: a._proxyFormState,
        callback: () => o({
            ...a._formState
        }),
        reRenderRoot: !0
    }), [a]),
    Re.useEffect( () => a._disableForm(e.disabled), [a, e.disabled]),
    Re.useEffect( () => {
        if (a._proxyFormState.isDirty) {
            const u = a._getDirty();
            u !== s.isDirty && a._subjects.state.next({
                isDirty: u
            })
        }
    }
    , [a, s.isDirty]),
    Re.useEffect( () => {
        e.values && !ls(e.values, n.current) ? (a._reset(e.values, a._options.resetOptions),
        n.current = e.values,
        o(u => ({
            ...u
        }))) : a._resetDefaultValues()
    }
    , [e.values, a]),
    Re.useEffect( () => {
        e.errors && !Zt(e.errors) && a._setErrors(e.errors)
    }
    , [e.errors, a]),
    Re.useEffect( () => {
        a._state.mount || (a._setValid(),
        a._state.mount = !0),
        a._state.watch && (a._state.watch = !1,
        a._subjects.state.next({
            ...a._formState
        })),
        a._removeUnmounted()
    }
    ),
    Re.useEffect( () => {
        e.shouldUnregister && a._subjects.state.next({
            values: a._getWatch()
        })
    }
    , [e.shouldUnregister, a]),
    t.current.formState = ET(s, a),
    t.current
}
const q0 = (e, t, n) => {
    if (e && "reportValidity"in e) {
        const s = ae(n, t);
        e.setCustomValidity(s && s.message || ""),
        e.reportValidity()
    }
}
  , IT = (e, t) => {
    for (const n in t.fields) {
        const s = t.fields[n];
        s && s.ref && "reportValidity"in s.ref ? q0(s.ref, n, e) : s.refs && s.refs.forEach(o => q0(o, n, e))
    }
}
  , f4 = (e, t) => {
    t.shouldUseNativeValidation && IT(e, t);
    const n = {};
    for (const s in e) {
        const o = ae(t.fields, s)
          , a = Object.assign(e[s] || {}, {
            ref: o && o.ref
        });
        if (h4(t.names || Object.keys(e), s)) {
            const u = Object.assign({}, ae(n, s));
            Ke(u, "root", a),
            Ke(n, s, u)
        } else
            Ke(n, s, a)
    }
    return n
}
  , h4 = (e, t) => e.some(n => n.startsWith(t + "."));
var p4 = function(e, t) {
    for (var n = {}; e.length; ) {
        var s = e[0]
          , o = s.code
          , a = s.message
          , u = s.path.join(".");
        if (!n[u])
            if ("unionErrors"in s) {
                var c = s.unionErrors[0].errors[0];
                n[u] = {
                    message: c.message,
                    type: c.code
                }
            } else
                n[u] = {
                    message: a,
                    type: o
                };
        if ("unionErrors"in s && s.unionErrors.forEach(function(m) {
            return m.errors.forEach(function(v) {
                return e.push(v)
            })
        }),
        t) {
            var f = n[u].types
              , h = f && f[s.code];
            n[u] = kT(u, t, n, o, h ? [].concat(h, s.message) : s.message)
        }
        e.shift()
    }
    return n
}
  , FT = function(e, t, n) {
    return n === void 0 && (n = {}),
    function(s, o, a) {
        try {
            return Promise.resolve((function(u, c) {
                try {
                    var f = Promise.resolve(e[n.mode === "sync" ? "parse" : "parseAsync"](s, t)).then(function(h) {
                        return a.shouldUseNativeValidation && IT({}, a),
                        {
                            errors: {},
                            values: n.raw ? s : h
                        }
                    })
                } catch (h) {
                    return c(h)
                }
                return f && f.then ? f.then(void 0, c) : f
            }
            )(0, function(u) {
                if ((function(c) {
                    return Array.isArray(c?.errors)
                }
                )(u))
                    return {
                        values: {},
                        errors: f4(p4(u.errors, !a.shouldUseNativeValidation && a.criteriaMode === "all"), a)
                    };
                throw u
            }))
        } catch (u) {
            return Promise.reject(u)
        }
    }
}
  , fh = "focusScope.autoFocusOnMount"
  , hh = "focusScope.autoFocusOnUnmount"
  , Q0 = {
    bubbles: !1,
    cancelable: !0
}
  , m4 = "FocusScope"
  , LT = w.forwardRef( (e, t) => {
    const {loop: n=!1, trapped: s=!1, onMountAutoFocus: o, onUnmountAutoFocus: a, ...u} = e
      , [c,f] = w.useState(null)
      , h = yn(o)
      , m = yn(a)
      , v = w.useRef(null)
      , x = qt(t, S => f(S))
      , T = w.useRef({
        paused: !1,
        pause() {
            this.paused = !0
        },
        resume() {
            this.paused = !1
        }
    }).current;
    w.useEffect( () => {
        if (s) {
            let S = function(j) {
                if (T.paused || !c)
                    return;
                const M = j.target;
                c.contains(M) ? v.current = M : as(v.current, {
                    select: !0
                })
            }
              , P = function(j) {
                if (T.paused || !c)
                    return;
                const M = j.relatedTarget;
                M !== null && (c.contains(M) || as(v.current, {
                    select: !0
                }))
            }
              , _ = function(j) {
                if (document.activeElement === document.body)
                    for (const O of j)
                        O.removedNodes.length > 0 && as(c)
            };
            document.addEventListener("focusin", S),
            document.addEventListener("focusout", P);
            const k = new MutationObserver(_);
            return c && k.observe(c, {
                childList: !0,
                subtree: !0
            }),
            () => {
                document.removeEventListener("focusin", S),
                document.removeEventListener("focusout", P),
                k.disconnect()
            }
        }
    }
    , [s, c, T.paused]),
    w.useEffect( () => {
        if (c) {
            G0.add(T);
            const S = document.activeElement;
            if (!c.contains(S)) {
                const _ = new CustomEvent(fh,Q0);
                c.addEventListener(fh, h),
                c.dispatchEvent(_),
                _.defaultPrevented || (g4(b4(VT(c)), {
                    select: !0
                }),
                document.activeElement === S && as(c))
            }
            return () => {
                c.removeEventListener(fh, h),
                setTimeout( () => {
                    const _ = new CustomEvent(hh,Q0);
                    c.addEventListener(hh, m),
                    c.dispatchEvent(_),
                    _.defaultPrevented || as(S ?? document.body, {
                        select: !0
                    }),
                    c.removeEventListener(hh, m),
                    G0.remove(T)
                }
                , 0)
            }
        }
    }
    , [c, h, m, T]);
    const C = w.useCallback(S => {
        if (!n && !s || T.paused)
            return;
        const P = S.key === "Tab" && !S.altKey && !S.ctrlKey && !S.metaKey
          , _ = document.activeElement;
        if (P && _) {
            const k = S.currentTarget
              , [j,M] = y4(k);
            j && M ? !S.shiftKey && _ === M ? (S.preventDefault(),
            n && as(j, {
                select: !0
            })) : S.shiftKey && _ === j && (S.preventDefault(),
            n && as(M, {
                select: !0
            })) : _ === k && S.preventDefault()
        }
    }
    , [n, s, T.paused]);
    return y.jsx(Xe.div, {
        tabIndex: -1,
        ...u,
        ref: x,
        onKeyDown: C
    })
}
);
LT.displayName = m4;
function g4(e, {select: t=!1}={}) {
    const n = document.activeElement;
    for (const s of e)
        if (as(s, {
            select: t
        }),
        document.activeElement !== n)
            return
}
function y4(e) {
    const t = VT(e)
      , n = K0(t, e)
      , s = K0(t.reverse(), e);
    return [n, s]
}
function VT(e) {
    const t = []
      , n = document.createTreeWalker(e, NodeFilter.SHOW_ELEMENT, {
        acceptNode: s => {
            const o = s.tagName === "INPUT" && s.type === "hidden";
            return s.disabled || s.hidden || o ? NodeFilter.FILTER_SKIP : s.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP
        }
    });
    for (; n.nextNode(); )
        t.push(n.currentNode);
    return t
}
function K0(e, t) {
    for (const n of e)
        if (!v4(n, {
            upTo: t
        }))
            return n
}
function v4(e, {upTo: t}) {
    if (getComputedStyle(e).visibility === "hidden")
        return !0;
    for (; e; ) {
        if (t !== void 0 && e === t)
            return !1;
        if (getComputedStyle(e).display === "none")
            return !0;
        e = e.parentElement
    }
    return !1
}
function x4(e) {
    return e instanceof HTMLInputElement && "select"in e
}
function as(e, {select: t=!1}={}) {
    if (e && e.focus) {
        const n = document.activeElement;
        e.focus({
            preventScroll: !0
        }),
        e !== n && x4(e) && t && e.select()
    }
}
var G0 = w4();
function w4() {
    let e = [];
    return {
        add(t) {
            const n = e[0];
            t !== n && n?.pause(),
            e = Z0(e, t),
            e.unshift(t)
        },
        remove(t) {
            e = Z0(e, t),
            e[0]?.resume()
        }
    }
}
function Z0(e, t) {
    const n = [...e]
      , s = n.indexOf(t);
    return s !== -1 && n.splice(s, 1),
    n
}
function b4(e) {
    return e.filter(t => t.tagName !== "A")
}
var ph = 0;
function S4() {
    w.useEffect( () => {
        const e = document.querySelectorAll("[data-radix-focus-guard]");
        return document.body.insertAdjacentElement("afterbegin", e[0] ?? Y0()),
        document.body.insertAdjacentElement("beforeend", e[1] ?? Y0()),
        ph++,
        () => {
            ph === 1 && document.querySelectorAll("[data-radix-focus-guard]").forEach(t => t.remove()),
            ph--
        }
    }
    , [])
}
function Y0() {
    const e = document.createElement("span");
    return e.setAttribute("data-radix-focus-guard", ""),
    e.tabIndex = 0,
    e.style.outline = "none",
    e.style.opacity = "0",
    e.style.position = "fixed",
    e.style.pointerEvents = "none",
    e
}
var tr = function() {
    return tr = Object.assign || function(t) {
        for (var n, s = 1, o = arguments.length; s < o; s++) {
            n = arguments[s];
            for (var a in n)
                Object.prototype.hasOwnProperty.call(n, a) && (t[a] = n[a])
        }
        return t
    }
    ,
    tr.apply(this, arguments)
};
function BT(e, t) {
    var n = {};
    for (var s in e)
        Object.prototype.hasOwnProperty.call(e, s) && t.indexOf(s) < 0 && (n[s] = e[s]);
    if (e != null && typeof Object.getOwnPropertySymbols == "function")
        for (var o = 0, s = Object.getOwnPropertySymbols(e); o < s.length; o++)
            t.indexOf(s[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, s[o]) && (n[s[o]] = e[s[o]]);
    return n
}
function T4(e, t, n) {
    if (n || arguments.length === 2)
        for (var s = 0, o = t.length, a; s < o; s++)
            (a || !(s in t)) && (a || (a = Array.prototype.slice.call(t, 0, s)),
            a[s] = t[s]);
    return e.concat(a || Array.prototype.slice.call(t))
}
var Du = "right-scroll-bar-position"
  , Ou = "width-before-scroll-bar"
  , P4 = "with-scroll-bars-hidden"
  , C4 = "--removed-body-scroll-bar-size";
function mh(e, t) {
    return typeof e == "function" ? e(t) : e && (e.current = t),
    e
}
function E4(e, t) {
    var n = w.useState(function() {
        return {
            value: e,
            callback: t,
            facade: {
                get current() {
                    return n.value
                },
                set current(s) {
                    var o = n.value;
                    o !== s && (n.value = s,
                    n.callback(s, o))
                }
            }
        }
    })[0];
    return n.callback = t,
    n.facade
}
var _4 = typeof window < "u" ? w.useLayoutEffect : w.useEffect
  , X0 = new WeakMap;
function k4(e, t) {
    var n = E4(null, function(s) {
        return e.forEach(function(o) {
            return mh(o, s)
        })
    });
    return _4(function() {
        var s = X0.get(n);
        if (s) {
            var o = new Set(s)
              , a = new Set(e)
              , u = n.current;
            o.forEach(function(c) {
                a.has(c) || mh(c, null)
            }),
            a.forEach(function(c) {
                o.has(c) || mh(c, u)
            })
        }
        X0.set(n, e)
    }, [e]),
    n
}
function N4(e) {
    return e
}
function A4(e, t) {
    t === void 0 && (t = N4);
    var n = []
      , s = !1
      , o = {
        read: function() {
            if (s)
                throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
            return n.length ? n[n.length - 1] : e
        },
        useMedium: function(a) {
            var u = t(a, s);
            return n.push(u),
            function() {
                n = n.filter(function(c) {
                    return c !== u
                })
            }
        },
        assignSyncMedium: function(a) {
            for (s = !0; n.length; ) {
                var u = n;
                n = [],
                u.forEach(a)
            }
            n = {
                push: function(c) {
                    return a(c)
                },
                filter: function() {
                    return n
                }
            }
        },
        assignMedium: function(a) {
            s = !0;
            var u = [];
            if (n.length) {
                var c = n;
                n = [],
                c.forEach(a),
                u = n
            }
            var f = function() {
                var m = u;
                u = [],
                m.forEach(a)
            }
              , h = function() {
                return Promise.resolve().then(f)
            };
            h(),
            n = {
                push: function(m) {
                    u.push(m),
                    h()
                },
                filter: function(m) {
                    return u = u.filter(m),
                    n
                }
            }
        }
    };
    return o
}
function R4(e) {
    e === void 0 && (e = {});
    var t = A4(null);
    return t.options = tr({
        async: !0,
        ssr: !1
    }, e),
    t
}
var zT = function(e) {
    var t = e.sideCar
      , n = BT(e, ["sideCar"]);
    if (!t)
        throw new Error("Sidecar: please provide `sideCar` property to import the right car");
    var s = t.read();
    if (!s)
        throw new Error("Sidecar medium not found");
    return w.createElement(s, tr({}, n))
};
zT.isSideCarExport = !0;
function j4(e, t) {
    return e.useMedium(t),
    zT
}
var UT = R4()
  , gh = function() {}
  , Vc = w.forwardRef(function(e, t) {
    var n = w.useRef(null)
      , s = w.useState({
        onScrollCapture: gh,
        onWheelCapture: gh,
        onTouchMoveCapture: gh
    })
      , o = s[0]
      , a = s[1]
      , u = e.forwardProps
      , c = e.children
      , f = e.className
      , h = e.removeScrollBar
      , m = e.enabled
      , v = e.shards
      , x = e.sideCar
      , T = e.noIsolation
      , C = e.inert
      , S = e.allowPinchZoom
      , P = e.as
      , _ = P === void 0 ? "div" : P
      , k = e.gapMode
      , j = BT(e, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"])
      , M = x
      , O = k4([n, t])
      , z = tr(tr({}, j), o);
    return w.createElement(w.Fragment, null, m && w.createElement(M, {
        sideCar: UT,
        removeScrollBar: h,
        shards: v,
        noIsolation: T,
        inert: C,
        setCallbacks: a,
        allowPinchZoom: !!S,
        lockRef: n,
        gapMode: k
    }), u ? w.cloneElement(w.Children.only(c), tr(tr({}, z), {
        ref: O
    })) : w.createElement(_, tr({}, z, {
        className: f,
        ref: O
    }), c))
});
Vc.defaultProps = {
    enabled: !0,
    removeScrollBar: !0,
    inert: !1
};
Vc.classNames = {
    fullWidth: Ou,
    zeroRight: Du
};
var D4 = function() {
    if (typeof __webpack_nonce__ < "u")
        return __webpack_nonce__
};
function O4() {
    if (!document)
        return null;
    var e = document.createElement("style");
    e.type = "text/css";
    var t = D4();
    return t && e.setAttribute("nonce", t),
    e
}
function M4(e, t) {
    e.styleSheet ? e.styleSheet.cssText = t : e.appendChild(document.createTextNode(t))
}
function I4(e) {
    var t = document.head || document.getElementsByTagName("head")[0];
    t.appendChild(e)
}
var F4 = function() {
    var e = 0
      , t = null;
    return {
        add: function(n) {
            e == 0 && (t = O4()) && (M4(t, n),
            I4(t)),
            e++
        },
        remove: function() {
            e--,
            !e && t && (t.parentNode && t.parentNode.removeChild(t),
            t = null)
        }
    }
}
  , L4 = function() {
    var e = F4();
    return function(t, n) {
        w.useEffect(function() {
            return e.add(t),
            function() {
                e.remove()
            }
        }, [t && n])
    }
}
  , $T = function() {
    var e = L4()
      , t = function(n) {
        var s = n.styles
          , o = n.dynamic;
        return e(s, o),
        null
    };
    return t
}
  , V4 = {
    left: 0,
    top: 0,
    right: 0,
    gap: 0
}
  , yh = function(e) {
    return parseInt(e || "", 10) || 0
}
  , B4 = function(e) {
    var t = window.getComputedStyle(document.body)
      , n = t[e === "padding" ? "paddingLeft" : "marginLeft"]
      , s = t[e === "padding" ? "paddingTop" : "marginTop"]
      , o = t[e === "padding" ? "paddingRight" : "marginRight"];
    return [yh(n), yh(s), yh(o)]
}
  , z4 = function(e) {
    if (e === void 0 && (e = "margin"),
    typeof window > "u")
        return V4;
    var t = B4(e)
      , n = document.documentElement.clientWidth
      , s = window.innerWidth;
    return {
        left: t[0],
        top: t[1],
        right: t[2],
        gap: Math.max(0, s - n + t[2] - t[0])
    }
}
  , U4 = $T()
  , Xi = "data-scroll-locked"
  , $4 = function(e, t, n, s) {
    var o = e.left
      , a = e.top
      , u = e.right
      , c = e.gap;
    return n === void 0 && (n = "margin"),
    `
  .`.concat(P4, ` {
   overflow: hidden `).concat(s, `;
   padding-right: `).concat(c, "px ").concat(s, `;
  }
  body[`).concat(Xi, `] {
    overflow: hidden `).concat(s, `;
    overscroll-behavior: contain;
    `).concat([t && "position: relative ".concat(s, ";"), n === "margin" && `
    padding-left: `.concat(o, `px;
    padding-top: `).concat(a, `px;
    padding-right: `).concat(u, `px;
    margin-left:0;
    margin-top:0;
    margin-right: `).concat(c, "px ").concat(s, `;
    `), n === "padding" && "padding-right: ".concat(c, "px ").concat(s, ";")].filter(Boolean).join(""), `
  }
  
  .`).concat(Du, ` {
    right: `).concat(c, "px ").concat(s, `;
  }
  
  .`).concat(Ou, ` {
    margin-right: `).concat(c, "px ").concat(s, `;
  }
  
  .`).concat(Du, " .").concat(Du, ` {
    right: 0 `).concat(s, `;
  }
  
  .`).concat(Ou, " .").concat(Ou, ` {
    margin-right: 0 `).concat(s, `;
  }
  
  body[`).concat(Xi, `] {
    `).concat(C4, ": ").concat(c, `px;
  }
`)
}
  , J0 = function() {
    var e = parseInt(document.body.getAttribute(Xi) || "0", 10);
    return isFinite(e) ? e : 0
}
  , W4 = function() {
    w.useEffect(function() {
        return document.body.setAttribute(Xi, (J0() + 1).toString()),
        function() {
            var e = J0() - 1;
            e <= 0 ? document.body.removeAttribute(Xi) : document.body.setAttribute(Xi, e.toString())
        }
    }, [])
}
  , H4 = function(e) {
    var t = e.noRelative
      , n = e.noImportant
      , s = e.gapMode
      , o = s === void 0 ? "margin" : s;
    W4();
    var a = w.useMemo(function() {
        return z4(o)
    }, [o]);
    return w.createElement(U4, {
        styles: $4(a, !t, o, n ? "" : "!important")
    })
}
  , ap = !1;
if (typeof window < "u")
    try {
        var bu = Object.defineProperty({}, "passive", {
            get: function() {
                return ap = !0,
                !0
            }
        });
        window.addEventListener("test", bu, bu),
        window.removeEventListener("test", bu, bu)
    } catch {
        ap = !1
    }
var Ii = ap ? {
    passive: !1
} : !1
  , q4 = function(e) {
    return e.tagName === "TEXTAREA"
}
  , WT = function(e, t) {
    if (!(e instanceof Element))
        return !1;
    var n = window.getComputedStyle(e);
    return n[t] !== "hidden" && !(n.overflowY === n.overflowX && !q4(e) && n[t] === "visible")
}
  , Q4 = function(e) {
    return WT(e, "overflowY")
}
  , K4 = function(e) {
    return WT(e, "overflowX")
}
  , ew = function(e, t) {
    var n = t.ownerDocument
      , s = t;
    do {
        typeof ShadowRoot < "u" && s instanceof ShadowRoot && (s = s.host);
        var o = HT(e, s);
        if (o) {
            var a = qT(e, s)
              , u = a[1]
              , c = a[2];
            if (u > c)
                return !0
        }
        s = s.parentNode
    } while (s && s !== n.body);
    return !1
}
  , G4 = function(e) {
    var t = e.scrollTop
      , n = e.scrollHeight
      , s = e.clientHeight;
    return [t, n, s]
}
  , Z4 = function(e) {
    var t = e.scrollLeft
      , n = e.scrollWidth
      , s = e.clientWidth;
    return [t, n, s]
}
  , HT = function(e, t) {
    return e === "v" ? Q4(t) : K4(t)
}
  , qT = function(e, t) {
    return e === "v" ? G4(t) : Z4(t)
}
  , Y4 = function(e, t) {
    return e === "h" && t === "rtl" ? -1 : 1
}
  , X4 = function(e, t, n, s, o) {
    var a = Y4(e, window.getComputedStyle(t).direction)
      , u = a * s
      , c = n.target
      , f = t.contains(c)
      , h = !1
      , m = u > 0
      , v = 0
      , x = 0;
    do {
        var T = qT(e, c)
          , C = T[0]
          , S = T[1]
          , P = T[2]
          , _ = S - P - a * C;
        (C || _) && HT(e, c) && (v += _,
        x += C),
        c instanceof ShadowRoot ? c = c.host : c = c.parentNode
    } while (!f && c !== document.body || f && (t.contains(c) || t === c));
    return (m && Math.abs(v) < 1 || !m && Math.abs(x) < 1) && (h = !0),
    h
}
  , Su = function(e) {
    return "changedTouches"in e ? [e.changedTouches[0].clientX, e.changedTouches[0].clientY] : [0, 0]
}
  , tw = function(e) {
    return [e.deltaX, e.deltaY]
}
  , nw = function(e) {
    return e && "current"in e ? e.current : e
}
  , J4 = function(e, t) {
    return e[0] === t[0] && e[1] === t[1]
}
  , e3 = function(e) {
    return `
  .block-interactivity-`.concat(e, ` {pointer-events: none;}
  .allow-interactivity-`).concat(e, ` {pointer-events: all;}
`)
}
  , t3 = 0
  , Fi = [];
function n3(e) {
    var t = w.useRef([])
      , n = w.useRef([0, 0])
      , s = w.useRef()
      , o = w.useState(t3++)[0]
      , a = w.useState($T)[0]
      , u = w.useRef(e);
    w.useEffect(function() {
        u.current = e
    }, [e]),
    w.useEffect(function() {
        if (e.inert) {
            document.body.classList.add("block-interactivity-".concat(o));
            var S = T4([e.lockRef.current], (e.shards || []).map(nw), !0).filter(Boolean);
            return S.forEach(function(P) {
                return P.classList.add("allow-interactivity-".concat(o))
            }),
            function() {
                document.body.classList.remove("block-interactivity-".concat(o)),
                S.forEach(function(P) {
                    return P.classList.remove("allow-interactivity-".concat(o))
                })
            }
        }
    }, [e.inert, e.lockRef.current, e.shards]);
    var c = w.useCallback(function(S, P) {
        if ("touches"in S && S.touches.length === 2 || S.type === "wheel" && S.ctrlKey)
            return !u.current.allowPinchZoom;
        var _ = Su(S), k = n.current, j = "deltaX"in S ? S.deltaX : k[0] - _[0], M = "deltaY"in S ? S.deltaY : k[1] - _[1], O, z = S.target, U = Math.abs(j) > Math.abs(M) ? "h" : "v";
        if ("touches"in S && U === "h" && z.type === "range")
            return !1;
        var W = ew(U, z);
        if (!W)
            return !0;
        if (W ? O = U : (O = U === "v" ? "h" : "v",
        W = ew(U, z)),
        !W)
            return !1;
        if (!s.current && "changedTouches"in S && (j || M) && (s.current = O),
        !O)
            return !0;
        var oe = s.current || O;
        return X4(oe, P, S, oe === "h" ? j : M)
    }, [])
      , f = w.useCallback(function(S) {
        var P = S;
        if (!(!Fi.length || Fi[Fi.length - 1] !== a)) {
            var _ = "deltaY"in P ? tw(P) : Su(P)
              , k = t.current.filter(function(O) {
                return O.name === P.type && (O.target === P.target || P.target === O.shadowParent) && J4(O.delta, _)
            })[0];
            if (k && k.should) {
                P.cancelable && P.preventDefault();
                return
            }
            if (!k) {
                var j = (u.current.shards || []).map(nw).filter(Boolean).filter(function(O) {
                    return O.contains(P.target)
                })
                  , M = j.length > 0 ? c(P, j[0]) : !u.current.noIsolation;
                M && P.cancelable && P.preventDefault()
            }
        }
    }, [])
      , h = w.useCallback(function(S, P, _, k) {
        var j = {
            name: S,
            delta: P,
            target: _,
            should: k,
            shadowParent: r3(_)
        };
        t.current.push(j),
        setTimeout(function() {
            t.current = t.current.filter(function(M) {
                return M !== j
            })
        }, 1)
    }, [])
      , m = w.useCallback(function(S) {
        n.current = Su(S),
        s.current = void 0
    }, [])
      , v = w.useCallback(function(S) {
        h(S.type, tw(S), S.target, c(S, e.lockRef.current))
    }, [])
      , x = w.useCallback(function(S) {
        h(S.type, Su(S), S.target, c(S, e.lockRef.current))
    }, []);
    w.useEffect(function() {
        return Fi.push(a),
        e.setCallbacks({
            onScrollCapture: v,
            onWheelCapture: v,
            onTouchMoveCapture: x
        }),
        document.addEventListener("wheel", f, Ii),
        document.addEventListener("touchmove", f, Ii),
        document.addEventListener("touchstart", m, Ii),
        function() {
            Fi = Fi.filter(function(S) {
                return S !== a
            }),
            document.removeEventListener("wheel", f, Ii),
            document.removeEventListener("touchmove", f, Ii),
            document.removeEventListener("touchstart", m, Ii)
        }
    }, []);
    var T = e.removeScrollBar
      , C = e.inert;
    return w.createElement(w.Fragment, null, C ? w.createElement(a, {
        styles: e3(o)
    }) : null, T ? w.createElement(H4, {
        gapMode: e.gapMode
    }) : null)
}
function r3(e) {
    for (var t = null; e !== null; )
        e instanceof ShadowRoot && (t = e.host,
        e = e.host),
        e = e.parentNode;
    return t
}
const s3 = j4(UT, n3);
var QT = w.forwardRef(function(e, t) {
    return w.createElement(Vc, tr({}, e, {
        ref: t,
        sideCar: s3
    }))
});
QT.classNames = Vc.classNames;
var i3 = function(e) {
    if (typeof document > "u")
        return null;
    var t = Array.isArray(e) ? e[0] : e;
    return t.ownerDocument.body
}
  , Li = new WeakMap
  , Tu = new WeakMap
  , Pu = {}
  , vh = 0
  , KT = function(e) {
    return e && (e.host || KT(e.parentNode))
}
  , o3 = function(e, t) {
    return t.map(function(n) {
        if (e.contains(n))
            return n;
        var s = KT(n);
        return s && e.contains(s) ? s : (console.error("aria-hidden", n, "in not contained inside", e, ". Doing nothing"),
        null)
    }).filter(function(n) {
        return !!n
    })
}
  , a3 = function(e, t, n, s) {
    var o = o3(t, Array.isArray(e) ? e : [e]);
    Pu[n] || (Pu[n] = new WeakMap);
    var a = Pu[n]
      , u = []
      , c = new Set
      , f = new Set(o)
      , h = function(v) {
        !v || c.has(v) || (c.add(v),
        h(v.parentNode))
    };
    o.forEach(h);
    var m = function(v) {
        !v || f.has(v) || Array.prototype.forEach.call(v.children, function(x) {
            if (c.has(x))
                m(x);
            else
                try {
                    var T = x.getAttribute(s)
                      , C = T !== null && T !== "false"
                      , S = (Li.get(x) || 0) + 1
                      , P = (a.get(x) || 0) + 1;
                    Li.set(x, S),
                    a.set(x, P),
                    u.push(x),
                    S === 1 && C && Tu.set(x, !0),
                    P === 1 && x.setAttribute(n, "true"),
                    C || x.setAttribute(s, "true")
                } catch (_) {
                    console.error("aria-hidden: cannot operate on ", x, _)
                }
        })
    };
    return m(t),
    c.clear(),
    vh++,
    function() {
        u.forEach(function(v) {
            var x = Li.get(v) - 1
              , T = a.get(v) - 1;
            Li.set(v, x),
            a.set(v, T),
            x || (Tu.has(v) || v.removeAttribute(s),
            Tu.delete(v)),
            T || v.removeAttribute(n)
        }),
        vh--,
        vh || (Li = new WeakMap,
        Li = new WeakMap,
        Tu = new WeakMap,
        Pu = {})
    }
}
  , l3 = function(e, t, n) {
    n === void 0 && (n = "data-aria-hidden");
    var s = Array.from(Array.isArray(e) ? e : [e])
      , o = i3(e);
    return o ? (s.push.apply(s, Array.from(o.querySelectorAll("[aria-live]"))),
    a3(s, o, n, "aria-hidden")) : function() {
        return null
    }
}
  , Pm = "Dialog"
  , [GT] = ei(Pm)
  , [u3,Qn] = GT(Pm)
  , ZT = e => {
    const {__scopeDialog: t, children: n, open: s, defaultOpen: o, onOpenChange: a, modal: u=!0} = e
      , c = w.useRef(null)
      , f = w.useRef(null)
      , [h=!1,m] = pc({
        prop: s,
        defaultProp: o,
        onChange: a
    });
    return y.jsx(u3, {
        scope: t,
        triggerRef: c,
        contentRef: f,
        contentId: ga(),
        titleId: ga(),
        descriptionId: ga(),
        open: h,
        onOpenChange: m,
        onOpenToggle: w.useCallback( () => m(v => !v), [m]),
        modal: u,
        children: n
    })
}
;
ZT.displayName = Pm;
var YT = "DialogTrigger"
  , XT = w.forwardRef( (e, t) => {
    const {__scopeDialog: n, ...s} = e
      , o = Qn(YT, n)
      , a = qt(t, o.triggerRef);
    return y.jsx(Xe.button, {
        type: "button",
        "aria-haspopup": "dialog",
        "aria-expanded": o.open,
        "aria-controls": o.contentId,
        "data-state": _m(o.open),
        ...s,
        ref: a,
        onClick: We(e.onClick, o.onOpenToggle)
    })
}
);
XT.displayName = YT;
var Cm = "DialogPortal"
  , [c3,JT] = GT(Cm, {
    forceMount: void 0
})
  , eP = e => {
    const {__scopeDialog: t, forceMount: n, children: s, container: o} = e
      , a = Qn(Cm, t);
    return y.jsx(c3, {
        scope: t,
        forceMount: n,
        children: w.Children.map(s, u => y.jsx(ti, {
            present: n || a.open,
            children: y.jsx(yp, {
                asChild: !0,
                container: o,
                children: u
            })
        }))
    })
}
;
eP.displayName = Cm;
var ac = "DialogOverlay"
  , tP = w.forwardRef( (e, t) => {
    const n = JT(ac, e.__scopeDialog)
      , {forceMount: s=n.forceMount, ...o} = e
      , a = Qn(ac, e.__scopeDialog);
    return a.modal ? y.jsx(ti, {
        present: s || a.open,
        children: y.jsx(f3, {
            ...o,
            ref: t
        })
    }) : null
}
);
tP.displayName = ac;
var d3 = Pa("DialogOverlay.RemoveScroll")
  , f3 = w.forwardRef( (e, t) => {
    const {__scopeDialog: n, ...s} = e
      , o = Qn(ac, n);
    return y.jsx(QT, {
        as: d3,
        allowPinchZoom: !0,
        shards: [o.contentRef],
        children: y.jsx(Xe.div, {
            "data-state": _m(o.open),
            ...s,
            ref: t,
            style: {
                pointerEvents: "auto",
                ...s.style
            }
        })
    })
}
)
  , Js = "DialogContent"
  , nP = w.forwardRef( (e, t) => {
    const n = JT(Js, e.__scopeDialog)
      , {forceMount: s=n.forceMount, ...o} = e
      , a = Qn(Js, e.__scopeDialog);
    return y.jsx(ti, {
        present: s || a.open,
        children: a.modal ? y.jsx(h3, {
            ...o,
            ref: t
        }) : y.jsx(p3, {
            ...o,
            ref: t
        })
    })
}
);
nP.displayName = Js;
var h3 = w.forwardRef( (e, t) => {
    const n = Qn(Js, e.__scopeDialog)
      , s = w.useRef(null)
      , o = qt(t, n.contentRef, s);
    return w.useEffect( () => {
        const a = s.current;
        if (a)
            return l3(a)
    }
    , []),
    y.jsx(rP, {
        ...e,
        ref: o,
        trapFocus: n.open,
        disableOutsidePointerEvents: !0,
        onCloseAutoFocus: We(e.onCloseAutoFocus, a => {
            a.preventDefault(),
            n.triggerRef.current?.focus()
        }
        ),
        onPointerDownOutside: We(e.onPointerDownOutside, a => {
            const u = a.detail.originalEvent
              , c = u.button === 0 && u.ctrlKey === !0;
            (u.button === 2 || c) && a.preventDefault()
        }
        ),
        onFocusOutside: We(e.onFocusOutside, a => a.preventDefault())
    })
}
)
  , p3 = w.forwardRef( (e, t) => {
    const n = Qn(Js, e.__scopeDialog)
      , s = w.useRef(!1)
      , o = w.useRef(!1);
    return y.jsx(rP, {
        ...e,
        ref: t,
        trapFocus: !1,
        disableOutsidePointerEvents: !1,
        onCloseAutoFocus: a => {
            e.onCloseAutoFocus?.(a),
            a.defaultPrevented || (s.current || n.triggerRef.current?.focus(),
            a.preventDefault()),
            s.current = !1,
            o.current = !1
        }
        ,
        onInteractOutside: a => {
            e.onInteractOutside?.(a),
            a.defaultPrevented || (s.current = !0,
            a.detail.originalEvent.type === "pointerdown" && (o.current = !0));
            const u = a.target;
            n.triggerRef.current?.contains(u) && a.preventDefault(),
            a.detail.originalEvent.type === "focusin" && o.current && a.preventDefault()
        }
    })
}
)
  , rP = w.forwardRef( (e, t) => {
    const {__scopeDialog: n, trapFocus: s, onOpenAutoFocus: o, onCloseAutoFocus: a, ...u} = e
      , c = Qn(Js, n)
      , f = w.useRef(null)
      , h = qt(t, f);
    return S4(),
    y.jsxs(y.Fragment, {
        children: [y.jsx(LT, {
            asChild: !0,
            loop: !0,
            trapped: s,
            onMountAutoFocus: o,
            onUnmountAutoFocus: a,
            children: y.jsx(hc, {
                role: "dialog",
                id: c.contentId,
                "aria-describedby": c.descriptionId,
                "aria-labelledby": c.titleId,
                "data-state": _m(c.open),
                ...u,
                ref: h,
                onDismiss: () => c.onOpenChange(!1)
            })
        }), y.jsxs(y.Fragment, {
            children: [y.jsx(m3, {
                titleId: c.titleId
            }), y.jsx(y3, {
                contentRef: f,
                descriptionId: c.descriptionId
            })]
        })]
    })
}
)
  , Em = "DialogTitle"
  , sP = w.forwardRef( (e, t) => {
    const {__scopeDialog: n, ...s} = e
      , o = Qn(Em, n);
    return y.jsx(Xe.h2, {
        id: o.titleId,
        ...s,
        ref: t
    })
}
);
sP.displayName = Em;
var iP = "DialogDescription"
  , oP = w.forwardRef( (e, t) => {
    const {__scopeDialog: n, ...s} = e
      , o = Qn(iP, n);
    return y.jsx(Xe.p, {
        id: o.descriptionId,
        ...s,
        ref: t
    })
}
);
oP.displayName = iP;
var aP = "DialogClose"
  , lP = w.forwardRef( (e, t) => {
    const {__scopeDialog: n, ...s} = e
      , o = Qn(aP, n);
    return y.jsx(Xe.button, {
        type: "button",
        ...s,
        ref: t,
        onClick: We(e.onClick, () => o.onOpenChange(!1))
    })
}
);
lP.displayName = aP;
function _m(e) {
    return e ? "open" : "closed"
}
var uP = "DialogTitleWarning"
  , [U3,cP] = V_(uP, {
    contentName: Js,
    titleName: Em,
    docsSlug: "dialog"
})
  , m3 = ({titleId: e}) => {
    const t = cP(uP)
      , n = `\`${t.contentName}\` requires a \`${t.titleName}\` for the component to be accessible for screen reader users.

If you want to hide the \`${t.titleName}\`, you can wrap it with our VisuallyHidden component.

For more information, see https://radix-ui.com/primitives/docs/components/${t.docsSlug}`;
    return w.useEffect( () => {
        e && (document.getElementById(e) || console.error(n))
    }
    , [n, e]),
    null
}
  , g3 = "DialogDescriptionWarning"
  , y3 = ({contentRef: e, descriptionId: t}) => {
    const s = `Warning: Missing \`Description\` or \`aria-describedby={undefined}\` for {${cP(g3).contentName}}.`;
    return w.useEffect( () => {
        const o = e.current?.getAttribute("aria-describedby");
        t && o && (document.getElementById(t) || console.warn(s))
    }
    , [s, e, t]),
    null
}
  , v3 = ZT
  , x3 = XT
  , w3 = eP
  , dP = tP
  , fP = nP
  , hP = sP
  , pP = oP
  , b3 = lP;
const mP = v3
  , gP = x3
  , S3 = w3
  , yP = w.forwardRef( ({className: e, ...t}, n) => y.jsx(dP, {
    ref: n,
    className: Ge("fixed inset-0 z-50 bg-black/80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0", e),
    ...t
}));
yP.displayName = dP.displayName;
const km = w.forwardRef( ({className: e, children: t, ...n}, s) => y.jsxs(S3, {
    children: [y.jsx(yP, {}), y.jsxs(fP, {
        ref: s,
        className: Ge("fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg", e),
        ...n,
        children: [t, y.jsxs(b3, {
            className: "absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground",
            children: [y.jsx(bp, {
                className: "h-4 w-4"
            }), y.jsx("span", {
                className: "sr-only",
                children: "Close"
            })]
        })]
    })]
}));
km.displayName = fP.displayName;
const Nm = ({className: e, ...t}) => y.jsx("div", {
    className: Ge("flex flex-col space-y-1.5 text-center sm:text-left", e),
    ...t
});
Nm.displayName = "DialogHeader";
const Am = w.forwardRef( ({className: e, ...t}, n) => y.jsx(hP, {
    ref: n,
    className: Ge("text-lg font-semibold leading-none tracking-tight", e),
    ...t
}));
Am.displayName = hP.displayName;
const vP = w.forwardRef( ({className: e, ...t}, n) => y.jsx(pP, {
    ref: n,
    className: Ge("text-sm text-muted-foreground", e),
    ...t
}));
vP.displayName = pP.displayName;
var T3 = "Label"
  , xP = w.forwardRef( (e, t) => y.jsx(Xe.label, {
    ...e,
    ref: t,
    onMouseDown: n => {
        n.target.closest("button, input, select, textarea") || (e.onMouseDown?.(n),
        !n.defaultPrevented && n.detail > 1 && n.preventDefault())
    }
}));
xP.displayName = T3;
var wP = xP;
const P3 = vc("text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70")
  , bP = w.forwardRef( ({className: e, ...t}, n) => y.jsx(wP, {
    ref: n,
    className: Ge(P3(), e),
    ...t
}));
bP.displayName = wP.displayName;
const SP = KV
  , TP = w.createContext({})
  , kr = ({...e}) => y.jsx(TP.Provider, {
    value: {
        name: e.name
    },
    children: y.jsx(XV, {
        ...e
    })
})
  , Bc = () => {
    const e = w.useContext(TP)
      , t = w.useContext(PP)
      , {getFieldState: n, formState: s} = Lc()
      , o = n(e.name, s);
    if (!e)
        throw new Error("useFormField should be used within <FormField>");
    const {id: a} = t;
    return {
        id: a,
        name: e.name,
        formItemId: `${a}-form-item`,
        formDescriptionId: `${a}-form-item-description`,
        formMessageId: `${a}-form-item-message`,
        ...o
    }
}
  , PP = w.createContext({})
  , Nr = w.forwardRef( ({className: e, ...t}, n) => {
    const s = w.useId();
    return y.jsx(PP.Provider, {
        value: {
            id: s
        },
        children: y.jsx("div", {
            ref: n,
            className: Ge("space-y-2", e),
            ...t
        })
    })
}
);
Nr.displayName = "FormItem";
const nr = w.forwardRef( ({className: e, ...t}, n) => {
    const {error: s, formItemId: o} = Bc();
    return y.jsx(bP, {
        ref: n,
        className: Ge(s && "text-destructive", e),
        htmlFor: o,
        ...t
    })
}
);
nr.displayName = "FormLabel";
const Ar = w.forwardRef( ({...e}, t) => {
    const {error: n, formItemId: s, formDescriptionId: o, formMessageId: a} = Bc();
    return y.jsx(_w, {
        ref: t,
        id: s,
        "aria-describedby": n ? `${o} ${a}` : `${o}`,
        "aria-invalid": !!n,
        ...e
    })
}
);
Ar.displayName = "FormControl";
const C3 = w.forwardRef( ({className: e, ...t}, n) => {
    const {formDescriptionId: s} = Bc();
    return y.jsx("p", {
        ref: n,
        id: s,
        className: Ge("text-sm text-muted-foreground", e),
        ...t
    })
}
);
C3.displayName = "FormDescription";
const rr = w.forwardRef( ({className: e, children: t, ...n}, s) => {
    const {error: o, formMessageId: a} = Bc()
      , u = o ? String(o?.message ?? "") : t;
    return u ? y.jsx("p", {
        ref: s,
        id: a,
        className: Ge("text-sm font-medium text-destructive", e),
        ...n,
        children: u
    }) : null
}
);
rr.displayName = "FormMessage";
const Rr = w.forwardRef( ({className: e, type: t, ...n}, s) => y.jsx("input", {
    type: t,
    className: Ge("flex h-9 w-full rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 md:text-sm", e),
    ref: s,
    ...n
}));
Rr.displayName = "Input";
const E3 = Ae.object({
    name: Ae.string().min(1, "Team name required"),
    captainDiscord: Ae.string().min(1, "Captain Discord required"),
    captainEmail: Ae.string().email().optional().or(Ae.literal("")),
    players: Ae.array(Ae.string().min(1, "Player tag required")).min(3, "Minimum 3 players required")
});
function _3({tournamentId: e}) {
    const [t,n] = w.useState(!1)
      , {toast: s} = gp()
      , o = HO(e)
      , a = MT({
        resolver: FT(E3),
        defaultValues: {
            name: "",
            captainDiscord: "",
            captainEmail: "",
            players: ["", "", ""]
        }
    })
      , u = m => {
        o.mutate(m, {
            onSuccess: () => {
                s({
                    title: "Registration Submitted!",
                    description: "Your team is now pending approval. Good luck!"
                }),
                n(!1),
                a.reset()
            }
            ,
            onError: v => {
                s({
                    title: "Registration Failed",
                    description: v.message,
                    variant: "destructive"
                })
            }
        })
    }
      , c = a.watch("players")
      , f = () => {
        const m = a.getValues("players");
        a.setValue("players", [...m, ""])
    }
      , h = m => {
        const v = a.getValues("players");
        v.length > 3 && a.setValue("players", v.filter( (x, T) => T !== m))
    }
    ;
    return y.jsxs(mP, {
        open: t,
        onOpenChange: n,
        children: [y.jsx(gP, {
            asChild: !0,
            children: y.jsxs(jt, {
                size: "lg",
                className: "w-full md:w-auto bg-accent text-accent-foreground hover:bg-accent/90 font-display tracking-wider text-xl py-6 px-8 shadow-lg shadow-accent/20",
                children: [y.jsx(ir, {
                    className: "mr-2 h-6 w-6"
                }), "Register Team"]
            })
        }), y.jsxs(km, {
            className: "max-w-2xl bg-card border-border",
            children: [y.jsxs(Nm, {
                children: [y.jsx(Am, {
                    className: "text-3xl font-display text-white",
                    children: "Team Registration"
                }), y.jsx(vP, {
                    children: "Enter your team details below. Make sure all player tags are correct!"
                })]
            }), y.jsx(SP, {
                ...a,
                children: y.jsxs("form", {
                    onSubmit: a.handleSubmit(u),
                    className: "space-y-6 mt-4",
                    children: [y.jsxs("div", {
                        className: "grid md:grid-cols-2 gap-4",
                        children: [y.jsx(kr, {
                            control: a.control,
                            name: "name",
                            render: ({field: m}) => y.jsxs(Nr, {
                                children: [y.jsx(nr, {
                                    children: "Team Name"
                                }), y.jsx(Ar, {
                                    children: y.jsx(Rr, {
                                        placeholder: "e.g. Brawl Stars Pros",
                                        ...m,
                                        className: "bg-background/50 border-white/10 focus:border-primary"
                                    })
                                }), y.jsx(rr, {})]
                            })
                        }), y.jsx(kr, {
                            control: a.control,
                            name: "captainDiscord",
                            render: ({field: m}) => y.jsxs(Nr, {
                                children: [y.jsx(nr, {
                                    children: "Captain Discord"
                                }), y.jsx(Ar, {
                                    children: y.jsx(Rr, {
                                        placeholder: "username#0000",
                                        ...m,
                                        className: "bg-background/50 border-white/10 focus:border-primary"
                                    })
                                }), y.jsx(rr, {})]
                            })
                        })]
                    }), y.jsx(kr, {
                        control: a.control,
                        name: "captainEmail",
                        render: ({field: m}) => y.jsxs(Nr, {
                            children: [y.jsx(nr, {
                                children: "Captain Email (Optional)"
                            }), y.jsx(Ar, {
                                children: y.jsx(Rr, {
                                    placeholder: "contact@email.com",
                                    ...m,
                                    className: "bg-background/50 border-white/10 focus:border-primary"
                                })
                            }), y.jsx(rr, {})]
                        })
                    }), y.jsxs("div", {
                        className: "space-y-3",
                        children: [y.jsxs("div", {
                            className: "flex items-center justify-between",
                            children: [y.jsx(nr, {
                                children: "Player Roster (Tags)"
                            }), y.jsxs(jt, {
                                type: "button",
                                variant: "outline",
                                size: "sm",
                                onClick: f,
                                className: "text-xs",
                                children: [y.jsx(rb, {
                                    className: "w-3 h-3 mr-1"
                                }), " Add Player"]
                            })]
                        }), y.jsx("div", {
                            className: "grid grid-cols-2 gap-3",
                            children: c.map( (m, v) => y.jsx(kr, {
                                control: a.control,
                                name: `players.${v}`,
                                render: ({field: x}) => y.jsxs("div", {
                                    className: "flex gap-2",
                                    children: [y.jsx(Rr, {
                                        placeholder: `Player ${v + 1} Tag`,
                                        ...x,
                                        className: "bg-background/50 border-white/10 focus:border-primary"
                                    }), c.length > 3 && y.jsx(jt, {
                                        type: "button",
                                        variant: "ghost",
                                        size: "icon",
                                        onClick: () => h(v),
                                        className: "text-destructive hover:text-destructive/80 hover:bg-destructive/10",
                                        children: y.jsx(Lk, {
                                            className: "w-4 h-4"
                                        })
                                    })]
                                })
                            }, v))
                        }), y.jsx(rr, {
                            children: a.formState.errors.players?.message
                        })]
                    }), y.jsx(jt, {
                        type: "submit",
                        className: "w-full bg-primary text-primary-foreground font-display text-lg py-6 mt-6",
                        disabled: o.isPending,
                        children: o.isPending ? "Submitting..." : "Submit Registration"
                    })]
                })
            })]
        })]
    })
}
function k3() {
    const [e,t] = GE("/tournaments/:id")
      , n = t ? parseInt(t.id) : 0
      , {data: s, isLoading: o} = zO(n)
      , {data: a, isLoading: u} = WO(n);
    return o ? y.jsxs("div", {
        className: "min-h-screen bg-background",
        children: [y.jsx(hr, {}), y.jsx("div", {
            className: "container mx-auto px-4 py-20 flex justify-center",
            children: y.jsx("div", {
                className: "w-12 h-12 border-4 border-primary border-t-transparent rounded-full animate-spin"
            })
        })]
    }) : s ? y.jsxs("div", {
        className: "min-h-screen bg-background pb-20",
        children: [y.jsx(hr, {}), y.jsxs("div", {
            className: "relative h-[400px] md:h-[500px] w-full overflow-hidden",
            children: [y.jsx("div", {
                className: "absolute inset-0 bg-gradient-to-t from-background via-background/80 to-transparent z-10"
            }), y.jsx("img", {
                src: s.imageUrl || "https://images.unsplash.com/photo-1542751371-adc38448a05e?w=1600&q=80",
                alt: s.title,
                className: "w-full h-full object-cover"
            }), y.jsx("div", {
                className: "absolute bottom-0 left-0 w-full z-20 pb-12 md:pb-20",
                children: y.jsx("div", {
                    className: "container mx-auto px-4",
                    children: y.jsxs("div", {
                        className: "flex flex-col md:flex-row items-end gap-8 justify-between",
                        children: [y.jsxs("div", {
                            className: "space-y-4 max-w-3xl",
                            children: [y.jsxs("div", {
                                className: "flex gap-3",
                                children: [y.jsx(Ru, {
                                    variant: "outline",
                                    className: "text-primary border-primary bg-primary/10 backdrop-blur-md",
                                    children: s.game
                                }), y.jsx(Ru, {
                                    variant: "outline",
                                    className: "border-white/50 text-white backdrop-blur-md",
                                    children: s.status.toUpperCase()
                                })]
                            }), y.jsx("h1", {
                                className: "text-4xl md:text-6xl lg:text-7xl font-display text-white drop-shadow-lg leading-none",
                                children: s.title
                            }), y.jsxs("div", {
                                className: "flex flex-wrap items-center gap-6 text-lg text-gray-200",
                                children: [y.jsxs("div", {
                                    className: "flex items-center gap-2",
                                    children: [y.jsx(nb, {
                                        className: "w-5 h-5 text-accent"
                                    }), y.jsx("span", {
                                        children: SS(new Date(s.date), "MMMM d, yyyy • h:mm a")
                                    })]
                                }), y.jsxs("div", {
                                    className: "flex items-center gap-2",
                                    children: [y.jsx(ir, {
                                        className: "w-5 h-5 text-accent"
                                    }), y.jsx("span", {
                                        className: "font-bold text-accent",
                                        children: s.prizePool
                                    })]
                                }), y.jsxs("div", {
                                    className: "flex items-center gap-2",
                                    children: [y.jsx(Dk, {
                                        className: "w-5 h-5 text-accent"
                                    }), y.jsx("span", {
                                        children: "Online Region"
                                    })]
                                })]
                            })]
                        }), s.status === "upcoming" && y.jsx("div", {
                            className: "w-full md:w-auto",
                            children: y.jsx(_3, {
                                tournamentId: s.id
                            })
                        })]
                    })
                })
            })]
        }), y.jsx("div", {
            className: "container mx-auto px-4 -mt-8 relative z-30",
            children: y.jsxs("div", {
                className: "grid grid-cols-1 lg:grid-cols-3 gap-8",
                children: [y.jsx("div", {
                    className: "lg:col-span-2",
                    children: y.jsxs(wT, {
                        defaultValue: "overview",
                        className: "w-full",
                        children: [y.jsxs(xm, {
                            className: "bg-card border border-white/10 w-full justify-start h-auto p-2 rounded-2xl mb-8 overflow-x-auto flex-nowrap",
                            children: [y.jsx(us, {
                                value: "overview",
                                className: "py-3 px-6 rounded-xl data-[state=active]:bg-primary data-[state=active]:text-black text-lg",
                                children: "Overview"
                            }), y.jsx(us, {
                                value: "bracket",
                                className: "py-3 px-6 rounded-xl data-[state=active]:bg-primary data-[state=active]:text-black text-lg",
                                children: "Bracket"
                            }), y.jsxs(us, {
                                value: "teams",
                                className: "py-3 px-6 rounded-xl data-[state=active]:bg-primary data-[state=active]:text-black text-lg",
                                children: ["Teams (", a?.length || 0, ")"]
                            }), y.jsx(us, {
                                value: "rules",
                                className: "py-3 px-6 rounded-xl data-[state=active]:bg-primary data-[state=active]:text-black text-lg",
                                children: "Rules"
                            })]
                        }), y.jsxs(pa, {
                            value: "overview",
                            className: "bg-card border border-white/10 rounded-3xl p-8 shadow-xl",
                            children: [y.jsx("h3", {
                                className: "text-2xl font-display text-white mb-4",
                                children: "About this Tournament"
                            }), y.jsx("p", {
                                className: "text-muted-foreground whitespace-pre-wrap leading-relaxed text-lg",
                                children: s.description
                            }), y.jsxs("div", {
                                className: "mt-8 grid grid-cols-1 sm:grid-cols-2 gap-6",
                                children: [y.jsxs("div", {
                                    className: "p-6 bg-background/50 rounded-2xl border border-white/5",
                                    children: [y.jsx(Mk, {
                                        className: "w-8 h-8 text-primary mb-3"
                                    }), y.jsx("h4", {
                                        className: "text-xl font-bold text-white mb-1",
                                        children: "Format"
                                    }), y.jsx("p", {
                                        className: "text-muted-foreground",
                                        children: "Single Elimination"
                                    }), y.jsx("p", {
                                        className: "text-muted-foreground",
                                        children: "Best of 3 Sets"
                                    })]
                                }), y.jsxs("div", {
                                    className: "p-6 bg-background/50 rounded-2xl border border-white/5",
                                    children: [y.jsx(sb, {
                                        className: "w-8 h-8 text-primary mb-3"
                                    }), y.jsx("h4", {
                                        className: "text-xl font-bold text-white mb-1",
                                        children: "Team Size"
                                    }), y.jsx("p", {
                                        className: "text-muted-foreground",
                                        children: "3v3 + 1 Sub (Optional)"
                                    }), y.jsxs("p", {
                                        className: "text-muted-foreground",
                                        children: [s.maxTeams, " Teams Max"]
                                    })]
                                })]
                            })]
                        }), y.jsx(pa, {
                            value: "bracket",
                            className: "bg-card border border-white/10 rounded-3xl p-8 shadow-xl min-h-[400px] flex flex-col items-center justify-center text-center",
                            children: s.bracketUrl ? y.jsxs(y.Fragment, {
                                children: [y.jsx(ir, {
                                    className: "w-16 h-16 text-accent mb-6 opacity-20"
                                }), y.jsx("h3", {
                                    className: "text-2xl font-display text-white mb-4",
                                    children: "View Live Bracket"
                                }), y.jsx("p", {
                                    className: "text-muted-foreground max-w-md mb-8",
                                    children: "Follow the live action, match results, and tournament progression on our external bracket provider."
                                }), y.jsx("a", {
                                    href: s.bracketUrl,
                                    target: "_blank",
                                    rel: "noopener noreferrer",
                                    children: y.jsxs(jt, {
                                        size: "lg",
                                        className: "bg-[#2a303c] hover:bg-[#3a4150] text-white",
                                        children: [y.jsx(jk, {
                                            className: "mr-2 w-4 h-4"
                                        }), " Open Bracket"]
                                    })
                                })]
                            }) : y.jsxs(y.Fragment, {
                                children: [y.jsx(ir, {
                                    className: "w-16 h-16 text-muted-foreground mb-6 opacity-20"
                                }), y.jsx("h3", {
                                    className: "text-2xl font-display text-white mb-2",
                                    children: "Bracket Not Yet Available"
                                }), y.jsx("p", {
                                    className: "text-muted-foreground",
                                    children: "Check back closer to the start date!"
                                })]
                            })
                        }), y.jsx(pa, {
                            value: "teams",
                            className: "bg-card border border-white/10 rounded-3xl p-8 shadow-xl",
                            children: y.jsx("div", {
                                className: "grid grid-cols-1 md:grid-cols-2 gap-4",
                                children: u ? y.jsx("p", {
                                    children: "Loading teams..."
                                }) : a && a.length > 0 ? a.map(c => y.jsxs("div", {
                                    className: "p-4 bg-background/50 rounded-xl border border-white/5 flex items-center justify-between",
                                    children: [y.jsxs("div", {
                                        children: [y.jsx("h4", {
                                            className: "font-bold text-white text-lg",
                                            children: c.name
                                        }), y.jsx("p", {
                                            className: "text-sm text-muted-foreground",
                                            children: c.players.join(", ")
                                        })]
                                    }), y.jsx(Ru, {
                                        variant: c.status === "approved" ? "default" : "secondary",
                                        children: c.status
                                    })]
                                }, c.id)) : y.jsx("p", {
                                    className: "text-muted-foreground col-span-full text-center py-10",
                                    children: "No teams registered yet. Be the first!"
                                })
                            })
                        }), y.jsxs(pa, {
                            value: "rules",
                            className: "bg-card border border-white/10 rounded-3xl p-8 shadow-xl",
                            children: [y.jsx("h3", {
                                className: "text-2xl font-display text-white mb-6",
                                children: "Tournament Rules"
                            }), y.jsx("div", {
                                className: "prose prose-invert max-w-none",
                                children: s.rules ? y.jsx("div", {
                                    className: "whitespace-pre-wrap",
                                    children: s.rules
                                }) : y.jsxs("ul", {
                                    className: "list-disc pl-5 space-y-2 text-muted-foreground",
                                    children: [y.jsx("li", {
                                        children: "Respect all players and staff."
                                    }), y.jsx("li", {
                                        children: "No cheating or use of third-party software."
                                    }), y.jsx("li", {
                                        children: "Be on time for your matches (15 minute buffer)."
                                    }), y.jsx("li", {
                                        children: "Captain must report scores in Discord."
                                    }), y.jsx("li", {
                                        children: "Disconnects during a match may result in a round loss."
                                    })]
                                })
                            })]
                        })]
                    })
                }), y.jsxs("div", {
                    className: "space-y-6",
                    children: [y.jsxs("div", {
                        className: "bg-gradient-to-br from-secondary to-purple-800 rounded-3xl p-8 text-white shadow-xl relative overflow-hidden",
                        children: [y.jsx("div", {
                            className: "absolute -right-10 -bottom-10 w-40 h-40 bg-white/10 rounded-full blur-3xl"
                        }), y.jsx("h3", {
                            className: "text-2xl font-display mb-2",
                            children: "Need Help?"
                        }), y.jsx("p", {
                            className: "text-white/80 mb-6",
                            children: "Join our Discord server for support, announcements, and to coordinate matches."
                        }), y.jsx(jt, {
                            className: "w-full bg-white text-secondary hover:bg-white/90 font-bold",
                            children: "Join Discord"
                        })]
                    }), y.jsxs("div", {
                        className: "bg-card border border-white/10 rounded-3xl p-8",
                        children: [y.jsx("h3", {
                            className: "text-xl font-display text-white mb-4",
                            children: "Share"
                        }), y.jsx("div", {
                            className: "flex gap-4",
                            children: y.jsx(jt, {
                                variant: "outline",
                                className: "flex-1 border-white/20",
                                onClick: () => {
                                    navigator.clipboard.writeText(window.location.href),
                                    alert("Link copied!")
                                }
                                ,
                                children: "Copy Link"
                            })
                        })]
                    })]
                })]
            })
        })]
    }) : y.jsxs("div", {
        className: "min-h-screen bg-background flex flex-col items-center justify-center",
        children: [y.jsx("h1", {
            className: "text-4xl font-display text-white mb-4",
            children: "Tournament Not Found"
        }), y.jsx(dn, {
            href: "/tournaments",
            children: y.jsx(jt, {
                children: "Back to Tournaments"
            })
        })]
    })
}
function N3() {
    return y.jsxs("div", {
        className: "min-h-screen bg-background",
        children: [y.jsx(hr, {}), y.jsxs("div", {
            className: "container mx-auto px-4 py-16",
            children: [y.jsx("h1", {
                className: "text-5xl font-display text-white text-center mb-4",
                children: "General Rules"
            }), y.jsx("p", {
                className: "text-center text-muted-foreground text-lg mb-16 max-w-2xl mx-auto",
                children: "These rules apply to all YF7 Tournaments unless specified otherwise in a specific tournament's details."
            }), y.jsxs("div", {
                className: "grid md:grid-cols-2 gap-8 max-w-4xl mx-auto",
                children: [y.jsxs("div", {
                    className: "bg-card border border-white/10 p-8 rounded-3xl",
                    children: [y.jsx("div", {
                        className: "w-12 h-12 bg-primary/20 text-primary rounded-xl flex items-center justify-center mb-6",
                        children: y.jsx(zk, {
                            className: "w-6 h-6"
                        })
                    }), y.jsx("h3", {
                        className: "text-2xl font-display text-white mb-4",
                        children: "Player Eligibility"
                    }), y.jsxs("ul", {
                        className: "space-y-3 text-muted-foreground",
                        children: [y.jsx("li", {
                            children: "• Players must be in the YF7 Discord server."
                        }), y.jsx("li", {
                            children: "• Accounts must be in good standing with Supercell."
                        }), y.jsx("li", {
                            children: "• Smurfing is strictly prohibited."
                        }), y.jsx("li", {
                            children: "• Only one account per player allowed."
                        })]
                    })]
                }), y.jsxs("div", {
                    className: "bg-card border border-white/10 p-8 rounded-3xl",
                    children: [y.jsx("div", {
                        className: "w-12 h-12 bg-secondary/20 text-secondary rounded-xl flex items-center justify-center mb-6",
                        children: y.jsx(Ak, {
                            className: "w-6 h-6"
                        })
                    }), y.jsx("h3", {
                        className: "text-2xl font-display text-white mb-4",
                        children: "Match Format"
                    }), y.jsxs("ul", {
                        className: "space-y-3 text-muted-foreground",
                        children: [y.jsx("li", {
                            children: "• Default format is 3v3 Draft Mode."
                        }), y.jsx("li", {
                            children: "• Maps are pre-selected by administration."
                        }), y.jsx("li", {
                            children: "• Disconnects during draft = remake."
                        }), y.jsx("li", {
                            children: "• Disconnects during game = play on."
                        })]
                    })]
                }), y.jsxs("div", {
                    className: "bg-card border border-white/10 p-8 rounded-3xl",
                    children: [y.jsx("div", {
                        className: "w-12 h-12 bg-accent/20 text-accent rounded-xl flex items-center justify-center mb-6",
                        children: y.jsx(Ah, {
                            className: "w-6 h-6"
                        })
                    }), y.jsx("h3", {
                        className: "text-2xl font-display text-white mb-4",
                        children: "Sportsmanship"
                    }), y.jsxs("ul", {
                        className: "space-y-3 text-muted-foreground",
                        children: [y.jsx("li", {
                            children: "• Respect all opponents and staff."
                        }), y.jsx("li", {
                            children: "• Toxic behavior may result in disqualification."
                        }), y.jsx("li", {
                            children: "• No match fixing or betting."
                        }), y.jsx("li", {
                            children: "• Report issues immediately to admins."
                        })]
                    })]
                }), y.jsxs("div", {
                    className: "bg-card border border-white/10 p-8 rounded-3xl",
                    children: [y.jsx("div", {
                        className: "w-12 h-12 bg-red-500/20 text-red-500 rounded-xl flex items-center justify-center mb-6",
                        children: y.jsx(Bk, {
                            className: "w-6 h-6"
                        })
                    }), y.jsx("h3", {
                        className: "text-2xl font-display text-white mb-4",
                        children: "Prizes & Payouts"
                    }), y.jsxs("ul", {
                        className: "space-y-3 text-muted-foreground",
                        children: [y.jsx("li", {
                            children: "• Payouts are sent via PayPal or Bank Transfer."
                        }), y.jsx("li", {
                            children: "• Claims must be made within 14 days."
                        }), y.jsx("li", {
                            children: "• Payouts processed within 30 days of end."
                        }), y.jsx("li", {
                            children: "• Captain is responsible for team split."
                        })]
                    })]
                })]
            })]
        })]
    })
}
const CP = w.forwardRef( ({className: e, ...t}, n) => y.jsx("textarea", {
    className: Ge("flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 md:text-sm", e),
    ref: n,
    ...t
}));
CP.displayName = "Textarea";
function A3() {
    const {user: e, isLoading: t} = J1()
      , [,n] = cp()
      , {data: s} = Ip()
      , o = $O()
      , a = UO()
      , {toast: u} = gp()
      , [c,f] = w.useState(!1);
    if (!t && (!e || !e.isAdmin))
        return n("/"),
        null;
    const h = MT({
        resolver: FT(yS),
        defaultValues: {
            title: "",
            description: "",
            game: "Brawl Stars",
            date: new Date().toISOString(),
            prizePool: "$0",
            status: "upcoming",
            maxTeams: 32,
            imageUrl: "",
            rules: ""
        }
    })
      , m = x => {
        const T = {
            ...x,
            date: new Date(x.date)
        };
        a.mutate(T, {
            onSuccess: () => {
                u({
                    title: "Tournament Created"
                }),
                f(!1),
                h.reset()
            }
            ,
            onError: C => {
                u({
                    title: "Error",
                    description: C.message,
                    variant: "destructive"
                })
            }
        })
    }
      , v = x => {
        confirm("Are you sure? This cannot be undone.") && o.mutate(x, {
            onSuccess: () => u({
                title: "Tournament Deleted"
            })
        })
    }
    ;
    return y.jsxs("div", {
        className: "min-h-screen bg-background pb-20",
        children: [y.jsx(hr, {}), y.jsxs("div", {
            className: "container mx-auto px-4 py-12",
            children: [y.jsxs("div", {
                className: "flex items-center justify-between mb-12",
                children: [y.jsx("h1", {
                    className: "text-4xl font-display text-white",
                    children: "Admin Dashboard"
                }), y.jsxs(mP, {
                    open: c,
                    onOpenChange: f,
                    children: [y.jsx(gP, {
                        asChild: !0,
                        children: y.jsxs(jt, {
                            className: "bg-primary text-black hover:bg-primary/90",
                            children: [y.jsx(rb, {
                                className: "mr-2 h-4 w-4"
                            }), " Create Tournament"]
                        })
                    }), y.jsxs(km, {
                        className: "bg-card border-border max-h-[90vh] overflow-y-auto",
                        children: [y.jsx(Nm, {
                            children: y.jsx(Am, {
                                children: "Create New Tournament"
                            })
                        }), y.jsx(SP, {
                            ...h,
                            children: y.jsxs("form", {
                                onSubmit: h.handleSubmit(m),
                                className: "space-y-4",
                                children: [y.jsx(kr, {
                                    control: h.control,
                                    name: "title",
                                    render: ({field: x}) => y.jsxs(Nr, {
                                        children: [y.jsx(nr, {
                                            children: "Title"
                                        }), y.jsx(Ar, {
                                            children: y.jsx(Rr, {
                                                ...x
                                            })
                                        }), y.jsx(rr, {})]
                                    })
                                }), y.jsx(kr, {
                                    control: h.control,
                                    name: "description",
                                    render: ({field: x}) => y.jsxs(Nr, {
                                        children: [y.jsx(nr, {
                                            children: "Description"
                                        }), y.jsx(Ar, {
                                            children: y.jsx(CP, {
                                                ...x
                                            })
                                        }), y.jsx(rr, {})]
                                    })
                                }), y.jsxs("div", {
                                    className: "grid grid-cols-2 gap-4",
                                    children: [y.jsx(kr, {
                                        control: h.control,
                                        name: "date",
                                        render: ({field: x}) => y.jsxs(Nr, {
                                            children: [y.jsx(nr, {
                                                children: "Date (YYYY-MM-DDTHH:mm:ss)"
                                            }), y.jsx(Ar, {
                                                children: y.jsx(Rr, {
                                                    type: "datetime-local",
                                                    ...x
                                                })
                                            }), y.jsx(rr, {})]
                                        })
                                    }), y.jsx(kr, {
                                        control: h.control,
                                        name: "prizePool",
                                        render: ({field: x}) => y.jsxs(Nr, {
                                            children: [y.jsx(nr, {
                                                children: "Prize Pool"
                                            }), y.jsx(Ar, {
                                                children: y.jsx(Rr, {
                                                    ...x
                                                })
                                            }), y.jsx(rr, {})]
                                        })
                                    })]
                                }), y.jsx(kr, {
                                    control: h.control,
                                    name: "imageUrl",
                                    render: ({field: x}) => y.jsxs(Nr, {
                                        children: [y.jsx(nr, {
                                            children: "Image URL (Optional)"
                                        }), y.jsx(Ar, {
                                            children: y.jsx(Rr, {
                                                ...x
                                            })
                                        }), y.jsx(rr, {})]
                                    })
                                }), y.jsx(jt, {
                                    type: "submit",
                                    className: "w-full",
                                    disabled: a.isPending,
                                    children: a.isPending ? "Creating..." : "Create Tournament"
                                })]
                            })
                        })]
                    })]
                })]
            }), y.jsxs("div", {
                className: "bg-card border border-white/10 rounded-2xl overflow-hidden",
                children: [y.jsx("div", {
                    className: "p-6 border-b border-white/10",
                    children: y.jsx("h2", {
                        className: "text-xl font-bold text-white",
                        children: "Manage Tournaments"
                    })
                }), y.jsxs("div", {
                    className: "divide-y divide-white/5",
                    children: [s?.map(x => y.jsxs("div", {
                        className: "p-6 flex items-center justify-between hover:bg-white/5 transition-colors",
                        children: [y.jsxs("div", {
                            children: [y.jsx("h3", {
                                className: "text-lg font-bold text-white",
                                children: x.title
                            }), y.jsxs("p", {
                                className: "text-sm text-muted-foreground",
                                children: [x.status, " • ", new Date(x.date).toLocaleDateString()]
                            })]
                        }), y.jsxs("div", {
                            className: "flex gap-2",
                            children: [y.jsx(jt, {
                                variant: "ghost",
                                size: "icon",
                                children: y.jsx(Fk, {
                                    className: "w-4 h-4"
                                })
                            }), y.jsx(jt, {
                                variant: "ghost",
                                size: "icon",
                                className: "text-destructive hover:bg-destructive/10",
                                onClick: () => v(x.id),
                                children: y.jsx(Vk, {
                                    className: "w-4 h-4"
                                })
                            })]
                        })]
                    }, x.id)), s?.length === 0 && y.jsx("div", {
                        className: "p-12 text-center text-muted-foreground",
                        children: "No tournaments found."
                    })]
                })]
            })]
        })]
    })
}
function R3() {
    return y.jsxs("div", {
        className: "min-h-screen bg-background",
        children: [y.jsx(hr, {}), y.jsxs("div", {
            className: "container mx-auto px-4 py-20",
            children: [y.jsxs(Ss.div, {
                initial: {
                    opacity: 0,
                    y: 20
                },
                animate: {
                    opacity: 1,
                    y: 0
                },
                className: "text-center mb-16",
                children: [y.jsx(ir, {
                    className: "w-16 h-16 text-primary mx-auto mb-6"
                }), y.jsx("h1", {
                    className: "text-5xl font-display text-white mb-4",
                    children: "Winners Teams"
                }), y.jsx("p", {
                    className: "text-xl text-muted-foreground",
                    children: "The Hall of Fame of YF7 Tournaments"
                })]
            }), y.jsx("div", {
                className: "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-8",
                children: y.jsxs("div", {
                    className: "bg-card p-8 rounded-3xl border border-white/5 text-center",
                    children: [y.jsx("h3", {
                        className: "text-2xl font-display text-primary mb-2",
                        children: "Champion Team #1"
                    }), y.jsx("p", {
                        className: "text-muted-foreground",
                        children: "Winner of YF7 Cup #41"
                    })]
                })
            })]
        })]
    })
}
function j3() {
    return y.jsxs("div", {
        className: "min-h-screen bg-background",
        children: [y.jsx(hr, {}), y.jsxs("div", {
            className: "container mx-auto px-4 py-20",
            children: [y.jsxs(Ss.div, {
                initial: {
                    opacity: 0,
                    y: 20
                },
                animate: {
                    opacity: 1,
                    y: 0
                },
                className: "text-center mb-16",
                children: [y.jsx("h1", {
                    className: "text-5xl font-display text-white mb-4",
                    children: "Our Partners"
                }), y.jsx("p", {
                    className: "text-xl text-muted-foreground",
                    children: "Growing the community together"
                })]
            }), y.jsx("div", {
                className: "grid grid-cols-2 md:grid-cols-4 gap-8",
                children: y.jsx("div", {
                    className: "bg-card p-8 rounded-3xl border border-white/5 flex items-center justify-center grayscale hover:grayscale-0 transition-all",
                    children: y.jsx("span", {
                        className: "text-2xl font-display opacity-50",
                        children: "Partner Logo"
                    })
                })
            })]
        })]
    })
}
function D3() {
    return y.jsxs("div", {
        className: "min-h-screen bg-background",
        children: [y.jsx(hr, {}), y.jsx("div", {
            className: "container mx-auto px-4 py-20 max-w-4xl",
            children: y.jsxs(Ss.div, {
                initial: {
                    opacity: 0,
                    y: 20
                },
                animate: {
                    opacity: 1,
                    y: 0
                },
                children: [y.jsx("h1", {
                    className: "text-5xl font-display text-white mb-8",
                    children: "About Us"
                }), y.jsx("div", {
                    className: "prose prose-invert lg:prose-xl",
                    children: y.jsx("p", {
                        children: "YF7 Tournaments is the premier platform for competitive Brawl Stars in France. Founded by YF7, we aim to provide high-quality competitive opportunities for players of all levels."
                    })
                })]
            })
        })]
    })
}
function O3() {
    return y.jsxs("div", {
        className: "min-h-screen bg-background",
        children: [y.jsx(hr, {}), y.jsx("div", {
            className: "container mx-auto px-4 py-20 max-w-4xl",
            children: y.jsxs(Ss.div, {
                initial: {
                    opacity: 0,
                    y: 20
                },
                animate: {
                    opacity: 1,
                    y: 0
                },
                children: [y.jsx("h1", {
                    className: "text-5xl font-display text-white mb-8",
                    children: "Organization"
                }), y.jsxs("div", {
                    className: "bg-card p-8 rounded-3xl border border-white/5",
                    children: [y.jsx("h2", {
                        className: "text-3xl font-display text-primary mb-4",
                        children: "The Team"
                    }), y.jsx("p", {
                        className: "text-xl text-muted-foreground mb-6",
                        children: "Managed by YF7 and a dedicated team of moderators and casters."
                    }), y.jsx("div", {
                        className: "grid grid-cols-1 md:grid-cols-2 gap-6",
                        children: y.jsxs("div", {
                            className: "p-6 bg-background rounded-2xl border border-white/5",
                            children: [y.jsx("h4", {
                                className: "font-display text-xl text-white",
                                children: "YF7"
                            }), y.jsx("p", {
                                className: "text-primary",
                                children: "Founder & Organizer"
                            })]
                        })
                    })]
                })]
            })
        })]
    })
}
function M3() {
    return y.jsxs(XE, {
        children: [y.jsx(er, {
            path: "/",
            component: kV
        }), y.jsx(er, {
            path: "/tournaments",
            component: HV
        }), y.jsx(er, {
            path: "/tournaments/:id",
            component: k3
        }), y.jsx(er, {
            path: "/rules",
            component: N3
        }), y.jsx(er, {
            path: "/winners",
            component: R3
        }), y.jsx(er, {
            path: "/partners",
            component: j3
        }), y.jsx(er, {
            path: "/about",
            component: D3
        }), y.jsx(er, {
            path: "/organization",
            component: O3
        }), y.jsx(er, {
            path: "/admin",
            component: A3
        }), y.jsx(er, {
            component: rR
        })]
    })
}
function I3() {
    return y.jsx(v_, {
        client: j_,
        children: y.jsxs(YA, {
            children: [y.jsx(TN, {}), y.jsx(M3, {})]
        })
    })
}
kE.createRoot(document.getElementById("root")).render(y.jsx(I3, {}));

    </script>
</html>